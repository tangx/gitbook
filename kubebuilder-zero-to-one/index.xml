<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>从零开始写一个 kubebuilder</title><link>https://books.tangx.in/kubebuilder-zero-to-one/</link><description>Recent content on 从零开始写一个 kubebuilder</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://books.tangx.in/kubebuilder-zero-to-one/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://books.tangx.in/kubebuilder-zero-to-one/chapter01/01-kubebuilder-init-project/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/kubebuilder-zero-to-one/chapter01/01-kubebuilder-init-project/</guid><description>使用 kuberbuilder 初始化项目 kubebuilder init --domain tangx.in kubebuilder create api --group myapp --version v1 --kind Redis apiVersion:myapp.tangx.in/v1kind:Redismetadata:name:my-op-redisspec:replicas:1port:3333# 安装 make install # 卸载 make uninstall 查看 crd
k get crd |grep tangx.in redis.myapp.tangx.in 2021-11-19T06:16:43Z</description></item><item><title/><link>https://books.tangx.in/kubebuilder-zero-to-one/chapter01/02-simplest-redis-crd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/kubebuilder-zero-to-one/chapter01/02-simplest-redis-crd/</guid><description>简单跑一跑 定义 CRD Redis 对象字段 在 /api/v1/redis_types.go 中， 增加 Replicas 和 Port 字段。
type RedisSpec struct { // INSERT ADDITIONAL SPEC FIELDS - desired state of cluster // Important: Run &amp;#34;make&amp;#34; to regenerate code after modifying this file // Foo is an example field of Redis. Edit redis_types.go to remove/update // Foo string `json:&amp;#34;foo,omitempty&amp;#34;` Replicas int `json:&amp;#34;replicas,omitempty&amp;#34;` Port int32 `json:&amp;#34;port,omitempty&amp;#34;` } 这个 RedisSpec 对应 /deploy/my-op-redis.</description></item><item><title/><link>https://books.tangx.in/kubebuilder-zero-to-one/chapter01/03-deploy-crd-controller/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/kubebuilder-zero-to-one/chapter01/03-deploy-crd-controller/</guid><description>发布 crd controller 设置 docker server 网络代理， 避免编译的时候下载所依赖的 gcr.io 镜像失败。 参考文章 设置 docker server 网路代理
修改 Makefile, 设置默认 image name
VERSION ?= v$(shell cat .version) # Image URL to use all building/pushing image targets IMG ?= cr.docker.tangx.in/jtredis/controller:$(VERSION) 修改镜像 pull 策略。 在 /config/manager/manager.yaml 配置文件中， 添加 imagePullPolicy 策略。 由于本地开发， 并不准备上传到云上， 所以设置为 IfNotPresent。 spec:securityContext:runAsNonRoot:truecontainers:- command:- /managerargs:- --leader-electimage:controller:latestname:manager## 由于不上传到镜像仓库， 所以这里以本地编译的版本为准imagePullPolicy:IfNotPresent执行编译 make docker-build 发布 make deploy</description></item><item><title/><link>https://books.tangx.in/kubebuilder-zero-to-one/chapter02/04-filed-validation-by-comment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/kubebuilder-zero-to-one/chapter02/04-filed-validation-by-comment/</guid><description>使用注解完整字段值约束 在 /api/v1/redis_types.go 中，使用注解完成字段值约束。
约束条件必须以 //+kubebuilder:validation:&amp;lt;METHOD&amp;gt;:=&amp;lt;VALUE&amp;gt; 为格式， 符号之间 没有空格。 约束条件必须 紧邻 字段， 且在字段上方。 https://book.kubebuilder.io/reference/markers/crd-validation.html
type RedisSpec struct { // INSERT ADDITIONAL SPEC FIELDS - desired state of cluster // Important: Run &amp;#34;make&amp;#34; to regenerate code after modifying this file Replicas int `json:&amp;#34;replicas,omitempty&amp;#34;` //+kubebuilder:validation:Minimum:=1234 //+kubebuilder:validation:Maximum:=54321 Port int32 `json:&amp;#34;port,omitempty&amp;#34;` } 重新编译安装
make install 使用命令查看查看
kg crd redis.myapp.tangx.inSpec:Description:RedisSpec defines the desired state of RedisProperties:Port:Format:int32Maximum:54321Minimum:1234Type:integerReplicas:Type:integerType:object将 /deploy/my-op-redis.</description></item><item><title/><link>https://books.tangx.in/kubebuilder-zero-to-one/chapter02/05-filed-validation-by-webhook/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/kubebuilder-zero-to-one/chapter02/05-filed-validation-by-webhook/</guid><description>通过 webhook 进行字段验证 通过 kubebuilder 生成代码 # 创建 api kubebuilder create api --group myapp --version v1 --kind Redis # 创建 api 的 webhook kubebuilder create webhook --group myapp --version v1 --kind Redis --defaulting --programmatic-validation 增加 webhook 条件 在 /api/v1/redis_webhook.go 中增加检查条件。
检查 webhook 被触发有三个条件 Create / Update / Delete 时间节点, 分别对应三个方法。
如下是 创建时检查
func (r *Redis) ValidateCreate() error { redislog.</description></item><item><title/><link>https://books.tangx.in/kubebuilder-zero-to-one/chapter02/06-create-pod-by-redis-operator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/kubebuilder-zero-to-one/chapter02/06-create-pod-by-redis-operator/</guid><description>使用 Operator 创建并发布一个 Pod 1. 组装 k8s api 创建 pod 创建 /controllers/helper 目录， 这里面的代码实现 k8s Workloads 的创建。 具体实现就是封装 k8s workloads 的 api 对象
// CreateRedis 创建 redis pod func CreateRedisPod2(ctx context.Context, client client.Client, config *appv1.Redis) error { pod := &amp;amp;corev1.Pod{} pod.Name = config.Name pod.Namespace = config.Namespace pod.Spec.Containers = []corev1.Container{ { Name: config.Name, Image: config.Spec.Image, ImagePullPolicy: corev1.PullIfNotPresent, Ports: []corev1.ContainerPort{ { ContainerPort: config.Spec.Port, }, }, }, } // ctx := context.</description></item><item><title/><link>https://books.tangx.in/kubebuilder-zero-to-one/chapter02/07-1-delete-pod-by-redis-OwnerReference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/kubebuilder-zero-to-one/chapter02/07-1-delete-pod-by-redis-OwnerReference/</guid><description>使用 OwnerReference 管理 redis operator 创建的 Pod https://kubernetes.io/blog/2021/05/14/using-finalizers-to-control-deletion/
在上一章的代码可以通过如下命令创建一个 redis 实例， 并随即创建一个 Pod
ka -f deploy/ 但是在使用如下命令删除 redis 实例时， 虽然命令行界面提示删除成功， 但是创建的 Pod 依旧存在。
krm -f deploy/ 其原因是 redis 实例 与 Pod 之间 没有 建立关联关系。
那要如何创建关联关系呢？ 可以参考阅读官方博客， 使用 finalizer 控制删除。
在 Owner Reference 一节中提到了资源的 父子关系 。
根据这个原理， 更新 /controllers/helper/redis_helper.go 的 Pod 创建 API， 加入 OwnerReference 相关的代码。
// CreateRedis 创建 redis pod func CreateRedisPod(ctx context.Context, client client.</description></item><item><title/><link>https://books.tangx.in/kubebuilder-zero-to-one/chapter02/07-2-delete-pod-by-finalizers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/kubebuilder-zero-to-one/chapter02/07-2-delete-pod-by-finalizers/</guid><description>使用 finalizers 管理 redis operator 创建的 Pod https://kubernetes.io/blog/2021/05/14/using-finalizers-to-control-deletion/
上一章使用了 OwnerReference 关联 redis instance 和所创建的 Pod， 这里的删除是通过 k8s 内置的关系处理器处理的。
根据官方博客文档中的阐述， 当一个资源的额 finalizers 没有被清空时， 这个资源将无法被删除。 因此， 本章通过 finalizers
来建立 redis instance 和所创建 pod 的关系， 以及处理删除逻辑 1. 创建 redis instance 与 pod 的关系 在 /controllers/helper/redis_helper.go 通过 Finalizers 管理 Pod
// CreateRedis 创建 redis pod func CreateRedisPod2(ctx context.Context, client client.Client, redis *appv1.Redis) error { isUpdated := false for i := 0; i &amp;lt; redis.</description></item><item><title/><link>https://books.tangx.in/kubebuilder-zero-to-one/chapter02/08-scale-pod/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/kubebuilder-zero-to-one/chapter02/08-scale-pod/</guid><description>Pod 扩容与缩容 代码分支越来越多 增/删/改 都有了， 于是选择拆分为 3 个分支。
// 扩容 func (r *RedisReconciler) increaseReconcile(ctx context.Context, redis *myappv1.Redis) (ctrl.Result, error) { // ... } // 缩容 func (r *RedisReconciler) decreaseReconcile(ctx context.Context, redis *myappv1.Redis) (ctrl.Result, error) { // ... } // 删除 func (r *RedisReconciler) deleteReconcile(ctx context.Context, redis *myappv1.Redis) (ctrl.Result, error) { // ... } 所谓 扩容/缩容， 在通过 finalizers 管理的时候就是 redis.spec.replicas 与 len(redis.finalizers) 的大小比较。
// 缩容 if len(redis.</description></item><item><title/><link>https://books.tangx.in/kubebuilder-zero-to-one/chapter02/09-watch-k8s-event/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/kubebuilder-zero-to-one/chapter02/09-watch-k8s-event/</guid><description>监听 k8s 事件 之前的代码遗留了一个问题， 当手动通过命令删除 pod 时候， 不会出发 redis.Finalizers 的更新， 也不会重建被删除的 Pod， 实现效果并不好
kubectl delete pod pod_name 1. 监听事件 在 /controllers/redis_controller.go 中生成了对象和方法监听 k8s 的事件。
ctrl 创建的 Builder 可以通过 链式 调用方式， 监听多个 k8s 对象的事件。
// SetupWithManager sets up the controller with the Manager. func (r *RedisReconciler) SetupWithManager(mgr ctrl.Manager) error { return ctrl.NewControllerManagedBy(mgr). For(&amp;amp;myappv1.Redis{}). // 监听 pod 事件 Watches( &amp;amp;source.Kind{Type: &amp;amp;corev1.Pod{}}, handler.Funcs{DeleteFunc: r.podDeleteHandler}, ).</description></item><item><title/><link>https://books.tangx.in/kubebuilder-zero-to-one/chapter02/10-recreate-deleted-pod/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/kubebuilder-zero-to-one/chapter02/10-recreate-deleted-pod/</guid><description>重建被删除的 Pod 之前遗留了一个问题， 直接用命令行删除的 Pod 不能被重建。 这次就来解决它。
首先来整理之前遗留的问题故障点在哪里？
使用命令 kubectl delete 直接删除 pod 的时候， redis.Finalizers 不会变更， 依旧包含被删除的 pod.Name。 在创建 Pod 的时候， 判断 Pod 是否存在使用的是 redis.Finalizers 提供信息， 而 没有判断 k8s 中真实的情况。 没有机制 通知 redis operator 进行检测或重建。 因此全新流程如下
Pod 状态变化: kubectl delete 删除 Pod Redis 重新调谐: 通知 Redis operator 变化， 重新启动 调谐(Reconcile) 创建 Pod 的逻辑如下 如果 Pod 在 k8s 中存在， 则跳过。 （为了降低复杂性， 不考虑直接改变 redis.finalizers 的情况） 如果 Pod 不存在， 创建 Pod。 是否更新 redis.</description></item><item><title/><link>https://books.tangx.in/kubebuilder-zero-to-one/chapter02/11-official-package-optimize/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/kubebuilder-zero-to-one/chapter02/11-official-package-optimize/</guid><description>使用 controllerutil 优化代码 在之前的代码中， 对于 OwnerReference 和 Finalizers 操作我们自己实现了一些方法。 其实这些操作官方已经封好成包了， 开箱即用。
复制 /controllers/helper 保存为 /controllers/helper2。 前者保存手工代码， 后者保存优化代码。
https://pkg.go.dev/sigs.k8s.io/controller-runtime/pkg/controller/controllerutil
Finalizers 操作 之前
// 添加 func appendFinalizers(redis *appv1.Redis, name string){ // 如果 pod.Name 不在 finalizers 中， 则为新增 pod。 // 使用 Finalizer 管理创建的 Pod。 当 pod 被删除完的时候，才能删除 redis redis.Finalizers = append(redis.Finalizers, name) } // 存在判断 func isPodExistInFinalizers2(redis *appv1.Redis, name string) bool { for _, rname := range redis.</description></item><item><title/><link>https://books.tangx.in/kubebuilder-zero-to-one/chapter03/12-add-event/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/kubebuilder-zero-to-one/chapter03/12-add-event/</guid><description>增加 event 事件支持 k8s 官方 controller 都实现了 Events 消息信息， 如下
kubectl describe deployment k8s-operator-demo-controller-manager Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal ScalingReplicaSet 15m deployment-controller Scaled up replica set k8s-operator-demo-controller-manager-75cc59d8ff to 1 Normal ScalingReplicaSet 14m deployment-controller Scaled down replica set k8s-operator-demo-controller-manager-b9d9f7886 to 0 我们自定义的 Operator 同样可以实现。
operator 支持 event 在 /controllers/redis_controller.go 中定义 RedisReconcile 的时候， 添加 EventRecord 字段。 // RedisReconciler reconciles a Redis object type RedisReconciler struct { client.</description></item><item><title/><link>https://books.tangx.in/kubebuilder-zero-to-one/chapter03/13-add-status/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/kubebuilder-zero-to-one/chapter03/13-add-status/</guid><description>添加 Status 状态字段 添加 kd 状态字段 在 /api/v1/redis_types.go 的 RedisStatus 中添加需要展示的字段。
这里添加一个副本数量。
type RedisStatus struct { // INSERT ADDITIONAL STATUS FIELD - define observed state of cluster // Important: Run &amp;#34;make&amp;#34; to regenerate code after modifying this file Replicas int `json:&amp;#34;replicas&amp;#34;` } 偷懒， 没有在创建或删除 pod 时进行精细控制。 而是使用 defer 在 Reconcile 退出的时候进行一次最终的赋值管理。
func (r *RedisReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) { fmt.</description></item><item><title/><link>https://books.tangx.in/kubebuilder-zero-to-one/chapter03/14-kubectl-scale-autoscale-support/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/kubebuilder-zero-to-one/chapter03/14-kubectl-scale-autoscale-support/</guid><description>支持 kubectl scale 和 kubectl autoscale 命令 在 k8s 自定义资源中有关于 scale 和 hpa 的 subresources 字段， 只有这些字段被定义的时候才能支持 scale 和 autoscale 命令
官方定义如下
https://kubernetes.io/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#scale-subresource
在 kubebuilde 中， 使用 //+kubebuilder:subresource:scale 增加注解， 生成对应的配置。
注意， 未知需要在 //+kubebuilder:subresource:status 下方
//+kubebuilder:object:root=true //+kubebuilder:subresource:status //+kubebuilder:subresource:scale:specpath=.spec.replicas,statuspath=.status.replicas,selectorpath=.status.selector 三个关键字段:
specpath: specReplicasPath 指定定制资源内与 scale.spec.replicas 对应的 JSON 路径。
此字段为 必需值 。 只可以使用 .spec 下的 JSON 路径，只可使用带句点的路径。 如果定制资源的 specReplicasPath 下没有取值，则针对 /scale 子资源执行 GET 操作时会返回错误。 statuspath: statusReplicasPath 指定定制资源内与 scale.</description></item><item><title/><link>https://books.tangx.in/kubebuilder-zero-to-one/README/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/kubebuilder-zero-to-one/README/</guid><description>kubebuilder 从 0 到 1 从 0 开始写一个 Redis Operator
feed</description></item><item><title/><link>https://books.tangx.in/kubebuilder-zero-to-one/SUMMARY/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/kubebuilder-zero-to-one/SUMMARY/</guid><description>目录 使用 kuberbuilder 初始化项目 简单跑一跑 发布 crd controller 使用注解完整字段值约束 通过 webhook 进行字段验证 使用 Operator 创建并发布一个 Pod K8S 父子资源删除管理 使用 OwnerReference 管理 redis operator 创建的 Pod 使用 finalizers 管理 redis operator 创建的 Pod Pod 扩容与缩容 监听 k8s 事件 重建被删除的 Pod 使用 controllerutil 优化代码 增加 event 事件支持 添加 Status 状态字段</description></item></channel></rss>