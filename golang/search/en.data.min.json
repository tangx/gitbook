[{"id":0,"href":"/books/golang/","title":"","parent":"","content":" golang 学习笔记 简介 一些高大上的话\n必读的书 《Go语言圣经》 入门经典， 进阶提升。\n中文版: https://golang-china.github.io/gopl-zh/ 《Go标准库》 帮你了解最核心的用法， 但是零散， 不成体系。\n官方英文版(最新最全): https://pkg.go.dev/std 中文版: https://studygolang.com/pkgdoc 《Go 语言设计与实现》 进阶提升， 了解原理\nhttps://draveness.me/golang/ 网友分享的 「Go 每日一库」， 这部分大多介绍开源好用的第三方库。 扩展知识面。\nGo Roadmap ","description":" golang 学习笔记 简介 一些高大上的话\n必读的书 《Go语言圣经》 入门经典， 进阶提升。\n中文版: https://golang-china.github.io/gopl-zh/ 《Go标准库》 帮你了解最核心的用法， 但是零散， 不成体系。\n官方英文版(最新最全): https://pkg.go.dev/std 中文版: https://studygolang.com/pkgdoc 《Go 语言设计与实现》 进阶提升， 了解原理\nhttps://draveness.me/golang/ 网友分享的 「Go 每日一库」， 这部分大多介绍开源好用的第三方库。 扩展知识面。\nGo Roadmap "},{"id":1,"href":"/books/golang/startup/","title":"01. Go开发环境配置","parent":"","content":"","description":""},{"id":2,"href":"/books/golang/shell-to-go/variable/","title":"01. 变量声明","parent":"02. Go基础语法: Shell to Go","content":" 变量声明 Shell 声明变量 在 Shell 中， 变量声明通常有两种方式\n通过 declare 进行变量声明， 并赋值。 省略 declare 进行变量声明。 # 方式1 declare abc=\u0026#34;abc\u0026#34; declare abc_123=123 # 方式2 abc=\u0026#34;abc\u0026#34; abc_123=123 事实上， declare 的用法还是很复杂的， 更多可以参考: https://www.runoob.com/linux/linux-comm-declare.html\nGo 声明变量 在 Go 中， 也有两种方式\n通过 var 关键字定义， 这种方式可以在 任意位置 定义变量。 省略 var 后， 可以使用 := 进行变量声明。 但是这种方式只能在 代码块 中使用， 可以简单的理解为 只能在函数中使用。 var abc int8 = 100 // 指定 abc 的类型是 int8 var def = 100 // 推定类型为 int func demo() { a1 := 100 var a2 = 100 fmt.Println(a1, a2) } 弱类型与强类型 有句笑话说： 动态类型一时爽， 重构全是火葬场\nShell 中， 变量是完完全全的 弱类型（动态类型）。 换句话说， 同一个变量名可以是 字符串， 也可以是 数字， 也可以是其他的。\nabc=\u0026#34;word\u0026#34; # 字符串 abc=123 # 数字 abc=(value1 value2) # 数组 而 Go 是一个完完全全的 强类型 语言。 如果变量声明时是 字符串， 那么绝对不能再重新被赋值为 数字。\nfunc assignment() { abc := \u0026#34;word\u0026#34; abc = 123 // 报错: cannot use 123 (untyped int constant) as string value fmt.Println(abc) } 更有甚者， Go 语言数字还分 有无符号， 各种长度， 之间也是不能互相通用的。\nint, int8, int16, int32, int64 uint, uint8, uint16, uint32, uint64 func assignmentNumber() { var n int = 100 var n8 int8 n8 = n // cannot use n (variable of type int) as int8 value fmt.Println(n8) } 常量(只读变量) 常量， 可以理解未 不可变 的变量， 也就是 只读。\nShell 设置常量 在 Shell 中， 使用 readonly 关键字来声明常量\nreadonly abc=100 readonly abc=1000 # bash: abc: readonly variable Go 设置常量 在 Go 中， 使用 const 关键字来声明常量。\nconst abc=100 // var abc=1000 初次之外， Go 语言中还有 iota 这种特殊的用法。\nconst ( Monday = 0 Tuesday = iota // 2 _ // 3。 周 3 跳过, 但使用站位符是 iota 递增 Thursday = iota // 4 // Friday // Saturday Sunday = iota + 2 // 7。 5和6不存在， 因此 Sunday 是 iota+2 ) 使用 iota 之后， 组内的的常量值会依次递增。\n可以通过 _ 占位符， 顺序递增。 可以使用 iota+n 实现 跳值。 总结 除了 弱类型和强类型 之外， 其他大部分使用方式都差不多。\n","description":"变量声明 Shell 声明变量 在 Shell 中， 变量声明通常有两种方式\n通过 declare 进行变量声明， 并赋值。 省略 declare 进行变量声明。 # 方式1 declare abc=\u0026#34;abc\u0026#34; declare abc_123=123 # 方式2 abc=\u0026#34;abc\u0026#34; abc_123=123 事实上， declare 的用法还是很复杂的， 更多可以参考: https://www.runoob.com/linux/linux-comm-declare.html\nGo 声明变量 在 Go 中， 也有两种方式\n通过 var 关键字定义， 这种方式可以在 任意位置 定义变量。 省略 var 后， 可以使用 := 进行变量声明。 但是这种方式只能在 代码块 中使用， 可以简单的理解为 只能在函数中使用。 var abc int8 = 100 // 指定 abc 的类型是 int8 var def = 100 // 推定类型为 int func demo() { a1 := 100 var a2 = 100 fmt."},{"id":3,"href":"/books/golang/shell-to-go/process-control/if-else/","title":"01. 条件语句 (if)","parent":"03. 流程控制","content":" Shell function abc() { n=$1 if [ $n -gt 100 ]; then { # 括号可有可无 echo \u0026#34;无效\u0026#34; } elif [ $n -gt 90 ]; then echo \u0026#34;优秀\u0026#34; else { echo \u0026#34;一般\u0026#34; } fi } 在 Shell 中，\nif-else-fi 是通过关键字约束 语句块 边界的。 大括号 {} 可有可无， 但是最好还是带上， 增强可读性。 判断条件使用 方括号 [ ] 或 [[ ]] 定义。 Go func if_else(n int) { if n \u0026gt;= 100 || n \u0026lt;= -1 { fmt.Println(\u0026#34;无效\u0026#34;) } else if n \u0026gt; 90 { fmt.Println(\u0026#34;优秀\u0026#34;) } else { fmt.Println(\u0026#34;一般\u0026#34;) } } 在 Go 中，\n大括号 {} 是语句块的定义， 必须存在。 没有关键字 then, elif, fi。 Go 中的逻辑运算符 \u0026amp;\u0026amp; 与 || 或 ! 非 这点在 Shell 中使一致的。\n关系运算符 == 等于， != 不等于 \u0026gt;, \u0026lt;, \u0026gt;=, \u0026lt;= 很直观。 ","description":"Shell function abc() { n=$1 if [ $n -gt 100 ]; then { # 括号可有可无 echo \u0026#34;无效\u0026#34; } elif [ $n -gt 90 ]; then echo \u0026#34;优秀\u0026#34; else { echo \u0026#34;一般\u0026#34; } fi } 在 Shell 中，\nif-else-fi 是通过关键字约束 语句块 边界的。 大括号 {} 可有可无， 但是最好还是带上， 增强可读性。 判断条件使用 方括号 [ ] 或 [[ ]] 定义。 Go func if_else(n int) { if n \u0026gt;= 100 || n \u0026lt;= -1 { fmt.Println(\u0026#34;无效\u0026#34;) } else if n \u0026gt; 90 { fmt."},{"id":4,"href":"/books/golang/daily-notes/environment/","title":"01. 环境变量操作","parent":"06. Go 应用笔记","content":" 一篇文章告诉你 golang 环境变量的所有基础操作 原文链接： https://typonotes.com/posts/2021/09/06/golang-os-env-operation/\ngolang 中的环境变量操作都在 os 包下面， 只有很少的几个方法， 而且字面意思也很明确。\n所有环境变量操作对象都是 字符串string ， 因此对于 int， bool 类型需要自己实现转换。\ngolang 程序执行的时候， 是在 linux 系统中 fork 的一种子进程中\ngolang程序 在 复制了开始运行的那一瞬间的当前环境所有变量， 之后的父进程中的变量变化不再影响 golang 程序。 golang 程序对环境变量的所有操作，都是在自身的子进程中，因此 只会影响 golang 程序本身。 go 语言中没有类似 bash 中的 export 的操作。 但是可以通过 os.Setenv 设置环境变量。 环境变量操作方法 1. os.Setenv(\u0026quot;key\u0026quot;,\u0026quot;val\u0026quot;) 创建一个环境变量\n2. os.Unsetenv(\u0026quot;key\u0026quot;) 取消一个变量\n3. val=os.Getenv(\u0026quot;key\u0026quot;) 返回一个变量的值。 如果变量不存在， val 为空字符串。 使用 len(val)==0 无法判断 变量值为空 或者 变量不存在\n4. val,ok=os.LookupEnv(\u0026quot;key\u0026quot;) 返回一个变量的值 与 变量是否存在的 bool 结果。\n如果变量存在， val 为值， ok 为 true\n如果变量不存在， val 为空字符串， ok 为 false\n注意， 变量不存在 (ok=false) 和 变量值为空 (ok=true) 不一样\n5. os.Clearenv() 清空所有变量。 危险 慎用。\n6. envs=os.Environ() 返回包含所有变量的 []string 切片 副本 。\n由于 os.Environ() 返回的是一个 []string 切片， 在某些场景下， 如果要进行 传递并检索 的时候， 并不是很方便， 因此会有需求转换成 map[string]string 。\n在这里 需要额外小心， 如果变量值中存在 等号 = 的话， 使用 strings.Split 进行分割之后， 而没有再使用 strings.Join 合并时， 可能会造成数据丢失。 有点拗口， 看例子。\n因为一下语句时合法的\nVAR=key1=val1,key2=val2 这句话赋值语句表示将\u0026amp; 字符串 key1=val1,key2=val2 赋值给 变量 VAR\n例如下面这段代码, envutils - fix: lost value when trans env string slice into map\n_ = os.Setenv(\u0026#34;VAR\u0026#34;, \u0026#34;key=val1,key2=val2\u0026#34;) m := make(map[string]string) envs := os.Environ() for _, pair := range envs { kv := strings.Split(pair, \u0026#34;=\u0026#34;) // m[kv[0]] = kv[1] // wrong: VAR=key 与实际情况不符合 m[kv[0]] = strings.Join(kv[1:], \u0026#34;=\u0026#34;) // 注意这里要使用 Join } 7. os.ExpandEnv(\u0026quot;string\u0026quot;) or os.Expand(\u0026quot;string\u0026quot;,os.Getenv) 如果 string 中包含 $key 或者 ${key} 的 占位符 ， 则将被替换为实际的值。就是 bash 中的变量用法。\nfunc Test_ExpandEnv(t *testing.T) { _ = os.Setenv(\u0026#34;MY_Age\u0026#34;, \u0026#34;18\u0026#34;) _ = os.Setenv(\u0026#34;MY_Name\u0026#34;, \u0026#34;Zhangsan\u0026#34;) // MY_age 大小写不匹配。 result := os.ExpandEnv(\u0026#34;my name is ${MY_Name}, i\u0026#39;m $MY_age years old\u0026#34;) fmt.Println(result) // my name is Zhangsan, i\u0026#39;m years old } ","description":"一篇文章告诉你 golang 环境变量的所有基础操作 原文链接： https://typonotes.com/posts/2021/09/06/golang-os-env-operation/\ngolang 中的环境变量操作都在 os 包下面， 只有很少的几个方法， 而且字面意思也很明确。\n所有环境变量操作对象都是 字符串string ， 因此对于 int， bool 类型需要自己实现转换。\ngolang 程序执行的时候， 是在 linux 系统中 fork 的一种子进程中\ngolang程序 在 复制了开始运行的那一瞬间的当前环境所有变量， 之后的父进程中的变量变化不再影响 golang 程序。 golang 程序对环境变量的所有操作，都是在自身的子进程中，因此 只会影响 golang 程序本身。 go 语言中没有类似 bash 中的 export 的操作。 但是可以通过 os.Setenv 设置环境变量。 环境变量操作方法 1. os.Setenv(\u0026quot;key\u0026quot;,\u0026quot;val\u0026quot;) 创建一个环境变量\n2. os.Unsetenv(\u0026quot;key\u0026quot;) 取消一个变量\n3. val=os.Getenv(\u0026quot;key\u0026quot;) 返回一个变量的值。 如果变量不存在， val 为空字符串。 使用 len(val)==0 无法判断 变量值为空 或者 变量不存在\n4. val,ok=os.LookupEnv(\u0026quot;key\u0026quot;) 返回一个变量的值 与 变量是否存在的 bool 结果。"},{"id":5,"href":"/books/golang/go-features/struct/","title":"01. 结构体 Struct","parent":"03. Go 特性语法","content":"","description":""},{"id":6,"href":"/books/golang/startup/introduce/","title":"01. 项目简介","parent":"01. Go开发环境配置","content":"","description":""},{"id":7,"href":"/books/golang/daily-notes/timezone/","title":"02. Go 的时区管理","parent":"06. Go 应用笔记","content":" 这些关于 Golang timezone 时区的坑， 我已经帮你踩过了 原文链接: https://typonotes.com/posts/2023/01/09/golang-timezone-issue/\nGolang 中一些不太注意的时区问题\n1. time/tzdata 库 Golang 内置的一个时区文件。\n可以在程序中任意位置被导入。 导入后， 如果程序 找不到本地 时区文件， 就会使用该库的数据。 本地 指的是 运行环境， 可能是实际的服务器， 也可能是容器。 通常， 应该在 main.go 中被导入。 如果是 库代码 则 不应该 导入该文件。 导入该文件后， 程序会增加 450KB 大小。 import ( _ \u0026#34;time/tzdata\u0026#34; ) 在老版本（1.15）以前并不包含时区信息， 通常会在容器化的时候单独处理时区问题。\nFROM golang:alpine as build RUN apk --no-cache add tzdata WORKDIR /app ADD . . RUN CGO_ENABLED=0 GOOS=linux go build -o myapp FROM scratch as final COPY --from=build /app/myapp . COPY --from=build /usr/share/zoneinfo /usr/share/zoneinfo ENV TZ=Europe/Berlin CMD [\u0026#34;/myapp\u0026#34;] 2. time.Parse and time.ParseInLocation 使用 time.Parse 解析时间， 默认 时区是 UTC。 使用 time.ParseInLocation 解析时间， 可以指定时区 func timeStr2Time() { timeStr := \u0026#34;2023-01-09 22:13:17\u0026#34; // 返回的是UTC时间 // 2023-01-09 22:13:17 +0000 UTC utcTimeObj, err := time.Parse(\u0026#34;2006-01-02 15:04:05\u0026#34;, timeStr) if err == nil { fmt.Println(\u0026#34;time.Parse\u0026#34;, utcTimeObj, utcTimeObj.Unix()) } // 返回的是当地时间 // 2023-01-09 22:13:17 +0800 CST localTimeObj, err := time.ParseInLocation(\u0026#34;2006-01-02 15:04:05\u0026#34;, timeStr, time.Local) if err == nil { fmt.Println(\u0026#34;time.ParseLocation\u0026#34;, localTimeObj, localTimeObj.Unix()) } } 3. 内部时区管理 默认情况下， 程序使用 程序运行的本地时区 Go提供了两个函数快速转换 时区 time.UTC() time.Local() 使用 LoadLocation(name) 设置时区。 使用 In(loc) 使用时区 func setTimezone() { n1.UTC() // 转换为 UTC 时区 n1.Local() // 转换为 本地时区 n1.Location() // 返回当前时间时区 // 没怎么用过 // loc := time.LoadLocationFromTZData() loc2, _ := time.LoadLocation(\u0026#34;Asia/Shanghai\u0026#34;) n1 := time.Now().In(loc2) fmt.Println(n1) } 4. 通过代码设置时区 在 实践操作 中 不允许 通过 代码 为 程序 本身设置时区的。\n上面提到的 不允许， 说明\n行为上 可以通过代码设置时区。 事实上 无法控制结果。 4.1 通过环境变量设置时区 可以通过设置 环境变量 的方式， 设置程序时区。\n// $ date # 本地时区 CST // Mon Jan 9 23:43:03 CST 2023 func setTimezone() { os.Setenv(\u0026#34;TZ\u0026#34;, \u0026#34;UTC\u0026#34;) fmt.Println(time.Now()) // 2023-01-09 15:42:51.309248 +0000 UTC m=+0.000084251 } 但是， 之后就 再也无法改变 时区了。\nfunc setTimezone() { os.Setenv(\u0026#34;TZ\u0026#34;, \u0026#34;UTC\u0026#34;) fmt.Println(time.Now()) os.Setenv(\u0026#34;TZ\u0026#34;, \u0026#34;Asia/Shanghai\u0026#34;) fmt.Println(time.Now()) } // 注意看第二个时间也是 UTC 时间 // 2023-01-09 15:46:41.130211 +0000 UTC m=+0.000180001 // 2023-01-09 15:46:41.130284 +0000 UTC m=+0.000253042 不仅如此， 如果之前执行过时间命令， 那么 即使第一次设置 时区也是无效的。\nfunc setTimezone() { fmt.Println(time.Now()) os.Setenv(\u0026#34;TZ\u0026#34;, \u0026#34;UTC\u0026#34;) fmt.Println(time.Now()) } // 2023-01-09 23:48:52.72857 +0800 CST m=+0.000167418 // 2023-01-09 23:48:52.729103 +0800 CST m=+0.000696960 总结， 时间操作的顺序会 影响 时区的设置。\n设置时区 到目前为止， 我还是只能老老实实去 运行环境 中操作， 设置 环境变量 TZ。\nexport TZ=Asia/Shanghai 具体可以参考 在容器中设置时区原来这么简单。\n除此之外， 还没找到其它好的办法。\n","description":"这些关于 Golang timezone 时区的坑， 我已经帮你踩过了 原文链接: https://typonotes.com/posts/2023/01/09/golang-timezone-issue/\nGolang 中一些不太注意的时区问题\n1. time/tzdata 库 Golang 内置的一个时区文件。\n可以在程序中任意位置被导入。 导入后， 如果程序 找不到本地 时区文件， 就会使用该库的数据。 本地 指的是 运行环境， 可能是实际的服务器， 也可能是容器。 通常， 应该在 main.go 中被导入。 如果是 库代码 则 不应该 导入该文件。 导入该文件后， 程序会增加 450KB 大小。 import ( _ \u0026#34;time/tzdata\u0026#34; ) 在老版本（1.15）以前并不包含时区信息， 通常会在容器化的时候单独处理时区问题。\nFROM golang:alpine as build RUN apk --no-cache add tzdata WORKDIR /app ADD . . RUN CGO_ENABLED=0 GOOS=linux go build -o myapp FROM scratch as final COPY --from=build /app/myapp ."},{"id":8,"href":"/books/golang/shell-to-go/","title":"02. Go基础语法: Shell to Go","parent":"","content":"","description":""},{"id":9,"href":"/books/golang/go-features/context/","title":"02. 上下文 Context","parent":"03. Go 特性语法","content":"","description":""},{"id":10,"href":"/books/golang/startup/install/","title":"02. 下载安装与环境配置","parent":"01. Go开发环境配置","content":" 下载和安装 前往 官网Go下载地址 页面下载与自己操作系统对应二进制文件。\n通常我会选择压缩包， 然后解压到所需要安装的目录。\n例如， 我是 mac 的 intel 系统， go1.19.6.darwin-amd64.tar.gz\ncd /tmp wget -c https://go.dev/dl/go1.19.6.darwin-amd64.tar.gz sudo tar xf go1.19.6.darwin-amd64.tar.gz -C /usr/local 配置环境变量 GOPROXY: Go代理地址， 通常使用 https://goproxy.cn 或 https://goproxy.io GOROOT: Go 二进制的位置, 即我们上面解压目录的 /usr/local/go GOPATH: 这个是我们项目代码的位置， 有了 go mod 之后 不是绝对的了 使用 go install 后， 编译的二进制会默认在 $GOPATH/bin/ 使用 go get 下载的所有库文件在 $GOPATH/pkg/mod/ 中 可以直接 go mod init， 如果项目在 $GOPATH/src/ 中， 会默认以相对目录配置 module 路径。 对于 Mac 和 Linux 系统， 设置环境变量。 配置到 /etc/profile 中。\nexport GOPROXY=\u0026#34;https://goproxy.cn\u0026#34; export GOROOT=\u0026#34;/usr/local/go\u0026#34; export GOPATH=\u0026#34;/data/gopath\u0026#34; export PATH=\u0026#34;$GOROOT/bin:$GOPATH/bin:$PATH\u0026#34; 执行 go version 命令测试结果。\n$ go version go version go1.19.6 darwin/amd64 关于Go版本的选择 我会选择使用 次新版本(当前为 v1.19.z) ， 并随时保持更新。 当 最新版本(当前为 1.20.z) 的 z 编号 不小于5 （即 1.20.5）的时候， 才会选择升级到最新版本。 个人意见， 仅供参考。\n","description":"下载和安装 前往 官网Go下载地址 页面下载与自己操作系统对应二进制文件。\n通常我会选择压缩包， 然后解压到所需要安装的目录。\n例如， 我是 mac 的 intel 系统， go1.19.6.darwin-amd64.tar.gz\ncd /tmp wget -c https://go.dev/dl/go1.19.6.darwin-amd64.tar.gz sudo tar xf go1.19.6.darwin-amd64.tar.gz -C /usr/local 配置环境变量 GOPROXY: Go代理地址， 通常使用 https://goproxy.cn 或 https://goproxy.io GOROOT: Go 二进制的位置, 即我们上面解压目录的 /usr/local/go GOPATH: 这个是我们项目代码的位置， 有了 go mod 之后 不是绝对的了 使用 go install 后， 编译的二进制会默认在 $GOPATH/bin/ 使用 go get 下载的所有库文件在 $GOPATH/pkg/mod/ 中 可以直接 go mod init， 如果项目在 $GOPATH/src/ 中， 会默认以相对目录配置 module 路径。 对于 Mac 和 Linux 系统， 设置环境变量。 配置到 /etc/profile 中。"},{"id":11,"href":"/books/golang/shell-to-go/function/","title":"02. 函数","parent":"02. Go基础语法: Shell to Go","content":"","description":""},{"id":12,"href":"/books/golang/shell-to-go/basic-type/","title":"02. 基础数据类型","parent":"02. Go基础语法: Shell to Go","content":"","description":""},{"id":13,"href":"/books/golang/shell-to-go/process-control/for-loops/","title":"02. 循环语句 (for / while)","parent":"03. 流程控制","content":" Go 循环 在 Go 中， 循环只有一个关键字 for， 通过不同的 格式 实现不同的逻辑\n基本格式如下\nfor 默认值; 条件; 计数器 { fmt.Println(\u0026#34;i=\u0026#34;, i) } 以上的 每一个字段都可以省略 。\n计数循环 在 shell 中， 通常使用 seq 实现计数循环\nfor i in $(seq 1 10); do { echo \u0026#34;i = $i\u0026#34; } done 而在 Go 中，\nfor i := 0; i \u0026lt; 1; i++ { fmt.Println(\u0026#34;i=\u0026#34;, i) } 遍历循环 for name in zhangsan lisi wangwu zhaoliu; do { echo \u0026#34;name = $name\u0026#34; } done 在 Go 中， 需要将对象放入到 切片 中\nfunc rangeSlice() { names := []string{\u0026#34;zhangsan\u0026#34;, \u0026#34;lisi\u0026#34;, \u0026#34;wangwu\u0026#34;, \u0026#34;zhaoliu\u0026#34;} for idx, value := range names { fmt.Println(names[idx], value) } } 其中， idx 为索引编号。\n遍历 map 对象 另外， 如果遍历对象是 map\nfunc rangeMap() { users := map[string]int{ \u0026#34;zhangsan\u0026#34;: 20, \u0026#34;lisi\u0026#34;: 30, \u0026#34;wangwu\u0026#34;: 40, } for key, value := range users { fmt.Println(key, value) } } 则第一个参数为 key。 而非索引。\n注意: value 在循环中， 都可以 省略， 只获取 idx 或 key。 取值的时候， 就使用 names[key] 这种方式。\nWhile 循环 在 shell 中， 使用 while 实现条件语句。 如果条件 恒真 则使用 True 或 : 实现。\nwhile True; do { date sleep 1 } done 在 Go 中， 省去前后两段， 实现条件 a\u0026lt;=b\nfor ; a\u0026lt;=b ; { fmt.Println(time.Now()) time.Sleep(1 * time.Second) } // 死循环 for { fmt.Println(time.Now()) time.Sleep(1 * time.Second) } 如果条件 恒真 则为死循环， 省略所有条件语句即可。\n跳出循环 跳出循环使用的两个关键字， 用法与 Shell 相同。\ncontinue: 结束当前循环语句， 进入下一次循环。 break: 退出所有循环， 不再执行剩下的循环次数。 for i := 1; i \u0026lt;= 10; i++ { if i%2 == 0 { // 当 i 是双数的时候， 退出当前循环 continue } if i \u0026gt; 6 { // 当 i 大于 6 的时候， 结束所有循环 break } fmt.Println(i) } 实际输出结果为 1, 3, 5。 注意， i 实际是等于 7 的时候才结束整个循环的。\n","description":"Go 循环 在 Go 中， 循环只有一个关键字 for， 通过不同的 格式 实现不同的逻辑\n基本格式如下\nfor 默认值; 条件; 计数器 { fmt.Println(\u0026#34;i=\u0026#34;, i) } 以上的 每一个字段都可以省略 。\n计数循环 在 shell 中， 通常使用 seq 实现计数循环\nfor i in $(seq 1 10); do { echo \u0026#34;i = $i\u0026#34; } done 而在 Go 中，\nfor i := 0; i \u0026lt; 1; i++ { fmt.Println(\u0026#34;i=\u0026#34;, i) } 遍历循环 for name in zhangsan lisi wangwu zhaoliu; do { echo \u0026#34;name = $name\u0026#34; } done 在 Go 中， 需要将对象放入到 切片 中"},{"id":14,"href":"/books/golang/go-features/","title":"03. Go 特性语法","parent":"","content":"","description":""},{"id":15,"href":"/books/golang/go-features/golang-interface/","title":"03. Golang 接口(interface)","parent":"03. Go 特性语法","content":" Golang 接口(interface) 简介和入门使用 上下文 interface 应该是 Go语言 中一个极其重要的 基石 概念了。\n这里有一篇 Go 语言设计与实现 - 接口 interface ， 是目前我学习的资料中 完成度 和 友善度 都很高的一篇文章。\n在 go v1.18 中， interface 有了一个别名 any。 所以在说 interface 和 any 的时候， 其实说的是相同的东西。\ninterface 的使用场景到处都是。 还记得我们之前说的 JSON 和 YAML 的配置文件处理吗？\n// json.Marshal func Marshal(v any) ([]byte, error) { // .... } 看完文章， 你至少应该知道\n什么是 鸭式对象 ？ 怎么使用 接口断言 ？ 鸭式对象 先来说说 鸭式对象: 叫的像鸭子， 走路像鸭子， 那它就是鸭子。\n我们对鸭子下一个定义， 1. 发出嘎嘎的叫声， 2. 走路一摇一摆， 然后规定 任何满足这两个条件的 都是鸭子 我们拿着定义去对比。 有一个 人 是演员， 他能模仿鸭子发出嘎嘎声， 也能模仿鸭子一摇一摆的走路。 那么， 这个人能被认为是鸭子。 有一个 玩具 ， 能发出嘎嘎声， 也能一摇一摆的就走。 那么， 这个玩具也能被认为是鸭子。 简单的说， 接口就是 白名单定义， 满足白名单要求就行。\n在上面描述中， 已经提到了接口的两个重要概念： 定义 与 实现。\n(1) 叫做 接口定义\ntype Duck interface{ Quack() Walk() } (2) 叫做 接口实现\n// 人 type Person struct{} func (p *Person) Quack(){} func (p *Person) Walk(){} // 玩具 type Toy struct{} func (t *Toy) Quack(){} func (t *Toy) Walk(){} 通过案例讲解 我们知道， 人和大熊猫都是哺乳动物\n他们都会 吃 (Eat) 吃东西， 区别是 人吃饭， 熊猫吃竹子 更大的不同是， 人会 读书 (Read)， 熊猫不会。 func Eating(v any){ v.Eat() // output: ??? } func WhoAreYou(v any){ // ???? } 接口定义 我们回到作业要求， 要求实现 动物 和 人 两种接口。 要求\n动物接口需要实现 吃 这个动作。 type Animal interface{ Eat() } 人接口 除了需要吃之外 ， 还需要 读书 这个动作。 type Human interface{ Eat() Read() } 这种 直接为人定义两种方法 的方式是可以的， 但是当以后我们要扩展动物接口， 添加 Walk 的时候， 也必须要为人添加 Walk 才行。 久而久之， 不仅难以管理， 还无法从字面值上看到人和动物的关系。\n那有没有更简单的方式呢？ 有！ 接口嵌套， Go 语言中没有继承概念。\ntype Human interface{ Read() Animal } 接口实现 我们定两个 struct， 分别是 Panda 和 Child\ntype Panda struct{} func (p *Panda) Eat(){ fmt.Println(\u0026#34;熊猫吃竹子\u0026#34;) } // type Child struct{} func (c *Child) Eat(){ fmt.Println(\u0026#34;人吃饭\u0026#34;) } func (c *Child) Read(){ fmt.Println(\u0026#34;人还会读书\u0026#34;) } 这样， 小孩和熊猫的结构对象就定义好了， 他们实现了各自的方法。 并且满足之前人和动物的接口。\n接口检查 在书写代码的过程中， 要检查一个结构对象是否完全 实现了接口对应的所有方法， 避免在运行调用的时候才发现。\n可以使用以下代码\nvar _ Person = \u0026amp;Child{} 这是一个 变量定义并赋值 的语句。 特殊的地方在于， 变量名使用了 下划线_。\nvar peppa Person = \u0026amp;Child{} // 把 _ 换成了 peppa 如此操作\n编译器在书写的时候就会进行语法检查。 创建的 不存在变量 最终会被丢弃。 接口断言 在日常使用中， 我们可以通过 断言 将 接口A 转换成 接口B。\n类似的， 就像问一头 熊猫 是不是 人？\nfunc WhoAreYou(v any){ animal, ok := v.(Animal) // 断言， 判断 any 是否为能转换为 Animal if ok { animal.Eat() } child, ok := animal.(Human) // 断言 if ok { child.Read() } } 断言 返回的 第二个结果（ok） 是可以省略的。 不过这种用法需要用在我们能 保证 转换一定成功的情况下。\nanimal := child.(Animal) 在这里， Human 嵌套了 Animal 方法， 所以转换一定成功。\n","description":"Golang 接口(interface) 简介和入门使用 上下文 interface 应该是 Go语言 中一个极其重要的 基石 概念了。\n这里有一篇 Go 语言设计与实现 - 接口 interface ， 是目前我学习的资料中 完成度 和 友善度 都很高的一篇文章。\n在 go v1.18 中， interface 有了一个别名 any。 所以在说 interface 和 any 的时候， 其实说的是相同的东西。\ninterface 的使用场景到处都是。 还记得我们之前说的 JSON 和 YAML 的配置文件处理吗？\n// json.Marshal func Marshal(v any) ([]byte, error) { // .... } 看完文章， 你至少应该知道\n什么是 鸭式对象 ？ 怎么使用 接口断言 ？ 鸭式对象 先来说说 鸭式对象: 叫的像鸭子， 走路像鸭子， 那它就是鸭子。\n我们对鸭子下一个定义， 1. 发出嘎嘎的叫声， 2."},{"id":16,"href":"/books/golang/startup/vscode/","title":"03. VSCode配置与插件","parent":"01. Go开发环境配置","content":" VS Code 我更喜欢 gopls， 所以我没用 goland。\n下载 到 微软官方 下载 VS Code: https://code.visualstudio.com/ 。\n插件 一个好汉三个帮， 一个篱笆三个桩。\nVSCode 本身并不是某个特定语言的 IDE。 但是安装了插件 VSCode 就是鸟枪换炮， 爽得飞起。\nGo 相关的 必须安装的 Go 插件 , 现在已经交给 Go Team 维护: 非常有用的 Go template 插件， 可以提供 template 的 高亮 和 格式化。 测试使用的 Go Test Explorer， 前期不写单元测试， 也可以不装。 提供代码片段缩写的 Go Snippet， 有用但不多。 可以将 JSON 文件直接转换成结构体的 Paste JSON as Code 通用的 格式化 JSON 的 Json Tools。 展示更方便。 远程开发必备的 Remote - SSH。 可以直接在目标机器（容器）中开发、调试。 一款网络请求的客户端工具 REST Client , 有他就可以不用 Postman 了。 工具 在安装完 最核心的 Go 插件后， VSCode 就会推荐按安装各种开发工具了。\n在 mac 下， 其他平台快捷键略有不同。\ncommand + shift + p 调出对话框， 输入 install 搜索， 得到结果 Go: install/update tools 全选， 安装即可。 ","description":"VS Code 我更喜欢 gopls， 所以我没用 goland。\n下载 到 微软官方 下载 VS Code: https://code.visualstudio.com/ 。\n插件 一个好汉三个帮， 一个篱笆三个桩。\nVSCode 本身并不是某个特定语言的 IDE。 但是安装了插件 VSCode 就是鸟枪换炮， 爽得飞起。\nGo 相关的 必须安装的 Go 插件 , 现在已经交给 Go Team 维护: 非常有用的 Go template 插件， 可以提供 template 的 高亮 和 格式化。 测试使用的 Go Test Explorer， 前期不写单元测试， 也可以不装。 提供代码片段缩写的 Go Snippet， 有用但不多。 可以将 JSON 文件直接转换成结构体的 Paste JSON as Code 通用的 格式化 JSON 的 Json Tools。 展示更方便。 远程开发必备的 Remote - SSH。 可以直接在目标机器（容器）中开发、调试。 一款网络请求的客户端工具 REST Client , 有他就可以不用 Postman 了。 工具 在安装完 最核心的 Go 插件后， VSCode 就会推荐按安装各种开发工具了。"},{"id":17,"href":"/books/golang/shell-to-go/process-control/switch/","title":"03. 分支语句 (switch / case)","parent":"03. 流程控制","content":"在 Shell 中使用 case ... in 做分支语句。\n使用 case ... in 作为开始， 使用 esac 作为结尾 使用 xxx ) 格式作为条件分支。 其中 xxx 可以是多个并列条件 使用 ;; 作为语句块结束。 使用 * 作为默认条件语句， 可省略。 case $1 in \u0026#34;n1\u0026#34;) echo \u0026#34;n1\u0026#34; ;; \u0026#34;n2\u0026#34; | \u0026#34;n3\u0026#34;) echo \u0026#34;n2 or n3\u0026#34; ;; *) echo \u0026#34;default\u0026#34; ;; esac 在 Go 中使用 switch 作为分支语句\n使用 switch 关键字作为开始 使用 case 关键字作为分支条件。 没有单独的结尾关键字 使用 default 作为 switch n { case 1: fmt.Println(\u0026#34;1\u0026#34;) fallthrough case 2, 3, \u0026#34;a\u0026#34;: fmt.Println(\u0026#34;2 或 3\u0026#34;) default: fmt.Println(\u0026#34;其他\u0026#34;) } 当使用 fallthrough 关键字时， 会直接进入下一条 case 语句， 不再做判断。 可以当作多个 并列条件 时使用。\n","description":"在 Shell 中使用 case ... in 做分支语句。\n使用 case ... in 作为开始， 使用 esac 作为结尾 使用 xxx ) 格式作为条件分支。 其中 xxx 可以是多个并列条件 使用 ;; 作为语句块结束。 使用 * 作为默认条件语句， 可省略。 case $1 in \u0026#34;n1\u0026#34;) echo \u0026#34;n1\u0026#34; ;; \u0026#34;n2\u0026#34; | \u0026#34;n3\u0026#34;) echo \u0026#34;n2 or n3\u0026#34; ;; *) echo \u0026#34;default\u0026#34; ;; esac 在 Go 中使用 switch 作为分支语句\n使用 switch 关键字作为开始 使用 case 关键字作为分支条件。 没有单独的结尾关键字 使用 default 作为 switch n { case 1: fmt.Println(\u0026#34;1\u0026#34;) fallthrough case 2, 3, \u0026#34;a\u0026#34;: fmt."},{"id":18,"href":"/books/golang/linux-go-snippet/filepath/","title":"03. 文件路径管理","parent":"05. Go 实现: Shell 命令","content":"","description":""},{"id":19,"href":"/books/golang/shell-to-go/process-control/","title":"03. 流程控制","parent":"02. Go基础语法: Shell to Go","content":"","description":""},{"id":20,"href":"/books/golang/go-libraries/","title":"04. Go 库推荐","parent":"","content":"","description":""},{"id":21,"href":"/books/golang/linux-go-snippet/filename/","title":"04. 文件名管理","parent":"05. Go 实现: Shell 命令","content":" 1. 文件名 2. 文件后缀 ","description":" 1. 文件名 2. 文件后缀 "},{"id":22,"href":"/books/golang/shell-to-go/process-control/label/","title":"04. 标签跳转语句 (label)","parent":"03. 流程控制","content":"Label 标签在 Shell 中没有。 但在 Go 中却应用广泛。\nLabel Label 的定义规则为 SomeName: ， 以 : 结尾。\n在 Go 使用 Label 必须使用配置关键字 continue, break, goto 的其中一个。\n需要注意的是，\ncontinue 和 break 的 Label 可以省略。 continue|break [Label] goto 必须配置 Laebl 使用。 goto Label for/select/switch 和 Label 直接使用 continue/break 的时候， 作用域在 当前代码体 中。 如果配合了 Label 就可以跳出到 当前代码体外。 在配合 for/select/switch 使用时， Label 必须 紧临 他们， 中间不能有任何其他语句。 func continueBreakDemo() { Outer: for m := 1; m \u0026lt; 10; m++ { Inner: for n := 1; n \u0026lt; 10; n++ { fmt.Printf(\u0026#34;%d*%d=%d \u0026#34;, m, n, m*n) if n == 3 { break Outer } if n%4 == 0 { break Inner } } fmt.Println(\u0026#34;\u0026#34;) } } // Output: // 1*1=1 1*2=2 1*3=3 Goto Label 在配置 goto 使用的时候， Label 的位置没有特别要求。 即可以在被 调用前或后。\nfunc gotoLabel(n int) { fmt.Println(\u0026#34;刚开始\u0026#34;) goto End fmt.Println(\u0026#34;是奇数\u0026#34;) // 永远不会执行， IDE 也提示对应提示 End: fmt.Println(\u0026#34;结束啦\u0026#34;) } ","description":"Label 标签在 Shell 中没有。 但在 Go 中却应用广泛。\nLabel Label 的定义规则为 SomeName: ， 以 : 结尾。\n在 Go 使用 Label 必须使用配置关键字 continue, break, goto 的其中一个。\n需要注意的是，\ncontinue 和 break 的 Label 可以省略。 continue|break [Label] goto 必须配置 Laebl 使用。 goto Label for/select/switch 和 Label 直接使用 continue/break 的时候， 作用域在 当前代码体 中。 如果配合了 Label 就可以跳出到 当前代码体外。 在配合 for/select/switch 使用时， Label 必须 紧临 他们， 中间不能有任何其他语句。 func continueBreakDemo() { Outer: for m := 1; m \u0026lt; 10; m++ { Inner: for n := 1; n \u0026lt; 10; n++ { fmt."},{"id":23,"href":"/books/golang/go-features/channel/","title":"04. 通道 Channel","parent":"03. Go 特性语法","content":"","description":""},{"id":24,"href":"/books/golang/linux-go-snippet/","title":"05. Go 实现: Shell 命令","parent":"","content":"本章节将以 Shell 中命令为索引， 汇总对应的 Go 代码实现方式或片段。\n欢迎留言补充。\n","description":"本章节将以 Shell 中命令为索引， 汇总对应的 Go 代码实现方式或片段。\n欢迎留言补充。"},{"id":25,"href":"/books/golang/shell-to-go/process-control/select/","title":"05. 并发选择语句 (select)","parent":"03. 流程控制","content":"select 语句在 Shell 中没有， 但是在 Go 中却是 并发 的根基。\nselect 在语法上面， 和 switch 相似\n使用 case 作为分支入口。 使用 default 作为默认语句。 不同的是，\nselect 没有条件语句 func selectGrammar(ctx context.Context) { channel := make(chan int, 10) value := 100 select { case \u0026lt;-ctx.Done(): // 执行的代码 case \u0026lt;-time.After(10 * time.Second): // 执行的代码 case val := \u0026lt;-channel: fmt.Println(val) // 执行的代码 case channel \u0026lt;- value: // 执行代码 default: // 所有通道都没有准备好，执行的代码 } } 每个 case 语句都必须是一个通道(channel)。 常见的通道包括以下: ctx.Done。 time.After。 chan 定义的通道 所有 通达都会 被求值。 无论 进入或发送 如果在进入 select 的时候， 已经有 多个分支 的通道 就绪， 则 随机 选择一个。 如果任意分支执行了， 其他分支就不执行了。 关于 default 分支, 其他分支没准备好是 当 没有 default 将 阻塞。 由于 阻塞 的特性， 所以有一个特点是 先到先执行。 当 有 default 执行 default。 当 select 的从句执行完成后， 整个 select 就退出了。\n一直选择 因此， 在服务端通常会配合 for 一起使用。\n当 select 没有从句满足条件是， 就 阻塞 等待。 当 select 执行并退出后， 被 for 捕获， 进入下一次循环。 func foreverSelect(ctx context.Context) { for { select { case \u0026lt;-ctx.Done(): // 执行的代码 case \u0026lt;-time.After(10 * time.Second): // 执行的代码 } } } 永远等待 当需要自定义的服务保持一直运行不退出的时候， 可以使用 阻塞 特性。 （见过，没这样用过）\nfunc foreverWaiting() { // 自己实现了一个服务器 server.Run() // 阻塞以保持服务器始终运行 select {} } 总结 目前就发现这么多用法， 如果不写并发服务的话， 估计一辈子用不到 select。 T.T\n","description":"select 语句在 Shell 中没有， 但是在 Go 中却是 并发 的根基。\nselect 在语法上面， 和 switch 相似\n使用 case 作为分支入口。 使用 default 作为默认语句。 不同的是，\nselect 没有条件语句 func selectGrammar(ctx context.Context) { channel := make(chan int, 10) value := 100 select { case \u0026lt;-ctx.Done(): // 执行的代码 case \u0026lt;-time.After(10 * time.Second): // 执行的代码 case val := \u0026lt;-channel: fmt.Println(val) // 执行的代码 case channel \u0026lt;- value: // 执行代码 default: // 所有通道都没有准备好，执行的代码 } } 每个 case 语句都必须是一个通道(channel)。 常见的通道包括以下: ctx.Done。 time."},{"id":26,"href":"/books/golang/go-features/generic/","title":"05. 泛型","parent":"03. Go 特性语法","content":"","description":""},{"id":27,"href":"/books/golang/daily-notes/","title":"06. Go 应用笔记","parent":"","content":"","description":""},{"id":28,"href":"/books/golang/go-features/error-operation/","title":"06. 错误处理(error)","parent":"03. Go 特性语法","content":"","description":""},{"id":29,"href":"/books/golang/go-features/defer/","title":"07. defer","parent":"03. Go 特性语法","content":" 变量在 defer 中的值， 其实在问变量的作用域 有没有想过， 面试中经常问的 变量在 defer 之后的值， 其实是在问 函数变量的作用域\n简单的说， defer 就是将当前操作放入 堆 中， 等待触发 return 的时候再拿出来执行。 符合堆的特色， 先进后出。\n从细节来了， 还需要注意\n变量 在 defer 中的 作用域 ？ 函数 的 执行操作 是在 入堆前还是后 ？ defer 中的函数发生了 panic 会怎样 ？ 真题测试 以下这是 go语言爱好者 97 期的一道题目。 要求很简单， 代码执行 i, j 的值分别是什么。\nfunc Test_Demo(t *testing.T) { i := 10 j := hello(\u0026amp;i) fmt.Println(i, j) } func hello(i *int) int { defer func() { *i = 19 }() return *i } 这道题虽然代码少， 但是考点还是蛮多的\n核心: 函数变量作用域 defer 执行时间 闭包 指针 知识点 这里面所有的内容都可以在 Effective Go 中解决\n贪婪算法 什么是贪婪算法， 就是找到局部最优解， 合并后就是全局最优解。\n怎么找局部最优解， 就是要 对事情进行抽象，掌握事情的本质 。\ndefer 延迟执行 defer 就是语句进行压栈(FILO)处理， 延迟到 在函数 return 之前执行 执行。 本身没什么难点。 其设计目的也很明确就是为了 解决资源释放 的问题。\nopen 和 close 写在一起， 语意更直观。 解决因为错误退出，导致而 无法或忘记 释放资源 Effective Go 中对 defer 的概述。\nIt\u0026rsquo;s an unusual but effective way to deal with situations such as resources that must be released regardless of which path a function takes to return.\n这是一种不寻常但有效的方法来处理诸如必须释放资源的情况，而不管函数采用哪条路径返回。\n因此 defer 有什么好考的， 而且实际场景代码也不会那样写（违反了可读性的这一基本之准则）。\n所以通常面试中有 defer 的问题都不是在考 defer ， 只不过是披上了 defer 的狼皮。\n函数及返回值 其实 go 中关于函数返回花样还是挺多的。\n命名的/匿名的 返回值 func NamedResult(i, j int) (x int) 带参数不带参数的 return return 感觉和 golang 本身的代码可读性的的理念有一点冲突。 就像为什么不支持三元运算符一样。 其实这样本身也没有什么， 就是一两个 死记硬背 的知识点而已。\n但是遇到了 defer, 闭包, 指针 中对变量有操作， 那么问题可能就大了。\n如果对 函数变量的作用域 理解不清楚的话， 就容易掉坑。\npackage main // 命名结果 func NamedResult(i, j int) (x int) { x = i + j // 默认返回 return } // 匿名结果 func UnnamedResult(i, j int) int { // 指定返回 return i + j } 我们开启汇编， 查看一下函数过程\ngo tool compile -N -l -S main.go 从汇编结果可以看到:\n虽然我们在 UnnamedResult 代码中没有显式的提供返回值的变量名， 但是 golang 自动为我们生成了一个叫 ~r2 变量名， 其 等价于 NamedResult 函数中的变量x 汇编中 RET后没有带任何参数 所有与结果有关的操作都标记了 (SP) , ex: MOVQ AX, \u0026quot;\u0026quot;.~r2+24(SP) 既然如此， 我们就将所有函数的写法全部统一， 不再区分 命名的、 匿名的 ， 默认的， 指定的\n命名返回值 return 指定结果 func ReformResult(i, j int) (r2 int) { r2 = i + j return r2 } 这样看起来， 整个函数就清晰的多了。\n实战练习一下 根据之前所说， 我们这里来对函数做一下整形手术。\nfunc Test_reformDemo(t *testing.T) { i := 10 j := reformHello(\u0026amp;i) fmt.Println(i, j) // 19 10 } // hello 原函数 func hello(i *int) int { defer func() { *i = 19 }() return *i } // reformHello 整形函数 // reform 1. 匿名变命名 func reformHello(i *int) (_x int) { // reform 2. return 拆分 // reform 2.1 显式赋值 _x = *i // _x=10 // reform 3. defer 在返回前执行 func() { *i = 19 }() // *i=19 // reform 2.2 显式返回 return _x // _x=10 } 这样看， defer 是不是很简单了啊？\n","description":"变量在 defer 中的值， 其实在问变量的作用域 有没有想过， 面试中经常问的 变量在 defer 之后的值， 其实是在问 函数变量的作用域\n简单的说， defer 就是将当前操作放入 堆 中， 等待触发 return 的时候再拿出来执行。 符合堆的特色， 先进后出。\n从细节来了， 还需要注意\n变量 在 defer 中的 作用域 ？ 函数 的 执行操作 是在 入堆前还是后 ？ defer 中的函数发生了 panic 会怎样 ？ 真题测试 以下这是 go语言爱好者 97 期的一道题目。 要求很简单， 代码执行 i, j 的值分别是什么。\nfunc Test_Demo(t *testing.T) { i := 10 j := hello(\u0026amp;i) fmt.Println(i, j) } func hello(i *int) int { defer func() { *i = 19 }() return *i } 这道题虽然代码少， 但是考点还是蛮多的"},{"id":30,"href":"/books/golang/go-features/panic-recover/","title":"08. panic and recover","parent":"03. Go 特性语法","content":"","description":""},{"id":31,"href":"/books/golang/go-features/context/context-value-propagation/","title":"1. Context 值传递 - 源码解析(1)","parent":"02. 上下文 Context","content":" Golang 上下文(Context) 源码解析(1): 值传递 如果在 公众号 文章发现状态为 已更新， 建议点击 查看原文 查看最新内容。\n状态: 未更新\n原文链接: https://typonotes.com/posts/2023/03/01/devopscamp-context-sample/\n上下文 Context 应该是 Go语言 中一个极其重要的 基石 概念了。 本文将通过一个案例 着重 说明 值传递 的过程、用法和注意事项。\n本文会通过 案例分析， 扩展到 源码讲解、使用方式 等多方面进行 Context 讲解。\n阅读完本文后， 你能\n掌握标准库中的 Context 是如何实现存取值的。 掌握开源库中， 对于 Context 的封装使用。 扩展阅读 这里有一篇 Go 语言设计与实现 - 上下文 Context ， 是目前我学习的资料中 完成度 和 友善度 都很高的一篇文章。\n不管你愿不愿意， 用 Go 都绕不过 Context。不管用不用， 在所有 公共方法或函数 中强迫自己自己使用 context 作为入参。 虽然有点武断，但是\u0026hellip;（我也没有想到好的理由）\n从上文中我们可以确认， context 有两个核心作用， 值传递 与 信号传递。\n值传递： 将上文的中的值传递到下文。 最直观的用法可能应该链路追踪。 信号传递： 应该算 值传递 的一种特殊情况。 通过捕获信号、处理信息， 可以控制调用链流程。 值传递案例讲解: 曹操打新野 就用 context 实现一个 曹操打新野 的值传递游戏， 要求如下\nmain -\u0026gt; Lubei(ctx context.Context, n int) -\u0026gt; Guanyu(ctx context.Context) -\u0026gt; Zhangfei(ctx context.Context) 给刘备传递 任意数字 刘备拿到数字， 并输出 “曹操来了 n 万人” 刘备把数字传递给关羽。 a. 如果数字为偶数， 直接传递给张飞 b. 如果数字为奇数， 数字扩大10倍后传递给张飞。 c. 输出 “曹操来了 n 万人”。 （注意 n 的值） 张飞拿到数字， 直接输出 “曹操来了 n 万人”。 代码已经放到了 Github 上: https://github.com/tangx-labs/golang-context-with-from-demo\nContext 是一个接口 为什么要单独把这个拿出来说呢？ 因为最开始我以为 Conetxt 是一个 struct， 所有的 Context 都是一样的。 指导我在 gonic-gin/gin 那边踩了坑（挖个坑，以后有机会再说）。\ntype Context interface { Deadline() (deadline time.Time, ok bool) Done() \u0026lt;-chan struct{} Err() error Value(key any) any } 而我们常用的 标准库 Conetxt， 其实背后基本上是 4种 基础 struct 构成。\nemptyCtx valueCtx: 这个是我们今天的重点。 cancelCtx timerCtx 如果你常用他们， 应该能马上想起对应他们几个的方法或函数。\n向 context 注入值 通常我们使用 context.WithValue 函数 进行变量值注入。\n// 定义曹军的 key ， 用于 context 的值传递 type enemy int // 定义一个新类型 var keyCaojun = enemy(0) // 将曹军数量注入到 context 中 func WithEnemyContext(ctx context.Context, number int) context.Context { return context.WithValue(ctx, keyCaojun, number) } 最后的返回值 context.Context 就是一个 valueCtx。 也就是不管你传入的 ctx 是什么， 最后得到的都是 valueCtx。 这个是无法控制的， 除非你不用这个函数而自己实现。\n从代码中可以看到， 我定义了一个 函数 叫做 WithEnemyContext 专门用作 值注入， 而 keyCaojun 并不是作为参数传递进来的， 而是在定义在 包级别 的常量。\n这是因为：作为一个 包， 所提供功能相对固定， 不需要用户自己定义。 这样可以减少了由于输入带来的不必要问题。\n这也是开源库中常见的用法。\nconetxt key 的讲究 从代码中可以看到， 我为这个 key 定义了一个 新类型， 其基础类型是 int。\n// 定义曹军的 key ， 用于 context 的值传递 type enemy int // 定义一个新类型 const keyCaojun = enemy(0) 掌握了基础的你应该知道， 类型 enemy 和 int 可以互相转换， 但他们并不相同。\n事实上， 在 context 注入值的时候， 应该 尽量避免 使用 基础类型。 就是因为基础类型太过于常用， 在做 key 的时候， 如果其值很简单， 很可能不知不觉就发生冲突被覆盖了。\n如果一定要使用基础类型怎么办？ 那就把值设置复杂一点吧。\n从 context 中取值 同样的， 为了从 context 中取值， 也封装了一个函数 FromEnemyContext， 同样也用到了 keyCaojun 这个常量。 这样 WithEnemyConetxt 一起， 组成了 一组 用于存取的函数。\n// 从 context 中取出曹军数量 func FromEnemyContext(ctx context.Context) int { val := ctx.Value(keyCaojun) n, ok := val.(int) // 类型断言 if !ok { return 0 } return n } 在代码中， 通过 ctx.Value 取出来的值是 any 类型， 在返回之前， 我们需要将其断言成 int 类型。\n不过， 由于我们这是 一组 函数， 所以 val 的类型肯定是 int， 而其 零值 就是 0。 综上这么多 约束条件， 此处代码可以简写， 不需要在判断类型断言是否成功。\n// 从 context 中取出曹军数量 func FromEnemyContext(ctx context.Context) int { val := ctx.Value(keyCaojun) n := val.(int) // 类型断言 return n } 值传递源码解析 下面这段代码， 就是 “曹操打新野” 的故事的代码实现。\nfunc main() { ctx := context.Background() Liubei(ctx, 9) } func Liubei(ctx context.Context, n int) { // (1) 注入到 context ctx = info.WithEnemyContext(ctx, n) fmt.Printf(\u0026#34;刘备: 曹操来了 %d 万人\\n\u0026#34;, n) Guanyu(ctx) } func Guanyu(ctx context.Context) { n := info.FromEnemyContext(ctx) // (2) 获取消息 fmt.Printf(\u0026#34;关羽(1) \u0026lt;-: 曹操来了 %d 万人\\n\u0026#34;, n) if n%2 == 1 { // 扩大数量 n = n * 10 // (1) 重新注入到 context ctx = info.WithEnemyContext(ctx, n) } fmt.Printf(\u0026#34;关羽(2) -\u0026gt;: 曹操来了 %d 万人\\n\u0026#34;, n) Zhangfei(ctx) } func Zhangfei(ctx context.Context) { // (2) 获取消息 n := info.FromEnemyContext(ctx) fmt.Printf(\u0026#34;张飞: 曹操来了 %d 万人\\n\u0026#34;, n) } 在代码中， 可以注意到\n在 (1) 处： 刘备和关羽都通过 WithEnemyContext 传递了军情信息。 在 (2) 处： 关羽和张飞都通过 FromEnemyContext 获得了军情信息。 虽然他们都使用了相同的函数， 相同的 key， 但是 传递或得到 的军情却是不同的。\n我们现在从上到下， 一步步来理清楚。\nBackground 和 TODO 虽然他们都是 emptyCtx 的实例， 他们 不能被取消、 没有值、 也没有到期时间\nvar ( background = new(emptyCtx) todo = new(emptyCtx) ) 但是他们用处不同（字面赋予的意义）。\nBackground: 用于 main 函数、 初始化、 测试以及最顶层的Context。 TODO: 作为一个占位符， 表示这里还不清楚的初始化， 或待替换成其他 context。 重复向 context 传值 在传值使用 WithValue， 省略其他安全边界检查， 可以看到核心代码如下， 每次都创建了一个新的 valueCtx 对象\nfunc WithValue(parent Context, key, val any) Context { // ... 省略安全边界 return \u0026amp;valueCtx{parent, key, val} } 我们再来看看 valueCtx 的结构， 非常简单， 就是三个字段。\ntype valueCtx struct { Context key, val any } 不管你传入的 context 底层是什么数据结构， 出来的一定是 valueCtx 。 每一次调用都是一次 valueCtx 的封装。 调用的的越多， 层就越多。 就像俄罗斯套娃一样。 所以就案例来讲， 画图大概如下。\n刘备在 main 上套了一层， 关羽在刘备上套了一层。 由于关羽创建新 context 是有条件的， 所以使用虚线表示。\n从 context 取值 这里需要注意， 跟踪 ctx.Value() 其实是到了 Context 接口的定义的 Value 方法字段。\ntype Context interface { // 省略 Value(key any) any } 因此， 要了解 Value 的实际行为逻辑， 还必须的到清楚 ctx 底层到底是什么结构体？\n我们这里开了天眼， 知道是 valueCtx， 所以直接转到这部分代码\nfunc (c *valueCtx) Value(key any) any { if c.key == key { return c.val } return value(c.Context, key) } func value(c Context, key any) any { for { // (1) 循环查找 switch ctx := c.(type) { case *valueCtx: if key == ctx.key { return ctx.val } c = ctx.Context // (2) 找到 valueCtx， 但 key 不对， 同变量复制继续循环 // 省略 case *emptyCtx: // (3) 如果底层是 emtpyCtx return nil default: return c.Value(key) // (3) 如果最底层是其他自定 Context } } } 可以看到， valueCtx.Value 的实现简单粗暴\n先看自己这一层的 key 是否匹配， 匹配则返回 val 值。 如果不匹配， 那我就不管了。 派遣下面小弟 value() 函数去处理， 自己只需要对外统一返回结果就行。 在 value() 函数中， 做的事情就比多了。\n(1) 首先就创建了一个 for {} 死循环， 准备死磕， 非要找到不可。 (2) 如果当前的是 valueCtx， 就使用 key 进行比对， 匹配就返回， 不匹配就就把 c 替换成 父Context， 继续死磕。 (3) 不断的循环迭代， 到最后找到最底层的 Context。 如果是 emptyCtx， 就直接返回 nil 如果是 用户自定义 的 Context ， value() 也不干了， 直接返回用户自定义的方法。 至于后面是什么， 怎么实现的，全看用户。 回到案例中， 情况就比较简单了。\n关羽得到军情， 一定是刘备给的。 用绿线表示。 而张飞得到军情， 可能是关羽给的、 也可能是刘备给的。从上往下获取。 用黑线表示。 总结 本文中， 着力于 valueCtx 的讨论， 而跳过了 timerCtx 和 cancelCtx。\n其一， valueCtx 只有值的操作， 用来说明 Context 的 层级结构 更简单。 其二， timerCtx 和 cancelCtx 可以看作 valueCtx 的扩展。 当后者掌握了之后， 前两者就只需要在补充一点个字特色知识就能掌握。\n","description":"Golang 上下文(Context) 源码解析(1): 值传递 如果在 公众号 文章发现状态为 已更新， 建议点击 查看原文 查看最新内容。\n状态: 未更新\n原文链接: https://typonotes.com/posts/2023/03/01/devopscamp-context-sample/\n上下文 Context 应该是 Go语言 中一个极其重要的 基石 概念了。 本文将通过一个案例 着重 说明 值传递 的过程、用法和注意事项。\n本文会通过 案例分析， 扩展到 源码讲解、使用方式 等多方面进行 Context 讲解。\n阅读完本文后， 你能\n掌握标准库中的 Context 是如何实现存取值的。 掌握开源库中， 对于 Context 的封装使用。 扩展阅读 这里有一篇 Go 语言设计与实现 - 上下文 Context ， 是目前我学习的资料中 完成度 和 友善度 都很高的一篇文章。\n不管你愿不愿意， 用 Go 都绕不过 Context。不管用不用， 在所有 公共方法或函数 中强迫自己自己使用 context 作为入参。 虽然有点武断，但是\u0026hellip;（我也没有想到好的理由）\n从上文中我们可以确认， context 有两个核心作用， 值传递 与 信号传递。"},{"id":32,"href":"/books/golang/cobra-in-action/01-cobra-sample/","title":"1. 参数绑定与交叉编译","parent":"99. Cobra 实战项目","content":" 作业要求: 使用 https://github.com/spf13/cobra 实现命令工具 命令具有以下参数 --name 姓名 --age 年龄 如果年龄为空， 默认为 20 岁。 完成交叉编译脚本， 编译其他平台的二进制文件 -rwxr-xr-x 1 devopscamp staff 4220672 Jan 13 15:35 greeting-darwin-amd64 -rwxr-xr-x 1 devopscamp staff 4203442 Jan 13 15:35 greeting-darwin-arm64 -rwxr-xr-x 1 devopscamp staff 4215010 Jan 13 15:35 greeting-linux-amd64 -rwxr-xr-x 1 devopscamp staff 4157892 Jan 13 15:35 greeting-linux-arm64 执行输出效果如下 $ ./out/greeting-darwin-arm64 你好, 今年 20 岁 $ ./out/greeting-darwin-arm64 --age 30 --name zhangsan zhangsan 你好, 今年 30 岁 解题过程 1. 安装依赖包 $ go get -u github.com/spf13/cobra 2. 创建命令 var root = \u0026amp;cobra.Command{ Use: \u0026#34;greeting\u0026#34;, // 命令名字 Short: \u0026#34;打招呼\u0026#34;, // 短介绍 Run: func(cmd *cobra.Command, args []string) { // 运行函数 greeting(name, age) }, } 3. 指定参数 定义了变量作为参数接受者。 使用 init 函数， 在程序初始化的时候， 传递参数值。 参数接受者 指针类型 参数名称， 字符串类型 短参数名称， 字符串类型， 但只接受一个参数 默认值， 具体类型 参数描述， 字符串类型 var ( name = \u0026#34;\u0026#34; age = 0 ) func init() { root.Flags().StringVarP(\u0026amp;name, \u0026#34;name\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;姓名\u0026#34;) root.Flags().IntVarP(\u0026amp;age, \u0026#34;age\u0026#34;, \u0026#34;\u0026#34;, 20, \u0026#34;年龄\u0026#34;) } 4. 调用执行 greeting 是程序实际执行逻辑， 及执行逻辑入口。 在 root 的 Run 中调用 执行逻辑入口。 在 main 中调用 root 的执行函数 Execute() func greeting(name string, age int) { fmt.Printf(\u0026#34;%s 你好， 今年 %d 岁\\n\u0026#34;, name, age) } var root = \u0026amp;cobra.Command{ Use: \u0026#34;greeting\u0026#34;, Short: \u0026#34;打招呼\u0026#34;, Run: func(cmd *cobra.Command, args []string) { greeting(name, age) // 2. root 命令调用 greeting 业务 }, } func main() { err := root.Execute() // 3. main 调用 root 命令 if err != nil { log.Fatal(err) } } 4. 使用 Makefile 进行编译管理 使用 GOOS 和 GOARCH 设置环境变量命令。 使用 build 命令， 使用进行 当前系统环境 的编译 并且编译文件命名包含系统信息。 使用 buildx 命令， 实现 交叉编译 使用 clean 命令清空编译结果。 ## 默认变量， 获取当前 go 的环境变量 GOOS ?= $(shell go env GOOS) GOARCH ?= $(shell go env GOARCH) ## build 在指定环境变异 build: go build -o out/greeting-$(GOOS)-$(GOARCH) . ## 通过指定环境变量， 执行交叉编译 buildx: GOOS=linux GOARCH=amd64 make build GOOS=linux GOARCH=arm64 make build GOOS=darwin GOARCH=amd64 make build GOOS=darwin GOARCH=arm64 make build ## 清理编译结果 clean: rm -rf out/ 一个最基本命令结构就这样完成了， 是不是很简单？\n","description":"作业要求: 使用 https://github.com/spf13/cobra 实现命令工具 命令具有以下参数 --name 姓名 --age 年龄 如果年龄为空， 默认为 20 岁。 完成交叉编译脚本， 编译其他平台的二进制文件 -rwxr-xr-x 1 devopscamp staff 4220672 Jan 13 15:35 greeting-darwin-amd64 -rwxr-xr-x 1 devopscamp staff 4203442 Jan 13 15:35 greeting-darwin-arm64 -rwxr-xr-x 1 devopscamp staff 4215010 Jan 13 15:35 greeting-linux-amd64 -rwxr-xr-x 1 devopscamp staff 4157892 Jan 13 15:35 greeting-linux-arm64 执行输出效果如下 $ ./out/greeting-darwin-arm64 你好, 今年 20 岁 $ ./out/greeting-darwin-arm64 --age 30 --name zhangsan zhangsan 你好, 今年 30 岁 解题过程 1."},{"id":33,"href":"/books/golang/go-features/context/context-in-action-trace/","title":"2. Golang Context 值传递的生产案例(01) - 链路追踪","parent":"02. 上下文 Context","content":" Golang Context 值传递的生产案例(01): 链路追踪 如果在 公众号 文章发现状态为 已更新， 建议点击 查看原文 查看最新内容。\n状态: 未更新\n原文链接: https://typonotes.com/posts/2023/03/15/golang-context-in-action-trace/\n看完本文\n了解 链路追踪 和 OpenTelemetry 相关知识 了解 Context 值传递是如何在 链路追踪 的发展历程上登台亮相的。 之前在 Golang 上下文 Context 源码解析(1): 值传递 文章中举了一个例子说明讲解 Context 的值传递， 其中说到了 刘备-关羽-张飞 之间使用 Context 传递 曹操军队人数，\n有朋友反馈说这个值应该是 业务参数 放在函数中作为 形参 传递， 难以理解为什么会放在 Context 中。\nfunc Guanyu(n int) { // statement } func Zhangfei(n int) { // statement } 因此， 这次我们通过生产实际应用， 来说一下 Context 的值传递。\n链路追踪 想必大家也知道， 微服务治理是一个头疼的问题。 由于服务众多且部署分散， 因此通过 调用链路 排查问题就非常重要了。 实现这个的方案就叫 链路追踪 ， 在微服务中非常重要。\n可以说， 开源项目 OpenTelemetry 在链路追踪层面， 基本上已经是事实标准了。\nGithub 地址: https://github.com/open-telemetry\n这里有一个官方一步步实现链路追踪的案例， 可以自己实现一下: https://github.com/open-telemetry/opentelemetry-go/tree/main/example/fib\nContext 在 链路追踪 中的应用 现在假设有 6 个服务， SvcA 1-3 ， SvcB 1-3， 这 6 个服务可能分布在不同机器上面。\n第一阶段\n我们知道他们之间存在调用关系， 但是任何证据支撑。 所以从外部看来， 他们之间就是完全独立的的 6 个服务。\n由于时间紧， 任务重， 业务就这样上线了。\n第二阶段\n后来业务出了问题， 除了靠记忆， 就只能现场看代码找调用链路。 排查过程异常艰难。\n于是有人提议说， 不如我们在每个请求中都带上 UUID， 并且打印到日志里面， 就知道哪些服务在某个请求下， 是有关系的。\n于是就有了 TraceID\n第三阶段\n业务还是除了问题， 这次排查过程相比上次就轻松多了， 但是依然发现了一些 困惑 的问题。 虽然能从日志时间看到服务的调用顺序， 但是并不知道他们之间的调用关系， 没办法有效的把他们组织起来。\n于是就有人说， 要不在日志中增加两个字段， 表明他们调用的父子关系吧\n于是就有了 ParentSpanID 和 SpanID\n使用 Context 携带字段 现在好了我们能通过 TraceID, SpanID, ParentSpanID 搞清楚服务之间的调用关系了。 但是要怎么传递他们呢？\n这些字段是 肯定不能 直接放在参数里面，\n这些字段不是业务参数， 放进去会 污染 函数或方法。 即使现在放进去了， 以后要维护 增加或减少 怎么办？ 不可能每个地方服务都去改一次吧， 服务里面还有那么多函数。 从理论上来说， 这个就是不合理的设计。 func Guanyu(n int, TraceID string, SpanID string, ParentSpanID string) { // statement } func Zhangfei(n int, TraceID string, SpanID string, ParentSpanID string) { // statement } 第四阶段\n于是又有人说了， 要不我们统一放在 Context 里面吧，\nContext 本身就是上下文， 就具有传递性。 而且其设计理论上还可以存储无限多的数据。 这样我们就只需要在在每个函数或者方法中多添加一个 Context 参数就行了， 维护也方便。\nfunc Guanyu(ctx context.Context, n int) { // statement } func Zhangfei(ctx context.Context, n int) { // statement } 这样看起来， 就清爽很多了。 而且这种结构 是不是很熟悉 ？\n","description":"Golang Context 值传递的生产案例(01): 链路追踪 如果在 公众号 文章发现状态为 已更新， 建议点击 查看原文 查看最新内容。\n状态: 未更新\n原文链接: https://typonotes.com/posts/2023/03/15/golang-context-in-action-trace/\n看完本文\n了解 链路追踪 和 OpenTelemetry 相关知识 了解 Context 值传递是如何在 链路追踪 的发展历程上登台亮相的。 之前在 Golang 上下文 Context 源码解析(1): 值传递 文章中举了一个例子说明讲解 Context 的值传递， 其中说到了 刘备-关羽-张飞 之间使用 Context 传递 曹操军队人数，\n有朋友反馈说这个值应该是 业务参数 放在函数中作为 形参 传递， 难以理解为什么会放在 Context 中。\nfunc Guanyu(n int) { // statement } func Zhangfei(n int) { // statement } 因此， 这次我们通过生产实际应用， 来说一下 Context 的值传递。\n链路追踪 想必大家也知道， 微服务治理是一个头疼的问题。 由于服务众多且部署分散， 因此通过 调用链路 排查问题就非常重要了。 实现这个的方案就叫 链路追踪 ， 在微服务中非常重要。"},{"id":34,"href":"/books/golang/cobra-in-action/02-json-yaml-config/","title":"2. 配置文件读取与写入","parent":"99. Cobra 实战项目","content":" 作业要求 使用 https://github.com/spf13/cobra 实现命令工具 命令具有以下参数 --config , -c 配置文件 配置文件如下\n# config.yml name: zhangsan age: 20 将配置文件保存为 JSON 格式 $ cat config.json 输出结果\n{ \u0026#34;name\u0026#34;:\u0026#34;zhangsan\u0026#34;, \u0026#34;age\u0026#34;: 20 } 单个参数绑定的困境 之前我们使用了 单个参数独立绑定 的方式， 为我们的 greeting 应用绑定了 name 和 age 参数。\n这种方式有个很明显的缺点， 如果应用参数的数量较多（比如说几十个） 的时候， 就会出现庞大的参数列表， 可读性 和 维护性 都会变得很差。\nvar ( name string age int ) func init() { root.Flags().StringVarP(\u0026amp;name, \u0026#34;name\u0026#34;, \u0026#34;n\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;名字\u0026#34;) root.Flags().IntVarP(\u0026amp;age, \u0026#34;age\u0026#34;, \u0026#34;a\u0026#34;, 20, \u0026#34;名字\u0026#34;) } 因此在生产中， 我们常常会选择 配置 文件来进行 参数/变量 的管理。 例如作业要求中提到的 YAML 或者 JSON 文件。\n配置文件 最常用 的的配置文件类型就是 YAML 和 JSON。 除此之外还有 toml, xml, ini 等， 这些类型的配置文件可以在实际碰到的时候去学习掌握， 大差不差。\n通常 解析 和 映射 方法名称分别为 Marshal 和 Unmarshal\nMarshal(v any) ([]byte, error) 将结构体 解析 成 []byte 类型。 Unmarshal(data []byte, v any) error 将 []byte 映射 到结构体中。 这里的 v 需要是 指针类型 但有些库在名字上可能具有一定变种，通常也有迹可循。\nMarshalJSON MarshalYAMl 不同库 对应的的 方法名称 和 实现逻辑 也不尽相同， 如果凭经验使用遇到了问题， 一定要去看看官网文档。\n最基本常用的解析库\njson: encoding/json yaml: gopkg.in/yaml.v3, gopkg.in/yaml.v2 v2 和 v3 有区别， 自己研究。 解题过程 1. 指定配置文件参数 由于我们的实际 参数/变量 通过配置文件管理了， 因此我们就需要指定一个配置文件参数。\nvar config string func init() { root.Flags().StringVarP(\u0026amp;config, \u0026#34;config\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;config.yml\u0026#34;, \u0026#34;配置文件\u0026#34;) } 有了上一篇作业的经验， 这个应该就很简单。\n2. 读取配置 我们定义了一个名为 Person 的结构体， 包含两个字段 Name 和 Age， 用于接受参数/变量。\ntype Person struct { Name string `yaml:\u0026#34;name,omitempty\u0026#34;` Age int `yaml:\u0026#34;age,omitempty\u0026#34;` } 我们在字段后面， 使用 tag 进行了信息补充， 提供 yaml 解析的行为参数。\n图片是之前 struct 的截图， 其中\n（1） 是字段名称 （2-4） 是 tag 内容。 （2） 是 tag name， 解析库依赖此字段进行判定。 （3-4） 是 tag value, 本质上是 字符串。 例如这里 name 和 omitempty 使用 分隔符, 进行分割。 不同的库的分隔符有所不同， 例如 gorm 使用的 分号;。 （3） 在这里对应的是 映射 的字段名称。 例如 yaml 文件中的 name 对应结构体中的 Name。 这里 name 也可以是其他值， 例如 MyName， 那么就会在 yaml文件中找对应的 MyName 字段。 （4） omitempty 是 yaml 支持的操作符， 同时还支持 flow, inline。 具体功能描述可以参考 https://pkg.go.dev/gopkg.in/yaml.v3#pkg-functions func readConfig(name string) *Person { person := \u0026amp;Person{} // 1. 读取文件 b, err := os.ReadFile(config) if err != nil { panic(err) } // 2. 绑定参数 err2 := yaml.Unmarshal(b, person) if err2 != nil { panic(err) } return person } 初始化 person 指针对象， 其底层类型为 Person 结构体。 在 readConfig 函数中， 我们使用 os.ReadFile 读取文件内容。 并通过 yaml.Unmarshal 将数据映射到 person 实例中。 需要 注意的是， person 所在的参数未知， 必须是 指针 对象， 否则反射无法保存数据到 内存 中。 保存文件为 json 把配置信息保存为 json 文件， 就是之前 yaml 的反操作。\n// dumpConfig 保存文件 func dumpConfig(person *Person) { // 将结构体解析成 []byte b, err := json.Marshal(person) if err != nil { panic(err) } // os.ModePerm =\u0026gt; folder 755, file 644 err2 := os.WriteFile(\u0026#34;config.json\u0026#34;, b, os.ModePerm) if err2 != nil { panic(err) } } 使用 json.Marshal 将对象转换成 []byte。 由于是 读取操作， person 所在的参数为止可以是结构体， 也可以是指针。 使用 os.WriteFile 进行文件写入操作。 需要注意的是 os.ModePerm 这个权限， 对于文件夹是 755， 对于文件是 644， 非常的灵活。 {\u0026#34;Name\u0026#34;:\u0026#34;zhugeliang\u0026#34;,\u0026#34;Age\u0026#34;:2600} 执行后，得到的结果与期望的结果有一点点不同。注意 ，这里的 Name 和 Age 都是大写。\n我们对 Person 结构体稍微做一点改造\ntype Person struct { Name string `yaml:\u0026#34;name,omitempty\u0026#34; json:\u0026#34;name,omitempty\u0026#34;` Age int `yaml:\u0026#34;age,omitempty\u0026#34; json:\u0026#34;age,omitempty\u0026#34;` } 加上 json tag 之后， 得到的结果就与期望一致了。\n{\u0026#34;name\u0026#34;:\u0026#34;zhugeliang\u0026#34;,\u0026#34;age\u0026#34;:2600} 思考题 留一点思考题吧。\n为什么没有设置 json tag 也可以成功保存 json 配置？ 设置了 json tag 之后， json 配置中的字段名字变了， 他们的优先级是什么？ 要怎么 忽略 一个字段？ 答案在官方文档中。\n","description":"作业要求 使用 https://github.com/spf13/cobra 实现命令工具 命令具有以下参数 --config , -c 配置文件 配置文件如下\n# config.yml name: zhangsan age: 20 将配置文件保存为 JSON 格式 $ cat config.json 输出结果\n{ \u0026#34;name\u0026#34;:\u0026#34;zhangsan\u0026#34;, \u0026#34;age\u0026#34;: 20 } 单个参数绑定的困境 之前我们使用了 单个参数独立绑定 的方式， 为我们的 greeting 应用绑定了 name 和 age 参数。\n这种方式有个很明显的缺点， 如果应用参数的数量较多（比如说几十个） 的时候， 就会出现庞大的参数列表， 可读性 和 维护性 都会变得很差。\nvar ( name string age int ) func init() { root.Flags().StringVarP(\u0026amp;name, \u0026#34;name\u0026#34;, \u0026#34;n\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;名字\u0026#34;) root.Flags().IntVarP(\u0026amp;age, \u0026#34;age\u0026#34;, \u0026#34;a\u0026#34;, 20, \u0026#34;名字\u0026#34;) } 因此在生产中， 我们常常会选择 配置 文件来进行 参数/变量 的管理。 例如作业要求中提到的 YAML 或者 JSON 文件。"},{"id":35,"href":"/books/golang/cobra-in-action/03-interactive-command/","title":"3. 交互式命令","parent":"99. Cobra 实战项目","content":" 原文链接: https://tangx.in/posts/2023/01/26/devopscamp-cobra-interactive-survey/\n本文为 DevOpsCamp 实战训练作业 cobra - 03 配置文件的读取与写入（简单） 的解题答案\nDevoOpsCamp 作业地址： https://www.devopscamp.cc/semi-plan-202301-2/posts/homework/cobra03/\n作业: cobra - 03 交互式命令 要求:\n使用 https://github.com/spf13/cobra 实现命令工具\n使用 https://github.com/go-survey/survey 实现交互式命令\n实现 Demo 效果\n除了官方效果之外， 我还发现了 aliyun 命令行工具在配置账户的时候使用的是 交互式 ， 如下\n为了更好的体现 实战性， 我们将以 aliyun configure --profile 的作为例子， 并进行一些优化。\n解题过程 1. 安装 survey 依赖 这是一个意外收获， survey 库的 Github 地址与 go module 名称不一致。 同时， survey 版本还是 v2 了。\n关于 go module version ， 参考文章： https://go.dev/doc/modules/version-numbers\n话说回来， 虽然 github 仓库地址是 https://github.com/go-survey/survey ， 但安装库需要使用命令\n$ go get -u github.com/AlecAivazis/survey/v2 在 go.mod 第一行中, 也可以看到 module 的名称\nmodule github.com/AlecAivazis/survey/v2 平时在使用的时候， 应该多注意官方文档的 Usage、 exmaple 或者 _test.go 等。\n2. 需要使用的交互组件 survey 提供了很多组件类型以及 Option 参数、 验证器 等功能，非常全面。 在这里简单介绍常用的几种\nInput 组件： 普通输入框， 输入什么就显示什么。 Password 组件： 密码输入框， 输入的内容不直接显示， 使用 * 替代。 Select 组件： 单选框。 MultiSelect 组件： 多选框， 结果为 切片 类型。 Confirm 组件： 确认框， 结果为 布尔 类型。 更多其它组件， 可以参考官方文档。\n3. 代码片段 参考 aliyun 命令行， 我们自己实现的功能需要以下字段。\nAccess Secret ID Access Secret Key Region Language 代码中， 创建了 匿名 struct ， 并创建 实例 赋值给 answers\nanswers := struct { ID string Key string ChinaRegion string `survey:\u0026#34;region\u0026#34;` Language []string }{} 其中 ChinaRegion 字段通过 tag survey:\u0026quot;region\u0026quot; 指定了一个映射名字 region。 回想一下， 这种用法是不是和上一篇配置文件中的 json, yaml 字段的映射名字用法一样？\n另一方面， 我们还准备了一系列问题， 引导用户输入\n// the questions to ask var qs = []*survey.Question{ { // 1. Input 输入框 Name: \u0026#34;id\u0026#34;, Prompt: \u0026amp;survey.Input{ Message: \u0026#34;Access Secret ID: \u0026#34;, }, Validate: survey.Required, }, { // 2. Password 密码输入框 Name: \u0026#34;key\u0026#34;, Prompt: \u0026amp;survey.Password{ Message: \u0026#34;Access Secret Key: \u0026#34;, }, Validate: survey.Required, }, { // 3. Select 单选框 Name: \u0026#34;region\u0026#34;, Prompt: \u0026amp;survey.Select{ Message: \u0026#34;Choose a region:\u0026#34;, Options: []string{\u0026#34;cn-shanghai\u0026#34;, \u0026#34;cn-hangzhou\u0026#34;}, Default: \u0026#34;cn-hangzhou\u0026#34;, }, }, { // 4. MultiSelect 多选框 Name: \u0026#34;language\u0026#34;, Prompt: \u0026amp;survey.MultiSelect{ Message: \u0026#34;Supported Configure Language: \u0026#34;, Options: []string{\u0026#34;zh\u0026#34;, \u0026#34;en\u0026#34;, \u0026#34;jp\u0026#34;}, }, }, } qs 中的 Name 名称与 answers 中的字段名称都是一一对应的。 在 id 和 key 字段， 设置了验证器， 要求 必须提供。 在 region 字段， 设置 cn-hangzhou 为默认值， 虽然在切片中排在第二位。 另外， 我们还使用 Confirm 组件引导用户确认是否将输入内容保存到文件中。 由于 保存确认 并不需要保存到配置文件中， 因此我们将其单独封装在了 confirm 函数中。\nfunc confirm() bool { ok := false // 5. Confirm 确认框 prompt := \u0026amp;survey.Confirm{ Message: \u0026#34;是否保存文件?\u0026#34;, } survey.AskOne(prompt, \u0026amp;ok) return ok } 4. JSON MashralIndent 为了更好的可读性， 这次在保存配置文件的时候， 使用了 MarshalIndent 方法。\n{ \u0026#34;ID\u0026#34;: \u0026#34;AKID-demodemo-adsfasdf\u0026#34;, \u0026#34;Key\u0026#34;: \u0026#34;flasjdflaksdjf\u0026#34;, \u0026#34;ChinaRegion\u0026#34;: \u0026#34;cn-shanghai\u0026#34;, \u0026#34;Language\u0026#34;: [ \u0026#34;zh\u0026#34;, \u0026#34;en\u0026#34; ] } 5. 全局 profile 字段 你可能已经注意到了， 目前所有的代码都在 main 包下面， 并没有 划分目录结构。\nvar profile string 因此定义的 profile 是全局变量， 可以在 任意位置 直接使用。\n但是我们在使用的时候并没有在函数中直接使用， 而是通过 函数参数 的方式传递下去的。 这是我们 刻意 回避直接在 dumpConfig 中直接使用 全局的profile 的。\n关于 目录结构 我们将会在后面的作业中提到。\nvar root = \u0026amp;cobra.Command{ Use: \u0026#34;aliyunx\u0026#34;, Short: \u0026#34;aliyun 配置中心\u0026#34;, Run: func(cmd *cobra.Command, args []string) { // 1. 使用全局 profile interactive(profile) }, } func interactive(profile string) { // 2. 参数传递 dumpConfig(profile, answers) } func dumpConfig(profile string, answer any) { // 3. 参数传递 name := fmt.Sprintf(\u0026#34;%s.config.json\u0026#34;, profile) err2 := os.WriteFile(name, b, os.ModePerm) if err2 != nil { panic(err2) } } 效果展示 ","description":"原文链接: https://tangx.in/posts/2023/01/26/devopscamp-cobra-interactive-survey/\n本文为 DevOpsCamp 实战训练作业 cobra - 03 配置文件的读取与写入（简单） 的解题答案\nDevoOpsCamp 作业地址： https://www.devopscamp.cc/semi-plan-202301-2/posts/homework/cobra03/\n作业: cobra - 03 交互式命令 要求:\n使用 https://github.com/spf13/cobra 实现命令工具\n使用 https://github.com/go-survey/survey 实现交互式命令\n实现 Demo 效果\n除了官方效果之外， 我还发现了 aliyun 命令行工具在配置账户的时候使用的是 交互式 ， 如下\n为了更好的体现 实战性， 我们将以 aliyun configure --profile 的作为例子， 并进行一些优化。\n解题过程 1. 安装 survey 依赖 这是一个意外收获， survey 库的 Github 地址与 go module 名称不一致。 同时， survey 版本还是 v2 了。\n关于 go module version ， 参考文章： https://go.dev/doc/modules/version-numbers\n话说回来， 虽然 github 仓库地址是 https://github."},{"id":36,"href":"/books/golang/cobra-in-action/04-layout/","title":"4. 项目的目录结构","parent":"99. Cobra 实战项目","content":" Go 项目的目录结构 Go 项目的目录结构， 通常都会参考该项目 Go语言规范/项目结构 - Github 。\n这是一个社区规范， 遵守这个规范， 大家都会很轻松。 但并不是严格的 Go 语言标准， 实际操作中各个公司可能会有自己的标准。\n另外， 在上述的 Github 仓库中可以看到， 所有 目录功能 都只有一层。 这样就意味着在实际使用时我们是可以自由组合。 只要遵守该层的功能约定就可以了。\n例如， 使用 cobra 时， 用于管理命令的 cmd 目录， 位置可以是\n/cmd/appname/cmd # 或 /pkg/cmd/ # 或 /internal/pkg/cmd # 或 /pkg/internal/cmd 关于这个没有必要钻牛角尖， 只要是一群相对固定的维护人员认同的约定， 就可以了。\ninternal 包 internal 包是是特殊的， 也是 Go 语言规范 强制 约束的。\n首先， 它的目录位置不是固定的， 和其他包一样。 其次， 它的访问是受限的， 只有和他有 近亲亲属关系 的路径才能访问。 举个例子， 代码在 https://github.com/tangx-labs/go-internal-demo\n代码目录树如下\n限制访问 在上图中, 其中 (2) 的调用因为没有权限被限制\n在 /cmd/appname/cmd/say 访问 pkg/internal/master 时，\n找到与 /pkg 与 /cmd 是相同层级。 但是 /pkg/internal 是子层级， 与 /cmd/appname 是同一层级。 因此属于 远亲， 不能直接调用 /pkg/internal/master 公共方法暴露 但是， 可以通过 私有包的公共方法暴露， 例如上图中的 (3)\n/pkg/hello 与 /pkg/internal 是同级， 且是 近亲， 可以调用。 /pkg/hello 是公共的 /cmd/appname/cmd/say 可以通过调用 /pkg/hello 间接实现调用 master 的逻辑。（ 更多详细信息， 可以阅读 internal 运行机制\n那 internal 是不是就一定不能被访问了呢？ 也不一定， 可以参考 突破限制,访问其它Go package中的私有函数 包命名规范 关于包的命名规范， Go 官方是有明确说明的， 但是 没有强制约束 。\n要求\n短，好记，有意义： bytes, io, os 小写字母。 多个单词使用 连字符（-） 连接， 不要使用 蛇形（下划线） 或者 驼峰： qcloud-cdn-sdk 更多信息， 参考 effective_go\n函数/方法，变量命令 大写开头是公共， 小写开头是私有： 这个就不多说了 命名不要与包名有重复： 假如包名为 bytes， 函数名就不用叫 BytesReader 了， 否则调用起来就是 bytes.BytesReader。 函数名就叫 Reader 就好了， 调用起来就是 bytes.Reader。 命令要有意义： 见名知义。 命名要遵循 驼峰 规则。 循环依赖 这个就不多说了， 学了基础的都应该知道， 相关文章一搜一大把。\n这个是 Go 语言的 强制约束。 换句话说， 不用等到编译， 在写代码的时候 IDE 就会提示你出现错误。\n","description":"Go 项目的目录结构 Go 项目的目录结构， 通常都会参考该项目 Go语言规范/项目结构 - Github 。\n这是一个社区规范， 遵守这个规范， 大家都会很轻松。 但并不是严格的 Go 语言标准， 实际操作中各个公司可能会有自己的标准。\n另外， 在上述的 Github 仓库中可以看到， 所有 目录功能 都只有一层。 这样就意味着在实际使用时我们是可以自由组合。 只要遵守该层的功能约定就可以了。\n例如， 使用 cobra 时， 用于管理命令的 cmd 目录， 位置可以是\n/cmd/appname/cmd # 或 /pkg/cmd/ # 或 /internal/pkg/cmd # 或 /pkg/internal/cmd 关于这个没有必要钻牛角尖， 只要是一群相对固定的维护人员认同的约定， 就可以了。\ninternal 包 internal 包是是特殊的， 也是 Go 语言规范 强制 约束的。\n首先， 它的目录位置不是固定的， 和其他包一样。 其次， 它的访问是受限的， 只有和他有 近亲亲属关系 的路径才能访问。 举个例子， 代码在 https://github.com/tangx-labs/go-internal-demo\n代码目录树如下\n限制访问 在上图中, 其中 (2) 的调用因为没有权限被限制"},{"id":37,"href":"/books/golang/cobra-in-action/05-1-command-tree/","title":"5. 子命令与Cobra命令树的实现","parent":"99. Cobra 实战项目","content":" cobra 的子命令 在 cobra 中， 每个 命令 都是独立的。 通过 parent.AddCommand(children) 的形式进行串连。\nvar root = \u0026amp;cobra.Command{} var child = \u0026amp;cobra.Command{} func init() { root.AddCommand(child) } 没了， 应用上就这么多。\ncobra 命令树 如果你用过 gin 的路由树的话， 可能会对 cobra 的命令树实现更为深刻。\n删除多余的结构， cobra 节点 就是下面这样的。\ntype Command struct { // 子命令 commands []*Command // 父命令 parent *Command } 当进行 命令树 组合的时候， 是通过 领养/挂靠 的方式实现的。\n// AddCommand adds one or more commands to this parent command. func (c *Command) AddCommand(cmds ...*Command) { for i, x := range cmds { if cmds[i] == c { panic(\u0026#34;Command can\u0026#39;t be a child of itself\u0026#34;) } // 为子命令设置父命令（认亲） cmds[i].parent = c // (1) // 省略 // 添加传入的子命令 c.commands = append(c.commands, x) // (2) } } (1) 在我们可以在任意节点调用 Execute 方法， 这个调用会通过 递归 找到最上层的 根 节点。\nfunc (c *Command) Execute() error { _, err := c.ExecuteC() return err } // ExecuteC executes the command. func (c *Command) ExecuteC() (cmd *Command, err error) { // Regardless of what command execute is called on, run on Root only // 递归寻找最上层 if c.HasParent() { return c.Root().ExecuteC() } } 再来看一次 Command 结构体定义\ntype Command struct { // 子命令 commands []*Command // 父命令 parent *Command } (2) 通过将传入的命令保存到 []*Command 切片中， 实现了命令树的 组合 。\nc.commands = append(c.commands, x) // (2) 且同时 实现了 同一个命令挂载到多个父命令上\nroot.AddCommand(sub1, sub2) // (a) sub1.AddCommand(sub2) // (b) commands 是一个切片， 用于保存 挂载 上来的子命令。 但是， 这里需要注意， 由于 *Command 是指针类型， 意味着在任何修改， 都可能影响其他调用的地方。\n对于 sub2 而言, (a)处父节点是 root。 (b)处父节点是 sub1。 最终父节点是 sub1。 但不影响 sub2 同时是 root 和 sub1 的子命令。\n总体来说， cobra 命令节点 独立而又统一\n","description":"cobra 的子命令 在 cobra 中， 每个 命令 都是独立的。 通过 parent.AddCommand(children) 的形式进行串连。\nvar root = \u0026amp;cobra.Command{} var child = \u0026amp;cobra.Command{} func init() { root.AddCommand(child) } 没了， 应用上就这么多。\ncobra 命令树 如果你用过 gin 的路由树的话， 可能会对 cobra 的命令树实现更为深刻。\n删除多余的结构， cobra 节点 就是下面这样的。\ntype Command struct { // 子命令 commands []*Command // 父命令 parent *Command } 当进行 命令树 组合的时候， 是通过 领养/挂靠 的方式实现的。\n// AddCommand adds one or more commands to this parent command. func (c *Command) AddCommand(cmds ."},{"id":38,"href":"/books/golang/cobra-in-action/05-2-gin-router-tree/","title":"5.2 gin 路由树的实现(扩展)","parent":"99. Cobra 实战项目","content":" gin 的路由树 与 cobra 相比， gin 的路由树实现就是另外一种方式了， 我称之为 生长。 换句话说， gin 路由的子节点不能独立于父节点 单独 定义。\n// Group creates a new router group. You should add all the routes that have common middlewares or the same path prefix. // For example, all the routes that use a common middleware for authorization could be grouped. func (group *RouterGroup) Group(relativePath string, handlers ...HandlerFunc) *RouterGroup { return \u0026amp;RouterGroup{ Handlers: group.combineHandlers(handlers), basePath: group.calculateAbsolutePath(relativePath), engine: group.engine, } } 从上面代码可以看出来， RouterGroup 是通过 Group 方法实现路由节点 生长 的， 在调用 Group 方法的时候，\n必须 要传入 子节点 的相对路径 使用私有方法计算出 basePath 的值。 这个特别像怀孕生孩子， 一代接一代。 绝对错不了。 O.o。\ngin 的 RouterGroup 能实现 认亲/挂靠 模式吗？ 肯定可以， 做个变形手术就好了。 这里挖个坑吧。\n","description":"gin 的路由树 与 cobra 相比， gin 的路由树实现就是另外一种方式了， 我称之为 生长。 换句话说， gin 路由的子节点不能独立于父节点 单独 定义。\n// Group creates a new router group. You should add all the routes that have common middlewares or the same path prefix. // For example, all the routes that use a common middleware for authorization could be grouped. func (group *RouterGroup) Group(relativePath string, handlers ...HandlerFunc) *RouterGroup { return \u0026amp;RouterGroup{ Handlers: group.combineHandlers(handlers), basePath: group.calculateAbsolutePath(relativePath), engine: group.engine, } } 从上面代码可以看出来， RouterGroup 是通过 Group 方法实现路由节点 生长 的， 在调用 Group 方法的时候，"},{"id":39,"href":"/books/golang/cobra-in-action/06-persistent-flag/","title":"6. 持久化命令与Go引用类型的使用","parent":"99. Cobra 实战项目","content":" DevOpsCamp第2期：从 《cobra - 06 持久化命令》 开始聊聊 Go语言 指针类型的使用注意事项 如果在 公众号 文章发现状态为 已更新， 建议点击 查看原文 查看最新内容。\n状态: 未更新\n原文链接: https://typonotes.com/posts/2023/02/19/devopscamp-cobra-06-persistent-run-and-flags/\n嗯， 在 cobra 中提供了一种叫做 Persistent 的 状态， 定向支持 函数 与 参数。\n下面这段代码是是使用时的定义。\nvar root = \u0026amp;cobra.Command{ Use: \u0026#34;root\u0026#34;, // Persistent Run (1) PersistentPreRun: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;PersistentPreRun in root\u0026#34;) }, Run: func(cmd *cobra.Command, args []string) { _ = cmd.Help() }, } var config string func init() { // Persistent Flag (2) root.PersistentFlags().StringVarP(\u0026amp;config, \u0026#34;config\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;~/.config.json\u0026#34;, \u0026#34;配置文件\u0026#34;) } 凡是定义了 Persistent Run(1) 和 Flag(2) 的节点， 其子孙节点都会 继承 这种状态。 这种状态也可以被子孙节点的自定义状态覆盖。\n注意： 这种状态是继承自 其父节点， 而非 上级节点 。\n父节点不是上级节点 这个的问题的发生原因， 还是在 xxx.AddCommand 的时候造成的。 因为 \u0026amp;cobra.Command{} 是指针对象/引用对象， 因此在不同的地方修改是会全局影响的。 这个是基础知识， 也是重要的 坑 点， 需要牢记。\n下面是一个代码案例， 帮助理解。\n案例代码在在 Github: https://github.com/tangx-labs/cobra06-demo\n代码中实现了一个如下图所示的 命令树 结构。 其中 sub2 同时挂载到了 root 和 sub1 节点。\n以下是代码执行结果执行结果， 注意看\n--config 的参数值 PersistentPreRun 的执行结果 sub2 的 Usage 路径， 无论从哪里进入， 都是 root sub1 sub2。 代码执行过程 ./cobra-demo6 # ./cobra-demo6 PersistentPreRun in root Flags: -c, --config string 配置文件 (default \u0026#34;~/.config.json\u0026#34;) ./cobra-demo6 sub1 # ./cobra-demo6 sub1 PersistentPreRun in sub1 Flags: -c, --config string 配置文件 (default \u0026#34;$HOME/.config.json\u0026#34;) ./cobra06-demo sub2 # ./cobra06-demo sub2 # (1) PersistentPreRun in sub1 # (2) Usage: root sub1 sub2 [flags] # (3) Global Flags: -c, --config string 配置文件 (default \u0026#34;$HOME/.config.json\u0026#34;) # (4) ./cobra06-demo sub1 sub2 # ./cobra06-demo sub1 sub2 #(1) PersistentPreRun in sub1 #(2) Usage: root sub1 sub2 [flags] #(3) Global Flags: -c, --config string 配置文件 (default \u0026#34;$HOME/.config.json\u0026#34;) #(4) 引用类型回顾 首先， 我们再来回顾一下一下 Cobra Command 的结构体\ntype Command struct { Use string parent *Command\t// 父命令 commands []*Command\t// 子命令 } 可以看到， parent *Command 是指针类型。 这意味着， 在任何地方修改都会影响全局引用。\n这里简单的回顾一下 引用对象。 A, B, C 都指向 指针地址， 而 指针地址 纸箱 真实数据地址。 当因为某个外力修改了 真实数据地址 中的内容的时候， 虽然 A, B, C 都没变化， 但是他们 取 到的东西发生了变化。\n举个例子，\n你去温泉之前寄存物品， 商家会给你一个 手牌（指针地址）， 你拿着手牌将 名贵手表（数据） 放入对应的 100号柜子（真实地址）。 在你泡温泉的时候， 某个人（外力） 打开了柜子， 把你的手表换成了 塑料手表（数据修改）。 等你回来的时候， 虽然你的手牌没变， 但是你打开柜子的时候， 你拿到的不再你期望的东西了。 而正好， 每次执行 xxx.AddCommand(children) 添加子命令的时候， children 节点的 parent 字段都会被修改。\nfunc (c *Command) AddCommand(cmds ...*Command) { for i, x := range cmds { if cmds[i] == c { panic(\u0026#34;Command can\u0026#39;t be a child of itself\u0026#34;) } cmds[i].parent = c // child 的父节点会被修改 // 省略 } } 当一个节点， 重复被假如到其他节点的时候， 会出现这个问题。\ncobra 树实现过程解析 下面， 我们对命令树的实现过程进行拆分。 注意 每个节点分为上下两层， 上层 表示父节点的名称， 下层 表示当前节点。\nparent ---------- node 当执行第一条命令时时候， 此时创建的命令树就有所差异了。 左侧时从 root 开始， 右侧是从 sub1 开始。\n当执行的第二条命令的时候， 都实现了相同结构的命令树（不看父节点差异的话）。\n但仔细分析其内部节点， 可以知道， 相同位置的节点， 其父节点不一样。\n","description":"DevOpsCamp第2期：从 《cobra - 06 持久化命令》 开始聊聊 Go语言 指针类型的使用注意事项 如果在 公众号 文章发现状态为 已更新， 建议点击 查看原文 查看最新内容。\n状态: 未更新\n原文链接: https://typonotes.com/posts/2023/02/19/devopscamp-cobra-06-persistent-run-and-flags/\n嗯， 在 cobra 中提供了一种叫做 Persistent 的 状态， 定向支持 函数 与 参数。\n下面这段代码是是使用时的定义。\nvar root = \u0026amp;cobra.Command{ Use: \u0026#34;root\u0026#34;, // Persistent Run (1) PersistentPreRun: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;PersistentPreRun in root\u0026#34;) }, Run: func(cmd *cobra.Command, args []string) { _ = cmd.Help() }, } var config string func init() { // Persistent Flag (2) root."},{"id":40,"href":"/books/golang/cobra-in-action/","title":"99. Cobra 实战项目","parent":"","content":"","description":""},{"id":41,"href":"/books/golang/linux-go-snippet/cut/","title":"cut 切割字符串","parent":"05. Go 实现: Shell 命令","content":"cut 有几个参数， 分别提供了不同的用法。\n1. -b 获取字符或字符串 $ echo abcdefg |cut -b 1,5 ae $ echo abcdefg |cut -b 1-5 abcde 这种情况， 相当于在 Go 中的切片操作\nfunc CutB() { s := \u0026#34;abcdefg\u0026#34; b1 := s[0] // (1) var b1 byte fmt.Println(string(b1)) // cut -b 1 fmt.Println(s[0:5]) // (2) cut -b 1-5 } 这里需要注意的是\n如果对字符串取 1个值， 则取出来的值是 byte 类型。 例如这里的 b1 Go 中的索引是 从 0 开始 计数； 且属于 左闭又开 模式， 即 左包含右不包含。 2. -d 指定分隔符， -f 指定分段位置 在使用 -d 的时候， 可以指定 分割符。\n$ a-bc-de-123-a |cut -d \u0026#39;-\u0026#39; -f 2 bc 在 Go 中， 使用标准库 strings.Split 进行字符串分割\nfunc CutSplit() { s := `a-bc-de-123-a` list := strings.Split(s, \u0026#34;-\u0026#34;) // (1) var list []string fmt.Println(list[1]) // 取第 2 个位置 // Output: bc s2 := strings.Join(list, \u0026#34;/\u0026#34;) // (2) fmt.Println(s2) // Output: a/bc/de/123/a } 这里需要注意的是，\n使用 strings.Split 拆分字符串后， 将会得到一个 切片。 如果指定的分隔符不存在， 也将得到一个长度为 1 的切片， 内容就是字符串本身。 拆分之后， 可以使用 strings.Join 将切片重新组合成一个字符串。 如果切片长度为 1， 则得到字符串本身（没有分隔符）。 ","description":"cut 有几个参数， 分别提供了不同的用法。\n1. -b 获取字符或字符串 $ echo abcdefg |cut -b 1,5 ae $ echo abcdefg |cut -b 1-5 abcde 这种情况， 相当于在 Go 中的切片操作\nfunc CutB() { s := \u0026#34;abcdefg\u0026#34; b1 := s[0] // (1) var b1 byte fmt.Println(string(b1)) // cut -b 1 fmt.Println(s[0:5]) // (2) cut -b 1-5 } 这里需要注意的是\n如果对字符串取 1个值， 则取出来的值是 byte 类型。 例如这里的 b1 Go 中的索引是 从 0 开始 计数； 且属于 左闭又开 模式， 即 左包含右不包含。 2. -d 指定分隔符， -f 指定分段位置 在使用 -d 的时候， 可以指定 分割符。"},{"id":42,"href":"/books/golang/linux-go-snippet/find/","title":"find 递归查找","parent":"05. Go 实现: Shell 命令","content":"在 Linux 中， find 是一个很强大的命令， 不仅能 递归 遍历所有子目录， 还提供了丰富的参数进行过滤。 更重要的是， 可以通过 管道 + xargs 将结果提供给其他命令。\n$ find ./ -type f -name \u0026#34;*.md\u0026#34; $ find ./ -type f -name \u0026#34;*.md\u0026#34; | xargs rm -f 在 Go 中， 同样使用 os.ReadDir 获取当前目录信息， 当目标是 文件夹 的时候进行递归遍历。\n// 递归查找 func walk(name string, handler func(name string)) { entries, err := os.ReadDir(name) if err != nil { panic(err) } for _, entry := range entries { // (0) 获取 完整 的相对路径 name := filepath.Join(name, entry.Name()) if entry.IsDir() { // (1) 递归查找 walk(name, handler) } // (2) 过滤参数: -type f if strings.HasSuffix(name, \u0026#34;.md\u0026#34;) { // _ = os.Remove(name) // (3) 管道应用 | xargs rm -f handler(name) } } } // rm -f func remove(name string) { err := os.Remove(name) if err != nil { panic(err) } } 需要注意的是：\nentry.Name 得到的时候 文件名， 不包含路径。 使用 filepath 进行拼接， 获取 完整 的相对路径。 在 entry.IsDir 判断为真的时候， 调用了 walk 函数本身， 进入下一级目录，进行递归查找。 使用 strings.HasSuffix 判断文件名是否具有某些特定结尾， 类似需求中的 *.md 向 handler(name) 中传入文件路径， 类似使用 | xargs \u0026lt;do_something\u0026gt; 时的 标准输入。 handler 是一个自定义函数， 可以执行任何处理。 在使用的时候， 将 remove 作为参数端的， 类似 xargs 后面接的命令。\nfunc OsWalkDelete() { walk(\u0026#34;/path/2/somefolder\u0026#34;, remove) } ","description":"在 Linux 中， find 是一个很强大的命令， 不仅能 递归 遍历所有子目录， 还提供了丰富的参数进行过滤。 更重要的是， 可以通过 管道 + xargs 将结果提供给其他命令。\n$ find ./ -type f -name \u0026#34;*.md\u0026#34; $ find ./ -type f -name \u0026#34;*.md\u0026#34; | xargs rm -f 在 Go 中， 同样使用 os.ReadDir 获取当前目录信息， 当目标是 文件夹 的时候进行递归遍历。\n// 递归查找 func walk(name string, handler func(name string)) { entries, err := os.ReadDir(name) if err != nil { panic(err) } for _, entry := range entries { // (0) 获取 完整 的相对路径 name := filepath."},{"id":43,"href":"/books/golang/linux-go-snippet/ls/","title":"ls 查看目录内容","parent":"05. Go 实现: Shell 命令","content":"在 Linux 中， 使用 ls 命令查看文件夹内容\nls /path/2/folder 在 Go 中，\n使用 os.ReadDir 获取文件夹中的内容。 使用 os.Stat 获取详细信息， 例如 大小， 权限 等。 func OsWalk(name string) { entries, err := os.ReadDir(name) if err != nil { panic(err) } for _, entry := range entries { name := entry.Name() if entry.IsDir() { fmt.Printf(\u0026#34;%s 是文件夹\\n\u0026#34;, name) } // 如果是文件 fi, err2 := os.Stat(name) if err2 != nil { panic(err) } fmt.Printf(\u0026#34;%s %d %s\\n\u0026#34;, fi.Mode().String(), fi.Size(), name) } } ","description":"在 Linux 中， 使用 ls 命令查看文件夹内容\nls /path/2/folder 在 Go 中，\n使用 os.ReadDir 获取文件夹中的内容。 使用 os.Stat 获取详细信息， 例如 大小， 权限 等。 func OsWalk(name string) { entries, err := os.ReadDir(name) if err != nil { panic(err) } for _, entry := range entries { name := entry.Name() if entry.IsDir() { fmt.Printf(\u0026#34;%s 是文件夹\\n\u0026#34;, name) } // 如果是文件 fi, err2 := os.Stat(name) if err2 != nil { panic(err) } fmt.Printf(\u0026#34;%s %d %s\\n\u0026#34;, fi.Mode().String(), fi."},{"id":44,"href":"/books/golang/linux-go-snippet/md5sum/","title":"md5sum 计算md5值","parent":"05. Go 实现: Shell 命令","content":"在 Linux 中， 使用 MD5 值作为唯一性校验应该是最基本的了。\n# 字符串 echo \u0026#34;abc\u0026#34; | md5sum # 文件 md5sum /path/2/file.txt 计算字符串 md5 计算字符串 md5 值相对简单， 直接使用标准库中的 md5 库就可以了\nfunc MustMd5(s string) string { h := md5.New() _, err := io.WriteString(h, s) if err != nil { panic(err) } return fmt.Sprintf(\u0026#34;%x\u0026#34;, h.Sum(nil)) } 计算文件 md5 计算文件的就稍微多一个步骤， 就是读取文件内容。 读取完了， 直接丢到上一个函数中就可以了。\nfunc MustMd5File(name string) string { data, err := os.ReadFile(name) if err != nil { panic(err) } return MustMd5(string(data)) } ","description":"在 Linux 中， 使用 MD5 值作为唯一性校验应该是最基本的了。\n# 字符串 echo \u0026#34;abc\u0026#34; | md5sum # 文件 md5sum /path/2/file.txt 计算字符串 md5 计算字符串 md5 值相对简单， 直接使用标准库中的 md5 库就可以了\nfunc MustMd5(s string) string { h := md5.New() _, err := io.WriteString(h, s) if err != nil { panic(err) } return fmt.Sprintf(\u0026#34;%x\u0026#34;, h.Sum(nil)) } 计算文件 md5 计算文件的就稍微多一个步骤， 就是读取文件内容。 读取完了， 直接丢到上一个函数中就可以了。\nfunc MustMd5File(name string) string { data, err := os.ReadFile(name) if err != nil { panic(err) } return MustMd5(string(data)) } "},{"id":45,"href":"/books/golang/linux-go-snippet/mkdir/","title":"mkdir 创建目录","parent":"05. Go 实现: Shell 命令","content":"在 Linux 中， 创建目录使用 mkdir， 如果要多级创建使用 mkdir -p\nmkdir -p /path mkdir -p /path/to/abc 在 Go 中， 有对应的标准库 os.Mkdir\nfunc Mkdir() { os.Mkdir(\u0026#34;path\u0026#34;, os.ModePerm) // 创建一级目录 os.MkdirAll(\u0026#34;path/to/abc\u0026#34;, os.ModePerm) // 创建多级目录 } 在创建的时候， 需要指定目录权限， 通常使用 os.ModePerm 就可以了。\n","description":"在 Linux 中， 创建目录使用 mkdir， 如果要多级创建使用 mkdir -p\nmkdir -p /path mkdir -p /path/to/abc 在 Go 中， 有对应的标准库 os.Mkdir\nfunc Mkdir() { os.Mkdir(\u0026#34;path\u0026#34;, os.ModePerm) // 创建一级目录 os.MkdirAll(\u0026#34;path/to/abc\u0026#34;, os.ModePerm) // 创建多级目录 } 在创建的时候， 需要指定目录权限， 通常使用 os.ModePerm 就可以了。"},{"id":46,"href":"/books/golang/linux-go-snippet/random/","title":"random","parent":"05. Go 实现: Shell 命令","content":"","description":""},{"id":47,"href":"/books/golang/linux-go-snippet/sleep/","title":"sleep 时间等待","parent":"05. Go 实现: Shell 命令","content":"时间等待， 让程序 阻塞 一段时间\n在 Shell 中 在 Shell 中使用 sleep n ， n 的默认单位 秒\nsleep 2 在 Go 中 在 Go 中， 对应使用 time.Sleep(n) 方法。但是需要注意的是， n 的默认单位是 毫秒。\ntime.Sleep(200) 如果要实现如果实现 秒 级别等待，\n可以将数字扩大 1000 倍， n * 1000 可以使用单位 n * time.Second time.Sleep(2 * 1000) time.Sleep(2 * time.Second) 常见单位 const ( Nanosecond Duration = 1 // 纳秒 Microsecond = 1000 * Nanosecond // 微秒 Millisecond = 1000 * Microsecond // 毫秒 Second = 1000 * Millisecond Minute = 60 * Second Hour = 60 * Minute ) ","description":"时间等待， 让程序 阻塞 一段时间\n在 Shell 中 在 Shell 中使用 sleep n ， n 的默认单位 秒\nsleep 2 在 Go 中 在 Go 中， 对应使用 time.Sleep(n) 方法。但是需要注意的是， n 的默认单位是 毫秒。\ntime.Sleep(200) 如果要实现如果实现 秒 级别等待，\n可以将数字扩大 1000 倍， n * 1000 可以使用单位 n * time.Second time.Sleep(2 * 1000) time.Sleep(2 * time.Second) 常见单位 const ( Nanosecond Duration = 1 // 纳秒 Microsecond = 1000 * Nanosecond // 微秒 Millisecond = 1000 * Microsecond // 毫秒 Second = 1000 * Millisecond Minute = 60 * Second Hour = 60 * Minute ) "},{"id":48,"href":"/books/golang/tags/","title":"Tags","parent":"","content":"","description":""},{"id":49,"href":"/books/golang/linux-go-snippet/tr/","title":"tr 大小写转换","parent":"05. Go 实现: Shell 命令","content":" 大小写转换 tr 其中一个最常见的， 是 大小写 的转换。\necho \u0026#34;abcDefg\u0026#34; | tr \u0026#39;a-z\u0026#39; \u0026#39;A-Z\u0026#39; 对于这个使用 Go 中对应的标准库 strings\nfunc TrDemo() { s1 := strings.ToLower(\u0026#34;abcDEFg\u0026#34;) // 转小写 s2 := strings.ToUpper(\u0026#34;abcDEFg\u0026#34;) // 转大写 fmt.Println(s1, s2) } 删除字符 使用 tr -d 删除出现的字符\necho \u0026#34;abcabcabc\u0026#34; | tr -d \u0026#34;ac\u0026#34; 这种情况下， 可以使用 strings.NewReplacer 创建自己的过滤器\nfunc TrDeleteDemo(t *testing.T) { delAbc := strings.NewReplacer(\u0026#34;a\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;\u0026#34;) ret := delAbc.Replace(\u0026#34;abcabcabc\u0026#34;) fmt.Println(ret) } 其中, NewReplacer 的参数必须为双数， 两个一组(old -\u0026gt; new)。 例如这里的就是 a -\u0026gt; 空, c -\u0026gt; 空， 也就是删除的意思。\n","description":"大小写转换 tr 其中一个最常见的， 是 大小写 的转换。\necho \u0026#34;abcDefg\u0026#34; | tr \u0026#39;a-z\u0026#39; \u0026#39;A-Z\u0026#39; 对于这个使用 Go 中对应的标准库 strings\nfunc TrDemo() { s1 := strings.ToLower(\u0026#34;abcDEFg\u0026#34;) // 转小写 s2 := strings.ToUpper(\u0026#34;abcDEFg\u0026#34;) // 转大写 fmt.Println(s1, s2) } 删除字符 使用 tr -d 删除出现的字符\necho \u0026#34;abcabcabc\u0026#34; | tr -d \u0026#34;ac\u0026#34; 这种情况下， 可以使用 strings.NewReplacer 创建自己的过滤器\nfunc TrDeleteDemo(t *testing.T) { delAbc := strings.NewReplacer(\u0026#34;a\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;\u0026#34;) ret := delAbc.Replace(\u0026#34;abcabcabc\u0026#34;) fmt.Println(ret) } 其中, NewReplacer 的参数必须为双数， 两个一组(old -\u0026gt; new)。 例如这里的就是 a -\u0026gt; 空, c -\u0026gt; 空， 也就是删除的意思。"}]