[{"id":0,"href":"/books/golang/","title":"","parent":"","content":" golang 学习笔记 简介 一些高大上的话\n必读的书 《Go语言圣经》 入门经典， 进阶提升。\n中文版: https://golang-china.github.io/gopl-zh/ 《Go标准库》 帮你了解最核心的用法， 但是零散， 不成体系。\n官方英文版(最新最全): https://pkg.go.dev/std 中文版: https://studygolang.com/pkgdoc 《Go 语言设计与实现》 进阶提升， 了解原理\nhttps://draveness.me/golang/ 网友分享的 「Go 每日一库」， 这部分大多介绍开源好用的第三方库。 扩展知识面。\nGo Roadmap ","description":" golang 学习笔记 简介 一些高大上的话\n必读的书 《Go语言圣经》 入门经典， 进阶提升。\n中文版: https://golang-china.github.io/gopl-zh/ 《Go标准库》 帮你了解最核心的用法， 但是零散， 不成体系。\n官方英文版(最新最全): https://pkg.go.dev/std 中文版: https://studygolang.com/pkgdoc 《Go 语言设计与实现》 进阶提升， 了解原理\nhttps://draveness.me/golang/ 网友分享的 「Go 每日一库」， 这部分大多介绍开源好用的第三方库。 扩展知识面。\nGo Roadmap "},{"id":1,"href":"/books/golang/startup/","title":"01. Go开发环境配置","parent":"","content":"","description":""},{"id":2,"href":"/books/golang/go-features/context/","title":"01. 上下文 context","parent":"03. Go 特性语法","content":"","description":""},{"id":3,"href":"/books/golang/shell-to-go/variable/","title":"01. 变量声明","parent":"02. Go基础语法: Shell to Go","content":" 变量声明 Shell 声明变量 在 Shell 中， 变量声明通常有两种方式\n通过 declare 进行变量声明， 并赋值。 省略 declare 进行变量声明。 # 方式1 declare abc=\u0026#34;abc\u0026#34; declare abc_123=123 # 方式2 abc=\u0026#34;abc\u0026#34; abc_123=123 事实上， declare 的用法还是很复杂的， 更多可以参考: https://www.runoob.com/linux/linux-comm-declare.html\nGo 声明变量 在 Go 中， 也有两种方式\n通过 var 关键字定义， 这种方式可以在 任意位置 定义变量。 省略 var 后， 可以使用 := 进行变量声明。 但是这种方式只能在 代码块 中使用， 可以简单的理解为 只能在函数中使用。 var abc int8 = 100 // 指定 abc 的类型是 int8 var def = 100 // 推定类型为 int func demo() { a1 := 100 var a2 = 100 fmt.Println(a1, a2) } 弱类型与强类型 有句笑话说： 动态类型一时爽， 重构全是火葬场\nShell 中， 变量是完完全全的 弱类型（动态类型）。 换句话说， 同一个变量名可以是 字符串， 也可以是 数字， 也可以是其他的。\nabc=\u0026#34;word\u0026#34; # 字符串 abc=123 # 数字 abc=(value1 value2) # 数组 而 Go 是一个完完全全的 强类型 语言。 如果变量声明时是 字符串， 那么绝对不能再重新被赋值为 数字。\nfunc assignment() { abc := \u0026#34;word\u0026#34; abc = 123 // 报错: cannot use 123 (untyped int constant) as string value fmt.Println(abc) } 更有甚者， Go 语言数字还分 有无符号， 各种长度， 之间也是不能互相通用的。\nint, int8, int16, int32, int64 uint, uint8, uint16, uint32, uint64 func assignmentNumber() { var n int = 100 var n8 int8 n8 = n // cannot use n (variable of type int) as int8 value fmt.Println(n8) } 常量(只读变量) 常量， 可以理解未 不可变 的变量， 也就是 只读。\nShell 设置常量 在 Shell 中， 使用 readonly 关键字来声明常量\nreadonly abc=100 readonly abc=1000 # bash: abc: readonly variable Go 设置常量 在 Go 中， 使用 const 关键字来声明常量。\nconst abc=100 // var abc=1000 初次之外， Go 语言中还有 iota 这种特殊的用法。\nconst ( Monday = 0 Tuesday = iota // 2 _ // 3。 周 3 跳过, 但使用站位符是 iota 递增 Thursday = iota // 4 // Friday // Saturday Sunday = iota + 2 // 7。 5和6不存在， 因此 Sunday 是 iota+2 ) 使用 iota 之后， 组内的的常量值会依次递增。\n可以通过 _ 占位符， 顺序递增。 可以使用 iota+n 实现 跳值。 总结 除了 弱类型和强类型 之外， 其他大部分使用方式都差不多。\n","description":"变量声明 Shell 声明变量 在 Shell 中， 变量声明通常有两种方式\n通过 declare 进行变量声明， 并赋值。 省略 declare 进行变量声明。 # 方式1 declare abc=\u0026#34;abc\u0026#34; declare abc_123=123 # 方式2 abc=\u0026#34;abc\u0026#34; abc_123=123 事实上， declare 的用法还是很复杂的， 更多可以参考: https://www.runoob.com/linux/linux-comm-declare.html\nGo 声明变量 在 Go 中， 也有两种方式\n通过 var 关键字定义， 这种方式可以在 任意位置 定义变量。 省略 var 后， 可以使用 := 进行变量声明。 但是这种方式只能在 代码块 中使用， 可以简单的理解为 只能在函数中使用。 var abc int8 = 100 // 指定 abc 的类型是 int8 var def = 100 // 推定类型为 int func demo() { a1 := 100 var a2 = 100 fmt."},{"id":4,"href":"/books/golang/shell-to-go/process-control/if-else/","title":"01. 条件语句 (if else)","parent":"03. 流程控制","content":" Shell function abc() { n=$1 if [ $n -gt 100 ]; then { # 括号可有可无 echo \u0026#34;无效\u0026#34; } elif [ $n -gt 90 ]; then echo \u0026#34;优秀\u0026#34; else { echo \u0026#34;一般\u0026#34; } fi } 在 Shell 中，\nif-else-fi 是通过关键字约束 语句块 边界的。 大括号 {} 可有可无， 但是最好还是带上， 增强可读性。 判断条件使用 方括号 [ ] 或 [[ ]] 定义。 Go func if_else(n int) { if n \u0026gt;= 100 || n \u0026lt;= -1 { fmt.Println(\u0026#34;无效\u0026#34;) } else if n \u0026gt; 90 { fmt.Println(\u0026#34;优秀\u0026#34;) } else { fmt.Println(\u0026#34;一般\u0026#34;) } } 在 Go 中，\n大括号 {} 是语句块的定义， 必须存在。 没有关键字 then, elif, fi。 Go 中的逻辑运算符 \u0026amp;\u0026amp; 与 || 或 ! 非 这点在 Shell 中使一致的。\n关系运算符 == 等于， != 不等于 \u0026gt;, \u0026lt;, \u0026gt;=, \u0026lt;= 很直观。 ","description":"Shell function abc() { n=$1 if [ $n -gt 100 ]; then { # 括号可有可无 echo \u0026#34;无效\u0026#34; } elif [ $n -gt 90 ]; then echo \u0026#34;优秀\u0026#34; else { echo \u0026#34;一般\u0026#34; } fi } 在 Shell 中，\nif-else-fi 是通过关键字约束 语句块 边界的。 大括号 {} 可有可无， 但是最好还是带上， 增强可读性。 判断条件使用 方括号 [ ] 或 [[ ]] 定义。 Go func if_else(n int) { if n \u0026gt;= 100 || n \u0026lt;= -1 { fmt.Println(\u0026#34;无效\u0026#34;) } else if n \u0026gt; 90 { fmt."},{"id":5,"href":"/books/golang/daily-notes/environment/","title":"01. 环境变量操作","parent":"06. Go 应用笔记","content":" 一篇文章告诉你 golang 环境变量的所有基础操作 原文链接： https://typonotes.com/posts/2021/09/06/golang-os-env-operation/\ngolang 中的环境变量操作都在 os 包下面， 只有很少的几个方法， 而且字面意思也很明确。\n所有环境变量操作对象都是 字符串string ， 因此对于 int， bool 类型需要自己实现转换。\ngolang 程序执行的时候， 是在 linux 系统中 fork 的一种子进程中\ngolang程序 在 复制了开始运行的那一瞬间的当前环境所有变量， 之后的父进程中的变量变化不再影响 golang 程序。 golang 程序对环境变量的所有操作，都是在自身的子进程中，因此 只会影响 golang 程序本身。 go 语言中没有类似 bash 中的 export 的操作。 但是可以通过 os.Setenv 设置环境变量。 环境变量操作方法 1. os.Setenv(\u0026quot;key\u0026quot;,\u0026quot;val\u0026quot;) 创建一个环境变量\n2. os.Unsetenv(\u0026quot;key\u0026quot;) 取消一个变量\n3. val=os.Getenv(\u0026quot;key\u0026quot;) 返回一个变量的值。 如果变量不存在， val 为空字符串。 使用 len(val)==0 无法判断 变量值为空 或者 变量不存在\n4. val,ok=os.LookupEnv(\u0026quot;key\u0026quot;) 返回一个变量的值 与 变量是否存在的 bool 结果。\n如果变量存在， val 为值， ok 为 true\n如果变量不存在， val 为空字符串， ok 为 false\n注意， 变量不存在 (ok=false) 和 变量值为空 (ok=true) 不一样\n5. os.Clearenv() 清空所有变量。 危险 慎用。\n6. envs=os.Environ() 返回包含所有变量的 []string 切片 副本 。\n由于 os.Environ() 返回的是一个 []string 切片， 在某些场景下， 如果要进行 传递并检索 的时候， 并不是很方便， 因此会有需求转换成 map[string]string 。\n在这里 需要额外小心， 如果变量值中存在 等号 = 的话， 使用 strings.Split 进行分割之后， 而没有再使用 strings.Join 合并时， 可能会造成数据丢失。 有点拗口， 看例子。\n因为一下语句时合法的\nVAR=key1=val1,key2=val2 这句话赋值语句表示将\u0026amp; 字符串 key1=val1,key2=val2 赋值给 变量 VAR\n例如下面这段代码, envutils - fix: lost value when trans env string slice into map\n_ = os.Setenv(\u0026#34;VAR\u0026#34;, \u0026#34;key=val1,key2=val2\u0026#34;) m := make(map[string]string) envs := os.Environ() for _, pair := range envs { kv := strings.Split(pair, \u0026#34;=\u0026#34;) // m[kv[0]] = kv[1] // wrong: VAR=key 与实际情况不符合 m[kv[0]] = strings.Join(kv[1:], \u0026#34;=\u0026#34;) // 注意这里要使用 Join } 7. os.ExpandEnv(\u0026quot;string\u0026quot;) or os.Expand(\u0026quot;string\u0026quot;,os.Getenv) 如果 string 中包含 $key 或者 ${key} 的 占位符 ， 则将被替换为实际的值。就是 bash 中的变量用法。\nfunc Test_ExpandEnv(t *testing.T) { _ = os.Setenv(\u0026#34;MY_Age\u0026#34;, \u0026#34;18\u0026#34;) _ = os.Setenv(\u0026#34;MY_Name\u0026#34;, \u0026#34;Zhangsan\u0026#34;) // MY_age 大小写不匹配。 result := os.ExpandEnv(\u0026#34;my name is ${MY_Name}, i\u0026#39;m $MY_age years old\u0026#34;) fmt.Println(result) // my name is Zhangsan, i\u0026#39;m years old } ","description":"一篇文章告诉你 golang 环境变量的所有基础操作 原文链接： https://typonotes.com/posts/2021/09/06/golang-os-env-operation/\ngolang 中的环境变量操作都在 os 包下面， 只有很少的几个方法， 而且字面意思也很明确。\n所有环境变量操作对象都是 字符串string ， 因此对于 int， bool 类型需要自己实现转换。\ngolang 程序执行的时候， 是在 linux 系统中 fork 的一种子进程中\ngolang程序 在 复制了开始运行的那一瞬间的当前环境所有变量， 之后的父进程中的变量变化不再影响 golang 程序。 golang 程序对环境变量的所有操作，都是在自身的子进程中，因此 只会影响 golang 程序本身。 go 语言中没有类似 bash 中的 export 的操作。 但是可以通过 os.Setenv 设置环境变量。 环境变量操作方法 1. os.Setenv(\u0026quot;key\u0026quot;,\u0026quot;val\u0026quot;) 创建一个环境变量\n2. os.Unsetenv(\u0026quot;key\u0026quot;) 取消一个变量\n3. val=os.Getenv(\u0026quot;key\u0026quot;) 返回一个变量的值。 如果变量不存在， val 为空字符串。 使用 len(val)==0 无法判断 变量值为空 或者 变量不存在\n4. val,ok=os.LookupEnv(\u0026quot;key\u0026quot;) 返回一个变量的值 与 变量是否存在的 bool 结果。"},{"id":6,"href":"/books/golang/startup/introduce/","title":"01. 项目简介","parent":"01. Go开发环境配置","content":"","description":""},{"id":7,"href":"/books/golang/daily-notes/timezone/","title":"02. Go 的时区管理","parent":"06. Go 应用笔记","content":" 这些关于 Golang timezone 时区的坑， 我已经帮你踩过了 原文链接: https://typonotes.com/posts/2023/01/09/golang-timezone-issue/\nGolang 中一些不太注意的时区问题\n1. time/tzdata 库 Golang 内置的一个时区文件。\n可以在程序中任意位置被导入。 导入后， 如果程序 找不到本地 时区文件， 就会使用该库的数据。 本地 指的是 运行环境， 可能是实际的服务器， 也可能是容器。 通常， 应该在 main.go 中被导入。 如果是 库代码 则 不应该 导入该文件。 导入该文件后， 程序会增加 450KB 大小。 import ( _ \u0026#34;time/tzdata\u0026#34; ) 在老版本（1.15）以前并不包含时区信息， 通常会在容器化的时候单独处理时区问题。\nFROM golang:alpine as build RUN apk --no-cache add tzdata WORKDIR /app ADD . . RUN CGO_ENABLED=0 GOOS=linux go build -o myapp FROM scratch as final COPY --from=build /app/myapp . COPY --from=build /usr/share/zoneinfo /usr/share/zoneinfo ENV TZ=Europe/Berlin CMD [\u0026#34;/myapp\u0026#34;] 2. time.Parse and time.ParseInLocation 使用 time.Parse 解析时间， 默认 时区是 UTC。 使用 time.ParseInLocation 解析时间， 可以指定时区 func timeStr2Time() { timeStr := \u0026#34;2023-01-09 22:13:17\u0026#34; // 返回的是UTC时间 // 2023-01-09 22:13:17 +0000 UTC utcTimeObj, err := time.Parse(\u0026#34;2006-01-02 15:04:05\u0026#34;, timeStr) if err == nil { fmt.Println(\u0026#34;time.Parse\u0026#34;, utcTimeObj, utcTimeObj.Unix()) } // 返回的是当地时间 // 2023-01-09 22:13:17 +0800 CST localTimeObj, err := time.ParseInLocation(\u0026#34;2006-01-02 15:04:05\u0026#34;, timeStr, time.Local) if err == nil { fmt.Println(\u0026#34;time.ParseLocation\u0026#34;, localTimeObj, localTimeObj.Unix()) } } 3. 内部时区管理 默认情况下， 程序使用 程序运行的本地时区 Go提供了两个函数快速转换 时区 time.UTC() time.Local() 使用 LoadLocation(name) 设置时区。 使用 In(loc) 使用时区 func setTimezone() { n1.UTC() // 转换为 UTC 时区 n1.Local() // 转换为 本地时区 n1.Location() // 返回当前时间时区 // 没怎么用过 // loc := time.LoadLocationFromTZData() loc2, _ := time.LoadLocation(\u0026#34;Asia/Shanghai\u0026#34;) n1 := time.Now().In(loc2) fmt.Println(n1) } 4. 通过代码设置时区 在 实践操作 中 不允许 通过 代码 为 程序 本身设置时区的。\n上面提到的 不允许， 说明\n行为上 可以通过代码设置时区。 事实上 无法控制结果。 4.1 通过环境变量设置时区 可以通过设置 环境变量 的方式， 设置程序时区。\n// $ date # 本地时区 CST // Mon Jan 9 23:43:03 CST 2023 func setTimezone() { os.Setenv(\u0026#34;TZ\u0026#34;, \u0026#34;UTC\u0026#34;) fmt.Println(time.Now()) // 2023-01-09 15:42:51.309248 +0000 UTC m=+0.000084251 } 但是， 之后就 再也无法改变 时区了。\nfunc setTimezone() { os.Setenv(\u0026#34;TZ\u0026#34;, \u0026#34;UTC\u0026#34;) fmt.Println(time.Now()) os.Setenv(\u0026#34;TZ\u0026#34;, \u0026#34;Asia/Shanghai\u0026#34;) fmt.Println(time.Now()) } // 注意看第二个时间也是 UTC 时间 // 2023-01-09 15:46:41.130211 +0000 UTC m=+0.000180001 // 2023-01-09 15:46:41.130284 +0000 UTC m=+0.000253042 不仅如此， 如果之前执行过时间命令， 那么 即使第一次设置 时区也是无效的。\nfunc setTimezone() { fmt.Println(time.Now()) os.Setenv(\u0026#34;TZ\u0026#34;, \u0026#34;UTC\u0026#34;) fmt.Println(time.Now()) } // 2023-01-09 23:48:52.72857 +0800 CST m=+0.000167418 // 2023-01-09 23:48:52.729103 +0800 CST m=+0.000696960 总结， 时间操作的顺序会 影响 时区的设置。\n设置时区 到目前为止， 我还是只能老老实实去 运行环境 中操作， 设置 环境变量 TZ。\nexport TZ=Asia/Shanghai 具体可以参考 在容器中设置时区原来这么简单。\n除此之外， 还没找到其它好的办法。\n","description":"这些关于 Golang timezone 时区的坑， 我已经帮你踩过了 原文链接: https://typonotes.com/posts/2023/01/09/golang-timezone-issue/\nGolang 中一些不太注意的时区问题\n1. time/tzdata 库 Golang 内置的一个时区文件。\n可以在程序中任意位置被导入。 导入后， 如果程序 找不到本地 时区文件， 就会使用该库的数据。 本地 指的是 运行环境， 可能是实际的服务器， 也可能是容器。 通常， 应该在 main.go 中被导入。 如果是 库代码 则 不应该 导入该文件。 导入该文件后， 程序会增加 450KB 大小。 import ( _ \u0026#34;time/tzdata\u0026#34; ) 在老版本（1.15）以前并不包含时区信息， 通常会在容器化的时候单独处理时区问题。\nFROM golang:alpine as build RUN apk --no-cache add tzdata WORKDIR /app ADD . . RUN CGO_ENABLED=0 GOOS=linux go build -o myapp FROM scratch as final COPY --from=build /app/myapp ."},{"id":8,"href":"/books/golang/shell-to-go/","title":"02. Go基础语法: Shell to Go","parent":"","content":"","description":""},{"id":9,"href":"/books/golang/startup/install/","title":"02. 下载安装与环境配置","parent":"01. Go开发环境配置","content":" 下载和安装 前往 官网Go下载地址 页面下载与自己操作系统对应二进制文件。\n通常我会选择压缩包， 然后解压到所需要安装的目录。\n例如， 我是 mac 的 intel 系统， go1.19.6.darwin-amd64.tar.gz\ncd /tmp wget -c https://go.dev/dl/go1.19.6.darwin-amd64.tar.gz sudo tar xf go1.19.6.darwin-amd64.tar.gz -C /usr/local 配置环境变量 GOPROXY: Go代理地址， 通常使用 https://goproxy.cn 或 https://goproxy.io GOROOT: Go 二进制的位置, 即我们上面解压目录的 /usr/local/go GOPATH: 这个是我们项目代码的位置， 有了 go mod 之后 不是绝对的了 使用 go install 后， 编译的二进制会默认在 $GOPATH/bin/ 使用 go get 下载的所有库文件在 $GOPATH/pkg/mod/ 中 可以直接 go mod init， 如果项目在 $GOPATH/src/ 中， 会默认以相对目录配置 module 路径。 对于 Mac 和 Linux 系统， 设置环境变量。 配置到 /etc/profile 中。\nexport GOPROXY=\u0026#34;https://goproxy.cn\u0026#34; export GOROOT=\u0026#34;/usr/local/go\u0026#34; export GOPATH=\u0026#34;/data/gopath\u0026#34; export PATH=\u0026#34;$GOROOT/bin:$GOPATH/bin:$PATH\u0026#34; 执行 go version 命令测试结果。\n$ go version go version go1.19.6 darwin/amd64 关于Go版本的选择 我会选择使用 次新版本(当前为 v1.19.z) ， 并随时保持更新。 当 最新版本(当前为 1.20.z) 的 z 编号 不小于5 （即 1.20.5）的时候， 才会选择升级到最新版本。 个人意见， 仅供参考。\n","description":"下载和安装 前往 官网Go下载地址 页面下载与自己操作系统对应二进制文件。\n通常我会选择压缩包， 然后解压到所需要安装的目录。\n例如， 我是 mac 的 intel 系统， go1.19.6.darwin-amd64.tar.gz\ncd /tmp wget -c https://go.dev/dl/go1.19.6.darwin-amd64.tar.gz sudo tar xf go1.19.6.darwin-amd64.tar.gz -C /usr/local 配置环境变量 GOPROXY: Go代理地址， 通常使用 https://goproxy.cn 或 https://goproxy.io GOROOT: Go 二进制的位置, 即我们上面解压目录的 /usr/local/go GOPATH: 这个是我们项目代码的位置， 有了 go mod 之后 不是绝对的了 使用 go install 后， 编译的二进制会默认在 $GOPATH/bin/ 使用 go get 下载的所有库文件在 $GOPATH/pkg/mod/ 中 可以直接 go mod init， 如果项目在 $GOPATH/src/ 中， 会默认以相对目录配置 module 路径。 对于 Mac 和 Linux 系统， 设置环境变量。 配置到 /etc/profile 中。"},{"id":10,"href":"/books/golang/shell-to-go/function/","title":"02. 函数","parent":"02. Go基础语法: Shell to Go","content":"","description":""},{"id":11,"href":"/books/golang/shell-to-go/basic-type/","title":"02. 基础数据类型","parent":"02. Go基础语法: Shell to Go","content":"","description":""},{"id":12,"href":"/books/golang/shell-to-go/process-control/for-loops/","title":"02. 循环语句 (for)","parent":"03. 流程控制","content":" Go 循环 在 Go 中， 循环只有一个关键字 for， 通过不同的 格式 实现不同的逻辑\n基本格式如下\nfor 默认值; 条件; 计数器 { fmt.Println(\u0026#34;i=\u0026#34;, i) } 以上的 每一个字段都可以省略 。\n计数循环 在 shell 中， 通常使用 seq 实现计数循环\nfor i in $(seq 1 10); do { echo \u0026#34;i = $i\u0026#34; } done 而在 Go 中，\nfor i := 0; i \u0026lt; 1; i++ { fmt.Println(\u0026#34;i=\u0026#34;, i) } 遍历循环 for name in zhangsan lisi wangwu zhaoliu; do { echo \u0026#34;name = $name\u0026#34; } done 在 Go 中， 需要将对象放入到 切片 中\nfunc rangeSlice() { names := []string{\u0026#34;zhangsan\u0026#34;, \u0026#34;lisi\u0026#34;, \u0026#34;wangwu\u0026#34;, \u0026#34;zhaoliu\u0026#34;} for idx, value := range names { fmt.Println(names[idx], value) } } 其中， idx 为索引编号。\n遍历 map 对象 另外， 如果遍历对象是 map\nfunc rangeMap() { users := map[string]int{ \u0026#34;zhangsan\u0026#34;: 20, \u0026#34;lisi\u0026#34;: 30, \u0026#34;wangwu\u0026#34;: 40, } for key, value := range users { fmt.Println(key, value) } } 则第一个参数为 key。 而非索引。\n注意: value 在循环中， 都可以 省略， 只获取 idx 或 key。 取值的时候， 就使用 names[key] 这种方式。\nWhile 循环 在 shell 中， 使用 while 实现条件语句。 如果条件 恒真 则使用 True 或 : 实现。\nwhile True; do { date sleep 1 } done 在 Go 中， 省去前后两段， 实现条件 a\u0026lt;=b\nfor ; a\u0026lt;=b ; { fmt.Println(time.Now()) time.Sleep(1 * time.Second) } // 死循环 for { fmt.Println(time.Now()) time.Sleep(1 * time.Second) } 如果条件 恒真 则为死循环， 省略所有条件语句即可。\n跳出循环 跳出循环使用的两个关键字， 用法与 Shell 相同。\ncontinue: 结束当前循环语句， 进入下一次循环。 break: 退出所有循环， 不再执行剩下的循环次数。 for i := 1; i \u0026lt;= 10; i++ { if i%2 == 0 { // 当 i 是双数的时候， 退出当前循环 continue } if i \u0026gt; 6 { // 当 i 大于 6 的时候， 结束所有循环 break } fmt.Println(i) } 实际输出结果为 1, 3, 5。 注意， i 实际是等于 7 的时候才结束整个循环的。\n","description":"Go 循环 在 Go 中， 循环只有一个关键字 for， 通过不同的 格式 实现不同的逻辑\n基本格式如下\nfor 默认值; 条件; 计数器 { fmt.Println(\u0026#34;i=\u0026#34;, i) } 以上的 每一个字段都可以省略 。\n计数循环 在 shell 中， 通常使用 seq 实现计数循环\nfor i in $(seq 1 10); do { echo \u0026#34;i = $i\u0026#34; } done 而在 Go 中，\nfor i := 0; i \u0026lt; 1; i++ { fmt.Println(\u0026#34;i=\u0026#34;, i) } 遍历循环 for name in zhangsan lisi wangwu zhaoliu; do { echo \u0026#34;name = $name\u0026#34; } done 在 Go 中， 需要将对象放入到 切片 中"},{"id":13,"href":"/books/golang/go-features/struct/","title":"02. 结构体 struct","parent":"03. Go 特性语法","content":"","description":""},{"id":14,"href":"/books/golang/go-features/","title":"03. Go 特性语法","parent":"","content":"","description":""},{"id":15,"href":"/books/golang/startup/vscode/","title":"03. VSCode配置与插件","parent":"01. Go开发环境配置","content":" VS Code 我更喜欢 gopls， 所以我没用 goland。\n下载 到 微软官方 下载 VS Code: https://code.visualstudio.com/ 。\n插件 一个好汉三个帮， 一个篱笆三个桩。\nVSCode 本身并不是某个特定语言的 IDE。 但是安装了插件 VSCode 就是鸟枪换炮， 爽得飞起。\nGo 相关的 必须安装的 Go 插件 , 现在已经交给 Go Team 维护: 非常有用的 Go template 插件， 可以提供 template 的 高亮 和 格式化。 测试使用的 Go Test Explorer， 前期不写单元测试， 也可以不装。 提供代码片段缩写的 Go Snippet， 有用但不多。 可以将 JSON 文件直接转换成结构体的 Paste JSON as Code 通用的 格式化 JSON 的 Json Tools。 展示更方便。 远程开发必备的 Remote - SSH。 可以直接在目标机器（容器）中开发、调试。 一款网络请求的客户端工具 REST Client , 有他就可以不用 Postman 了。 工具 在安装完 最核心的 Go 插件后， VSCode 就会推荐按安装各种开发工具了。\n在 mac 下， 其他平台快捷键略有不同。\ncommand + shift + p 调出对话框， 输入 install 搜索， 得到结果 Go: install/update tools 全选， 安装即可。 ","description":"VS Code 我更喜欢 gopls， 所以我没用 goland。\n下载 到 微软官方 下载 VS Code: https://code.visualstudio.com/ 。\n插件 一个好汉三个帮， 一个篱笆三个桩。\nVSCode 本身并不是某个特定语言的 IDE。 但是安装了插件 VSCode 就是鸟枪换炮， 爽得飞起。\nGo 相关的 必须安装的 Go 插件 , 现在已经交给 Go Team 维护: 非常有用的 Go template 插件， 可以提供 template 的 高亮 和 格式化。 测试使用的 Go Test Explorer， 前期不写单元测试， 也可以不装。 提供代码片段缩写的 Go Snippet， 有用但不多。 可以将 JSON 文件直接转换成结构体的 Paste JSON as Code 通用的 格式化 JSON 的 Json Tools。 展示更方便。 远程开发必备的 Remote - SSH。 可以直接在目标机器（容器）中开发、调试。 一款网络请求的客户端工具 REST Client , 有他就可以不用 Postman 了。 工具 在安装完 最核心的 Go 插件后， VSCode 就会推荐按安装各种开发工具了。"},{"id":16,"href":"/books/golang/shell-to-go/process-control/switch/","title":"03. 分支语句 (switch)","parent":"03. 流程控制","content":"在 Shell 中使用 case ... in 做分支语句。\n使用 case ... in 作为开始， 使用 esac 作为结尾 使用 xxx ) 格式作为条件分支。 其中 xxx 可以是多个并列条件 使用 ;; 作为语句块结束。 使用 * 作为默认条件语句， 可省略。 case $1 in \u0026#34;n1\u0026#34;) echo \u0026#34;n1\u0026#34; ;; \u0026#34;n2\u0026#34; | \u0026#34;n3\u0026#34;) echo \u0026#34;n2 or n3\u0026#34; ;; *) echo \u0026#34;default\u0026#34; ;; esac 在 Go 中使用 switch 作为分支语句\n使用 switch 关键字作为开始 使用 case 关键字作为分支条件。 没有单独的结尾关键字 使用 default 作为 switch n { case 1: fmt.Println(\u0026#34;1\u0026#34;) fallthrough case 2, 3, \u0026#34;a\u0026#34;: fmt.Println(\u0026#34;2 或 3\u0026#34;) default: fmt.Println(\u0026#34;其他\u0026#34;) } 当使用 fallthrough 关键字时， 会直接进入下一条 case 语句， 不再做判断。 可以当作多个 并列条件 时使用。\n","description":"在 Shell 中使用 case ... in 做分支语句。\n使用 case ... in 作为开始， 使用 esac 作为结尾 使用 xxx ) 格式作为条件分支。 其中 xxx 可以是多个并列条件 使用 ;; 作为语句块结束。 使用 * 作为默认条件语句， 可省略。 case $1 in \u0026#34;n1\u0026#34;) echo \u0026#34;n1\u0026#34; ;; \u0026#34;n2\u0026#34; | \u0026#34;n3\u0026#34;) echo \u0026#34;n2 or n3\u0026#34; ;; *) echo \u0026#34;default\u0026#34; ;; esac 在 Go 中使用 switch 作为分支语句\n使用 switch 关键字作为开始 使用 case 关键字作为分支条件。 没有单独的结尾关键字 使用 default 作为 switch n { case 1: fmt.Println(\u0026#34;1\u0026#34;) fallthrough case 2, 3, \u0026#34;a\u0026#34;: fmt."},{"id":17,"href":"/books/golang/go-features/interface/","title":"03. 接口 interface","parent":"03. Go 特性语法","content":"","description":""},{"id":18,"href":"/books/golang/linux-go-snippet/filepath/","title":"03. 文件路径管理","parent":"05. Go 实现: Shell 命令","content":"","description":""},{"id":19,"href":"/books/golang/shell-to-go/process-control/","title":"03. 流程控制","parent":"02. Go基础语法: Shell to Go","content":"","description":""},{"id":20,"href":"/books/golang/go-libraries/","title":"04. Go 库推荐","parent":"","content":"","description":""},{"id":21,"href":"/books/golang/linux-go-snippet/filename/","title":"04. 文件名管理","parent":"05. Go 实现: Shell 命令","content":" 1. 文件名 2. 文件后缀 ","description":" 1. 文件名 2. 文件后缀 "},{"id":22,"href":"/books/golang/shell-to-go/process-control/label/","title":"04. 跳转语句(label)","parent":"03. 流程控制","content":"Label 标签在 Shell 中没有。 但在 Go 中却应用广泛。\nLabel Label 的定义规则为 SomeName: ， 以 : 结尾。\n在 Go 使用 Label 必须使用配置关键字 continue, break, goto 的其中一个。\n需要注意的是，\ncontinue 和 break 的 Label 可以省略。 continue|break [Label] goto 必须配置 Laebl 使用。 goto Label for/select/switch 和 Label 直接使用 continue/break 的时候， 作用域在 当前代码体 中。 如果配合了 Label 就可以跳出到 当前代码体外。 在配合 for/select/switch 使用时， Label 必须 紧临 他们， 中间不能有任何其他语句。 func continueBreakDemo() { Outer: for m := 1; m \u0026lt; 10; m++ { Inner: for n := 1; n \u0026lt; 10; n++ { fmt.Printf(\u0026#34;%d*%d=%d \u0026#34;, m, n, m*n) if n == 3 { break Outer } if n%4 == 0 { break Inner } } fmt.Println(\u0026#34;\u0026#34;) } } // Output: // 1*1=1 1*2=2 1*3=3 Goto Label 在配置 goto 使用的时候， Label 的位置没有特别要求。 即可以在被 调用前或后。\nfunc gotoLabel(n int) { fmt.Println(\u0026#34;刚开始\u0026#34;) goto End fmt.Println(\u0026#34;是奇数\u0026#34;) // 永远不会执行， IDE 也提示对应提示 End: fmt.Println(\u0026#34;结束啦\u0026#34;) } ","description":"Label 标签在 Shell 中没有。 但在 Go 中却应用广泛。\nLabel Label 的定义规则为 SomeName: ， 以 : 结尾。\n在 Go 使用 Label 必须使用配置关键字 continue, break, goto 的其中一个。\n需要注意的是，\ncontinue 和 break 的 Label 可以省略。 continue|break [Label] goto 必须配置 Laebl 使用。 goto Label for/select/switch 和 Label 直接使用 continue/break 的时候， 作用域在 当前代码体 中。 如果配合了 Label 就可以跳出到 当前代码体外。 在配合 for/select/switch 使用时， Label 必须 紧临 他们， 中间不能有任何其他语句。 func continueBreakDemo() { Outer: for m := 1; m \u0026lt; 10; m++ { Inner: for n := 1; n \u0026lt; 10; n++ { fmt."},{"id":23,"href":"/books/golang/go-features/channel/","title":"04. 通道 channel","parent":"03. Go 特性语法","content":"","description":""},{"id":24,"href":"/books/golang/linux-go-snippet/","title":"05. Go 实现: Shell 命令","parent":"","content":"本章节将以 Shell 中命令为索引， 汇总对应的 Go 代码实现方式或片段。\n欢迎留言补充。\n","description":"本章节将以 Shell 中命令为索引， 汇总对应的 Go 代码实现方式或片段。\n欢迎留言补充。"},{"id":25,"href":"/books/golang/shell-to-go/process-control/select/","title":"05. 并发选择语句(select)","parent":"03. 流程控制","content":"select 语句在 Shell 中没有， 但是在 Go 中却是 并发 的根基。\nselect 在语法上面， 和 switch 相似\n使用 case 作为分支入口。 使用 default 作为默认语句。 不同的是，\nselect 没有条件语句 func selectGrammar(ctx context.Context) { channel := make(chan int, 10) value := 100 select { case \u0026lt;-ctx.Done(): // 执行的代码 case \u0026lt;-time.After(10 * time.Second): // 执行的代码 case val := \u0026lt;-channel: fmt.Println(val) // 执行的代码 case channel \u0026lt;- value: // 执行代码 default: // 所有通道都没有准备好，执行的代码 } } 每个 case 语句都必须是一个通道(channel)。 常见的通道包括以下: ctx.Done。 time.After。 chan 定义的通道 所有 通达都会 被求值。 无论 进入或发送 如果在进入 select 的时候， 已经有 多个分支 的通道 就绪， 则 随机 选择一个。 如果任意分支执行了， 其他分支就不执行了。 关于 default 分支, 其他分支没准备好是 当 没有 default 将 阻塞。 由于 阻塞 的特性， 所以有一个特点是 先到先执行。 当 有 default 执行 default。 当 select 的从句执行完成后， 整个 select 就退出了。\n一直选择 因此， 在服务端通常会配合 for 一起使用。\n当 select 没有从句满足条件是， 就 阻塞 等待。 当 select 执行并退出后， 被 for 捕获， 进入下一次循环。 func foreverSelect(ctx context.Context) { for { select { case \u0026lt;-ctx.Done(): // 执行的代码 case \u0026lt;-time.After(10 * time.Second): // 执行的代码 } } } 永远等待 当需要自定义的服务保持一直运行不退出的时候， 可以使用 阻塞 特性。 （见过，没这样用过）\nfunc foreverWaiting() { // 自己实现了一个服务器 server.Run() // 阻塞以保持服务器始终运行 select {} } 总结 目前就发现这么多用法， 如果不写并发服务的话， 估计一辈子用不到 select。 T.T\n","description":"select 语句在 Shell 中没有， 但是在 Go 中却是 并发 的根基。\nselect 在语法上面， 和 switch 相似\n使用 case 作为分支入口。 使用 default 作为默认语句。 不同的是，\nselect 没有条件语句 func selectGrammar(ctx context.Context) { channel := make(chan int, 10) value := 100 select { case \u0026lt;-ctx.Done(): // 执行的代码 case \u0026lt;-time.After(10 * time.Second): // 执行的代码 case val := \u0026lt;-channel: fmt.Println(val) // 执行的代码 case channel \u0026lt;- value: // 执行代码 default: // 所有通道都没有准备好，执行的代码 } } 每个 case 语句都必须是一个通道(channel)。 常见的通道包括以下: ctx.Done。 time."},{"id":26,"href":"/books/golang/go-features/generic/","title":"05. 泛型","parent":"03. Go 特性语法","content":"","description":""},{"id":27,"href":"/books/golang/daily-notes/","title":"06. Go 应用笔记","parent":"","content":"","description":""},{"id":28,"href":"/books/golang/go-features/error-operation/","title":"06. 错误处理(error)","parent":"03. Go 特性语法","content":"","description":""},{"id":29,"href":"/books/golang/go-features/defer/","title":"07. defer","parent":"03. Go 特性语法","content":" 变量在 defer 中的值， 其实在问变量的作用域 有没有想过， 面试中经常问的 变量在 defer 之后的值， 其实是在问 函数变量的作用域\n简单的说， defer 就是将当前操作放入 堆 中， 等待触发 return 的时候再拿出来执行。 符合堆的特色， 先进后出。\n从细节来了， 还需要注意\n变量 在 defer 中的 作用域 ？ 函数 的 执行操作 是在 入堆前还是后 ？ defer 中的函数发生了 panic 会怎样 ？ 真题测试 以下这是 go语言爱好者 97 期的一道题目。 要求很简单， 代码执行 i, j 的值分别是什么。\nfunc Test_Demo(t *testing.T) { i := 10 j := hello(\u0026amp;i) fmt.Println(i, j) } func hello(i *int) int { defer func() { *i = 19 }() return *i } 这道题虽然代码少， 但是考点还是蛮多的\n核心: 函数变量作用域 defer 执行时间 闭包 指针 知识点 这里面所有的内容都可以在 Effective Go 中解决\n贪婪算法 什么是贪婪算法， 就是找到局部最优解， 合并后就是全局最优解。\n怎么找局部最优解， 就是要 对事情进行抽象，掌握事情的本质 。\ndefer 延迟执行 defer 就是语句进行压栈(FILO)处理， 延迟到 在函数 return 之前执行 执行。 本身没什么难点。 其设计目的也很明确就是为了 解决资源释放 的问题。\nopen 和 close 写在一起， 语意更直观。 解决因为错误退出，导致而 无法或忘记 释放资源 Effective Go 中对 defer 的概述。\nIt\u0026rsquo;s an unusual but effective way to deal with situations such as resources that must be released regardless of which path a function takes to return.\n这是一种不寻常但有效的方法来处理诸如必须释放资源的情况，而不管函数采用哪条路径返回。\n因此 defer 有什么好考的， 而且实际场景代码也不会那样写（违反了可读性的这一基本之准则）。\n所以通常面试中有 defer 的问题都不是在考 defer ， 只不过是披上了 defer 的狼皮。\n函数及返回值 其实 go 中关于函数返回花样还是挺多的。\n命名的/匿名的 返回值 func NamedResult(i, j int) (x int) 带参数不带参数的 return return 感觉和 golang 本身的代码可读性的的理念有一点冲突。 就像为什么不支持三元运算符一样。 其实这样本身也没有什么， 就是一两个 死记硬背 的知识点而已。\n但是遇到了 defer, 闭包, 指针 中对变量有操作， 那么问题可能就大了。\n如果对 函数变量的作用域 理解不清楚的话， 就容易掉坑。\npackage main // 命名结果 func NamedResult(i, j int) (x int) { x = i + j // 默认返回 return } // 匿名结果 func UnnamedResult(i, j int) int { // 指定返回 return i + j } 我们开启汇编， 查看一下函数过程\ngo tool compile -N -l -S main.go 从汇编结果可以看到:\n虽然我们在 UnnamedResult 代码中没有显式的提供返回值的变量名， 但是 golang 自动为我们生成了一个叫 ~r2 变量名， 其 等价于 NamedResult 函数中的变量x 汇编中 RET后没有带任何参数 所有与结果有关的操作都标记了 (SP) , ex: MOVQ AX, \u0026quot;\u0026quot;.~r2+24(SP) 既然如此， 我们就将所有函数的写法全部统一， 不再区分 命名的、 匿名的 ， 默认的， 指定的\n命名返回值 return 指定结果 func ReformResult(i, j int) (r2 int) { r2 = i + j return r2 } 这样看起来， 整个函数就清晰的多了。\n实战练习一下 根据之前所说， 我们这里来对函数做一下整形手术。\nfunc Test_reformDemo(t *testing.T) { i := 10 j := reformHello(\u0026amp;i) fmt.Println(i, j) // 19 10 } // hello 原函数 func hello(i *int) int { defer func() { *i = 19 }() return *i } // reformHello 整形函数 // reform 1. 匿名变命名 func reformHello(i *int) (_x int) { // reform 2. return 拆分 // reform 2.1 显式赋值 _x = *i // _x=10 // reform 3. defer 在返回前执行 func() { *i = 19 }() // *i=19 // reform 2.2 显式返回 return _x // _x=10 } 这样看， defer 是不是很简单了啊？\n","description":"变量在 defer 中的值， 其实在问变量的作用域 有没有想过， 面试中经常问的 变量在 defer 之后的值， 其实是在问 函数变量的作用域\n简单的说， defer 就是将当前操作放入 堆 中， 等待触发 return 的时候再拿出来执行。 符合堆的特色， 先进后出。\n从细节来了， 还需要注意\n变量 在 defer 中的 作用域 ？ 函数 的 执行操作 是在 入堆前还是后 ？ defer 中的函数发生了 panic 会怎样 ？ 真题测试 以下这是 go语言爱好者 97 期的一道题目。 要求很简单， 代码执行 i, j 的值分别是什么。\nfunc Test_Demo(t *testing.T) { i := 10 j := hello(\u0026amp;i) fmt.Println(i, j) } func hello(i *int) int { defer func() { *i = 19 }() return *i } 这道题虽然代码少， 但是考点还是蛮多的"},{"id":30,"href":"/books/golang/go-features/panic-recover/","title":"08. panic and recover","parent":"03. Go 特性语法","content":"","description":""},{"id":31,"href":"/books/golang/cobra-in-action/01-cobra-sample/","title":"1. 参数绑定与交叉编译","parent":"99. Cobra 实战项目","content":" 作业要求: 使用 https://github.com/spf13/cobra 实现命令工具 命令具有以下参数 --name 姓名 --age 年龄 如果年龄为空， 默认为 20 岁。 完成交叉编译脚本， 编译其他平台的二进制文件 -rwxr-xr-x 1 devopscamp staff 4220672 Jan 13 15:35 greeting-darwin-amd64 -rwxr-xr-x 1 devopscamp staff 4203442 Jan 13 15:35 greeting-darwin-arm64 -rwxr-xr-x 1 devopscamp staff 4215010 Jan 13 15:35 greeting-linux-amd64 -rwxr-xr-x 1 devopscamp staff 4157892 Jan 13 15:35 greeting-linux-arm64 执行输出效果如下 $ ./out/greeting-darwin-arm64 你好, 今年 20 岁 $ ./out/greeting-darwin-arm64 --age 30 --name zhangsan zhangsan 你好, 今年 30 岁 解题过程 1. 安装依赖包 $ go get -u github.com/spf13/cobra 2. 创建命令 var root = \u0026amp;cobra.Command{ Use: \u0026#34;greeting\u0026#34;, // 命令名字 Short: \u0026#34;打招呼\u0026#34;, // 短介绍 Run: func(cmd *cobra.Command, args []string) { // 运行函数 greeting(name, age) }, } 3. 指定参数 定义了变量作为参数接受者。 使用 init 函数， 在程序初始化的时候， 传递参数值。 参数接受者 指针类型 参数名称， 字符串类型 短参数名称， 字符串类型， 但只接受一个参数 默认值， 具体类型 参数描述， 字符串类型 var ( name = \u0026#34;\u0026#34; age = 0 ) func init() { root.Flags().StringVarP(\u0026amp;name, \u0026#34;name\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;姓名\u0026#34;) root.Flags().IntVarP(\u0026amp;age, \u0026#34;age\u0026#34;, \u0026#34;\u0026#34;, 20, \u0026#34;年龄\u0026#34;) } 4. 调用执行 greeting 是程序实际执行逻辑， 及执行逻辑入口。 在 root 的 Run 中调用 执行逻辑入口。 在 main 中调用 root 的执行函数 Execute() func greeting(name string, age int) { fmt.Printf(\u0026#34;%s 你好， 今年 %d 岁\\n\u0026#34;, name, age) } var root = \u0026amp;cobra.Command{ Use: \u0026#34;greeting\u0026#34;, Short: \u0026#34;打招呼\u0026#34;, Run: func(cmd *cobra.Command, args []string) { greeting(name, age) // 2. root 命令调用 greeting 业务 }, } func main() { err := root.Execute() // 3. main 调用 root 命令 if err != nil { log.Fatal(err) } } 4. 使用 Makefile 进行编译管理 使用 GOOS 和 GOARCH 设置环境变量命令。 使用 build 命令， 使用进行 当前系统环境 的编译 并且编译文件命名包含系统信息。 使用 buildx 命令， 实现 交叉编译 使用 clean 命令清空编译结果。 ## 默认变量， 获取当前 go 的环境变量 GOOS ?= $(shell go env GOOS) GOARCH ?= $(shell go env GOARCH) ## build 在指定环境变异 build: go build -o out/greeting-$(GOOS)-$(GOARCH) . ## 通过指定环境变量， 执行交叉编译 buildx: GOOS=linux GOARCH=amd64 make build GOOS=linux GOARCH=arm64 make build GOOS=darwin GOARCH=amd64 make build GOOS=darwin GOARCH=arm64 make build ## 清理编译结果 clean: rm -rf out/ 一个最基本命令结构就这样完成了， 是不是很简单？\n","description":"作业要求: 使用 https://github.com/spf13/cobra 实现命令工具 命令具有以下参数 --name 姓名 --age 年龄 如果年龄为空， 默认为 20 岁。 完成交叉编译脚本， 编译其他平台的二进制文件 -rwxr-xr-x 1 devopscamp staff 4220672 Jan 13 15:35 greeting-darwin-amd64 -rwxr-xr-x 1 devopscamp staff 4203442 Jan 13 15:35 greeting-darwin-arm64 -rwxr-xr-x 1 devopscamp staff 4215010 Jan 13 15:35 greeting-linux-amd64 -rwxr-xr-x 1 devopscamp staff 4157892 Jan 13 15:35 greeting-linux-arm64 执行输出效果如下 $ ./out/greeting-darwin-arm64 你好, 今年 20 岁 $ ./out/greeting-darwin-arm64 --age 30 --name zhangsan zhangsan 你好, 今年 30 岁 解题过程 1."},{"id":32,"href":"/books/golang/cobra-in-action/02-json-yaml-config/","title":"2. 配置文件读取与写入","parent":"99. Cobra 实战项目","content":" 作业要求 使用 https://github.com/spf13/cobra 实现命令工具 命令具有以下参数 --config , -c 配置文件 配置文件如下\n# config.yml name: zhangsan age: 20 将配置文件保存为 JSON 格式 $ cat config.json 输出结果\n{ \u0026#34;name\u0026#34;:\u0026#34;zhangsan\u0026#34;, \u0026#34;age\u0026#34;: 20 } 单个参数绑定的困境 之前我们使用了 单个参数独立绑定 的方式， 为我们的 greeting 应用绑定了 name 和 age 参数。\n这种方式有个很明显的缺点， 如果应用参数的数量较多（比如说几十个） 的时候， 就会出现庞大的参数列表， 可读性 和 维护性 都会变得很差。\nvar ( name string age int ) func init() { root.Flags().StringVarP(\u0026amp;name, \u0026#34;name\u0026#34;, \u0026#34;n\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;名字\u0026#34;) root.Flags().IntVarP(\u0026amp;age, \u0026#34;age\u0026#34;, \u0026#34;a\u0026#34;, 20, \u0026#34;名字\u0026#34;) } 因此在生产中， 我们常常会选择 配置 文件来进行 参数/变量 的管理。 例如作业要求中提到的 YAML 或者 JSON 文件。\n配置文件 最常用 的的配置文件类型就是 YAML 和 JSON。 除此之外还有 toml, xml, ini 等， 这些类型的配置文件可以在实际碰到的时候去学习掌握， 大差不差。\n通常 解析 和 映射 方法名称分别为 Marshal 和 Unmarshal\nMarshal(v any) ([]byte, error) 将结构体 解析 成 []byte 类型。 Unmarshal(data []byte, v any) error 将 []byte 映射 到结构体中。 这里的 v 需要是 指针类型 但有些库在名字上可能具有一定变种，通常也有迹可循。\nMarshalJSON MarshalYAMl 不同库 对应的的 方法名称 和 实现逻辑 也不尽相同， 如果凭经验使用遇到了问题， 一定要去看看官网文档。\n最基本常用的解析库\njson: encoding/json yaml: gopkg.in/yaml.v3, gopkg.in/yaml.v2 v2 和 v3 有区别， 自己研究。 解题过程 1. 指定配置文件参数 由于我们的实际 参数/变量 通过配置文件管理了， 因此我们就需要指定一个配置文件参数。\nvar config string func init() { root.Flags().StringVarP(\u0026amp;config, \u0026#34;config\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;config.yml\u0026#34;, \u0026#34;配置文件\u0026#34;) } 有了上一篇作业的经验， 这个应该就很简单。\n2. 读取配置 我们定义了一个名为 Person 的结构体， 包含两个字段 Name 和 Age， 用于接受参数/变量。\ntype Person struct { Name string `yaml:\u0026#34;name,omitempty\u0026#34;` Age int `yaml:\u0026#34;age,omitempty\u0026#34;` } 我们在字段后面， 使用 tag 进行了信息补充， 提供 yaml 解析的行为参数。\n图片是之前 struct 的截图， 其中\n（1） 是字段名称 （2-4） 是 tag 内容。 （2） 是 tag name， 解析库依赖此字段进行判定。 （3-4） 是 tag value, 本质上是 字符串。 例如这里 name 和 omitempty 使用 分隔符, 进行分割。 不同的库的分隔符有所不同， 例如 gorm 使用的 分号;。 （3） 在这里对应的是 映射 的字段名称。 例如 yaml 文件中的 name 对应结构体中的 Name。 这里 name 也可以是其他值， 例如 MyName， 那么就会在 yaml文件中找对应的 MyName 字段。 （4） omitempty 是 yaml 支持的操作符， 同时还支持 flow, inline。 具体功能描述可以参考 https://pkg.go.dev/gopkg.in/yaml.v3#pkg-functions func readConfig(name string) *Person { person := \u0026amp;Person{} // 1. 读取文件 b, err := os.ReadFile(config) if err != nil { panic(err) } // 2. 绑定参数 err2 := yaml.Unmarshal(b, person) if err2 != nil { panic(err) } return person } 初始化 person 指针对象， 其底层类型为 Person 结构体。 在 readConfig 函数中， 我们使用 os.ReadFile 读取文件内容。 并通过 yaml.Unmarshal 将数据映射到 person 实例中。 需要 注意的是， person 所在的参数未知， 必须是 指针 对象， 否则反射无法保存数据到 内存 中。 保存文件为 json 把配置信息保存为 json 文件， 就是之前 yaml 的反操作。\n// dumpConfig 保存文件 func dumpConfig(person *Person) { // 将结构体解析成 []byte b, err := json.Marshal(person) if err != nil { panic(err) } // os.ModePerm =\u0026gt; folder 755, file 644 err2 := os.WriteFile(\u0026#34;config.json\u0026#34;, b, os.ModePerm) if err2 != nil { panic(err) } } 使用 json.Marshal 将对象转换成 []byte。 由于是 读取操作， person 所在的参数为止可以是结构体， 也可以是指针。 使用 os.WriteFile 进行文件写入操作。 需要注意的是 os.ModePerm 这个权限， 对于文件夹是 755， 对于文件是 644， 非常的灵活。 {\u0026#34;Name\u0026#34;:\u0026#34;zhugeliang\u0026#34;,\u0026#34;Age\u0026#34;:2600} 执行后，得到的结果与期望的结果有一点点不同。注意 ，这里的 Name 和 Age 都是大写。\n我们对 Person 结构体稍微做一点改造\ntype Person struct { Name string `yaml:\u0026#34;name,omitempty\u0026#34; json:\u0026#34;name,omitempty\u0026#34;` Age int `yaml:\u0026#34;age,omitempty\u0026#34; json:\u0026#34;age,omitempty\u0026#34;` } 加上 json tag 之后， 得到的结果就与期望一致了。\n{\u0026#34;name\u0026#34;:\u0026#34;zhugeliang\u0026#34;,\u0026#34;age\u0026#34;:2600} 思考题 留一点思考题吧。\n为什么没有设置 json tag 也可以成功保存 json 配置？ 设置了 json tag 之后， json 配置中的字段名字变了， 他们的优先级是什么？ 要怎么 忽略 一个字段？ 答案在官方文档中。\n","description":"作业要求 使用 https://github.com/spf13/cobra 实现命令工具 命令具有以下参数 --config , -c 配置文件 配置文件如下\n# config.yml name: zhangsan age: 20 将配置文件保存为 JSON 格式 $ cat config.json 输出结果\n{ \u0026#34;name\u0026#34;:\u0026#34;zhangsan\u0026#34;, \u0026#34;age\u0026#34;: 20 } 单个参数绑定的困境 之前我们使用了 单个参数独立绑定 的方式， 为我们的 greeting 应用绑定了 name 和 age 参数。\n这种方式有个很明显的缺点， 如果应用参数的数量较多（比如说几十个） 的时候， 就会出现庞大的参数列表， 可读性 和 维护性 都会变得很差。\nvar ( name string age int ) func init() { root.Flags().StringVarP(\u0026amp;name, \u0026#34;name\u0026#34;, \u0026#34;n\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;名字\u0026#34;) root.Flags().IntVarP(\u0026amp;age, \u0026#34;age\u0026#34;, \u0026#34;a\u0026#34;, 20, \u0026#34;名字\u0026#34;) } 因此在生产中， 我们常常会选择 配置 文件来进行 参数/变量 的管理。 例如作业要求中提到的 YAML 或者 JSON 文件。"},{"id":33,"href":"/books/golang/cobra-in-action/03-interactive-command/","title":"3. 交互式命令","parent":"99. Cobra 实战项目","content":" 原文链接: https://tangx.in/posts/2023/01/26/devopscamp-cobra-interactive-survey/\n本文为 DevOpsCamp 实战训练作业 cobra - 03 配置文件的读取与写入（简单） 的解题答案\nDevoOpsCamp 作业地址： https://www.devopscamp.cc/semi-plan-202301-2/posts/homework/cobra03/\n作业: cobra - 03 交互式命令 要求:\n使用 https://github.com/spf13/cobra 实现命令工具\n使用 https://github.com/go-survey/survey 实现交互式命令\n实现 Demo 效果\n除了官方效果之外， 我还发现了 aliyun 命令行工具在配置账户的时候使用的是 交互式 ， 如下\n为了更好的体现 实战性， 我们将以 aliyun configure --profile 的作为例子， 并进行一些优化。\n解题过程 1. 安装 survey 依赖 这是一个意外收获， survey 库的 Github 地址与 go module 名称不一致。 同时， survey 版本还是 v2 了。\n关于 go module version ， 参考文章： https://go.dev/doc/modules/version-numbers\n话说回来， 虽然 github 仓库地址是 https://github.com/go-survey/survey ， 但安装库需要使用命令\n$ go get -u github.com/AlecAivazis/survey/v2 在 go.mod 第一行中, 也可以看到 module 的名称\nmodule github.com/AlecAivazis/survey/v2 平时在使用的时候， 应该多注意官方文档的 Usage、 exmaple 或者 _test.go 等。\n2. 需要使用的交互组件 survey 提供了很多组件类型以及 Option 参数、 验证器 等功能，非常全面。 在这里简单介绍常用的几种\nInput 组件： 普通输入框， 输入什么就显示什么。 Password 组件： 密码输入框， 输入的内容不直接显示， 使用 * 替代。 Select 组件： 单选框。 MultiSelect 组件： 多选框， 结果为 切片 类型。 Confirm 组件： 确认框， 结果为 布尔 类型。 更多其它组件， 可以参考官方文档。\n3. 代码片段 参考 aliyun 命令行， 我们自己实现的功能需要以下字段。\nAccess Secret ID Access Secret Key Region Language 代码中， 创建了 匿名 struct ， 并创建 实例 赋值给 answers\nanswers := struct { ID string Key string ChinaRegion string `survey:\u0026#34;region\u0026#34;` Language []string }{} 其中 ChinaRegion 字段通过 tag survey:\u0026quot;region\u0026quot; 指定了一个映射名字 region。 回想一下， 这种用法是不是和上一篇配置文件中的 json, yaml 字段的映射名字用法一样？\n另一方面， 我们还准备了一系列问题， 引导用户输入\n// the questions to ask var qs = []*survey.Question{ { // 1. Input 输入框 Name: \u0026#34;id\u0026#34;, Prompt: \u0026amp;survey.Input{ Message: \u0026#34;Access Secret ID: \u0026#34;, }, Validate: survey.Required, }, { // 2. Password 密码输入框 Name: \u0026#34;key\u0026#34;, Prompt: \u0026amp;survey.Password{ Message: \u0026#34;Access Secret Key: \u0026#34;, }, Validate: survey.Required, }, { // 3. Select 单选框 Name: \u0026#34;region\u0026#34;, Prompt: \u0026amp;survey.Select{ Message: \u0026#34;Choose a region:\u0026#34;, Options: []string{\u0026#34;cn-shanghai\u0026#34;, \u0026#34;cn-hangzhou\u0026#34;}, Default: \u0026#34;cn-hangzhou\u0026#34;, }, }, { // 4. MultiSelect 多选框 Name: \u0026#34;language\u0026#34;, Prompt: \u0026amp;survey.MultiSelect{ Message: \u0026#34;Supported Configure Language: \u0026#34;, Options: []string{\u0026#34;zh\u0026#34;, \u0026#34;en\u0026#34;, \u0026#34;jp\u0026#34;}, }, }, } qs 中的 Name 名称与 answers 中的字段名称都是一一对应的。 在 id 和 key 字段， 设置了验证器， 要求 必须提供。 在 region 字段， 设置 cn-hangzhou 为默认值， 虽然在切片中排在第二位。 另外， 我们还使用 Confirm 组件引导用户确认是否将输入内容保存到文件中。 由于 保存确认 并不需要保存到配置文件中， 因此我们将其单独封装在了 confirm 函数中。\nfunc confirm() bool { ok := false // 5. Confirm 确认框 prompt := \u0026amp;survey.Confirm{ Message: \u0026#34;是否保存文件?\u0026#34;, } survey.AskOne(prompt, \u0026amp;ok) return ok } 4. JSON MashralIndent 为了更好的可读性， 这次在保存配置文件的时候， 使用了 MarshalIndent 方法。\n{ \u0026#34;ID\u0026#34;: \u0026#34;AKID-demodemo-adsfasdf\u0026#34;, \u0026#34;Key\u0026#34;: \u0026#34;flasjdflaksdjf\u0026#34;, \u0026#34;ChinaRegion\u0026#34;: \u0026#34;cn-shanghai\u0026#34;, \u0026#34;Language\u0026#34;: [ \u0026#34;zh\u0026#34;, \u0026#34;en\u0026#34; ] } 5. 全局 profile 字段 你可能已经注意到了， 目前所有的代码都在 main 包下面， 并没有 划分目录结构。\nvar profile string 因此定义的 profile 是全局变量， 可以在 任意位置 直接使用。\n但是我们在使用的时候并没有在函数中直接使用， 而是通过 函数参数 的方式传递下去的。 这是我们 刻意 回避直接在 dumpConfig 中直接使用 全局的profile 的。\n关于 目录结构 我们将会在后面的作业中提到。\nvar root = \u0026amp;cobra.Command{ Use: \u0026#34;aliyunx\u0026#34;, Short: \u0026#34;aliyun 配置中心\u0026#34;, Run: func(cmd *cobra.Command, args []string) { // 1. 使用全局 profile interactive(profile) }, } func interactive(profile string) { // 2. 参数传递 dumpConfig(profile, answers) } func dumpConfig(profile string, answer any) { // 3. 参数传递 name := fmt.Sprintf(\u0026#34;%s.config.json\u0026#34;, profile) err2 := os.WriteFile(name, b, os.ModePerm) if err2 != nil { panic(err2) } } 效果展示 ","description":"原文链接: https://tangx.in/posts/2023/01/26/devopscamp-cobra-interactive-survey/\n本文为 DevOpsCamp 实战训练作业 cobra - 03 配置文件的读取与写入（简单） 的解题答案\nDevoOpsCamp 作业地址： https://www.devopscamp.cc/semi-plan-202301-2/posts/homework/cobra03/\n作业: cobra - 03 交互式命令 要求:\n使用 https://github.com/spf13/cobra 实现命令工具\n使用 https://github.com/go-survey/survey 实现交互式命令\n实现 Demo 效果\n除了官方效果之外， 我还发现了 aliyun 命令行工具在配置账户的时候使用的是 交互式 ， 如下\n为了更好的体现 实战性， 我们将以 aliyun configure --profile 的作为例子， 并进行一些优化。\n解题过程 1. 安装 survey 依赖 这是一个意外收获， survey 库的 Github 地址与 go module 名称不一致。 同时， survey 版本还是 v2 了。\n关于 go module version ， 参考文章： https://go.dev/doc/modules/version-numbers\n话说回来， 虽然 github 仓库地址是 https://github."},{"id":34,"href":"/books/golang/cobra-in-action/04-layout/","title":"4. 项目的目录结构","parent":"99. Cobra 实战项目","content":" Go 项目的目录结构 Go 项目的目录结构， 通常都会参考该项目 Go语言规范/项目结构 - Github 。\n这是一个社区规范， 遵守这个规范， 大家都会很轻松。 但并不是严格的 Go 语言标准， 实际操作中各个公司可能会有自己的标准。\n另外， 在上述的 Github 仓库中可以看到， 所有 目录功能 都只有一层。 这样就意味着在实际使用时我们是可以自由组合。 只要遵守该层的功能约定就可以了。\n例如， 使用 cobra 时， 用于管理命令的 cmd 目录， 位置可以是\n/cmd/appname/cmd # 或 /pkg/cmd/ # 或 /internal/pkg/cmd # 或 /pkg/internal/cmd 关于这个没有必要钻牛角尖， 只要是一群相对固定的维护人员认同的约定， 就可以了。\ninternal 包 internal 包是是特殊的， 也是 Go 语言规范 强制 约束的。\n首先， 它的目录位置不是固定的， 和其他包一样。 其次， 它的访问是受限的， 只有和他有 近亲亲属关系 的路径才能访问。 举个例子， 代码在 https://github.com/tangx-labs/go-internal-demo\n代码目录树如下\n限制访问 在上图中, 其中 (2) 的调用因为没有权限被限制\n在 /cmd/appname/cmd/say 访问 pkg/internal/master 时，\n找到与 /pkg 与 /cmd 是相同层级。 但是 /pkg/internal 是子层级， 与 /cmd/appname 是同一层级。 因此属于 远亲， 不能直接调用 /pkg/internal/master 公共方法暴露 但是， 可以通过 私有包的公共方法暴露， 例如上图中的 (3)\n/pkg/hello 与 /pkg/internal 是同级， 且是 近亲， 可以调用。 /pkg/hello 是公共的 /cmd/appname/cmd/say 可以通过调用 /pkg/hello 间接实现调用 master 的逻辑。（ 更多详细信息， 可以阅读 internal 运行机制\n那 internal 是不是就一定不能被访问了呢？ 也不一定， 可以参考 突破限制,访问其它Go package中的私有函数 包命名规范 关于包的命名规范， Go 官方是有明确说明的， 但是 没有强制约束 。\n要求\n短，好记，有意义： bytes, io, os 小写字母。 多个单词使用 连字符（-） 连接， 不要使用 蛇形（下划线） 或者 驼峰： qcloud-cdn-sdk 更多信息， 参考 effective_go\n函数/方法，变量命令 大写开头是公共， 小写开头是私有： 这个就不多说了 命名不要与包名有重复： 假如包名为 bytes， 函数名就不用叫 BytesReader 了， 否则调用起来就是 bytes.BytesReader。 函数名就叫 Reader 就好了， 调用起来就是 bytes.Reader。 命令要有意义： 见名知义。 命名要遵循 驼峰 规则。 循环依赖 这个就不多说了， 学了基础的都应该知道， 相关文章一搜一大把。\n这个是 Go 语言的 强制约束。 换句话说， 不用等到编译， 在写代码的时候 IDE 就会提示你出现错误。\n","description":"Go 项目的目录结构 Go 项目的目录结构， 通常都会参考该项目 Go语言规范/项目结构 - Github 。\n这是一个社区规范， 遵守这个规范， 大家都会很轻松。 但并不是严格的 Go 语言标准， 实际操作中各个公司可能会有自己的标准。\n另外， 在上述的 Github 仓库中可以看到， 所有 目录功能 都只有一层。 这样就意味着在实际使用时我们是可以自由组合。 只要遵守该层的功能约定就可以了。\n例如， 使用 cobra 时， 用于管理命令的 cmd 目录， 位置可以是\n/cmd/appname/cmd # 或 /pkg/cmd/ # 或 /internal/pkg/cmd # 或 /pkg/internal/cmd 关于这个没有必要钻牛角尖， 只要是一群相对固定的维护人员认同的约定， 就可以了。\ninternal 包 internal 包是是特殊的， 也是 Go 语言规范 强制 约束的。\n首先， 它的目录位置不是固定的， 和其他包一样。 其次， 它的访问是受限的， 只有和他有 近亲亲属关系 的路径才能访问。 举个例子， 代码在 https://github.com/tangx-labs/go-internal-demo\n代码目录树如下\n限制访问 在上图中, 其中 (2) 的调用因为没有权限被限制"},{"id":35,"href":"/books/golang/cobra-in-action/05-1-command-tree/","title":"5. 子命令与Cobra命令树的实现","parent":"99. Cobra 实战项目","content":" cobra 的子命令 在 cobra 中， 每个 命令 都是独立的。 通过 parent.AddCommand(children) 的形式进行串连。\nvar root = \u0026amp;cobra.Command{} var child = \u0026amp;cobra.Command{} func init() { root.AddCommand(child) } 没了， 应用上就这么多。\ncobra 命令树 如果你用过 gin 的路由树的话， 可能会对 cobra 的命令树实现更为深刻。\n删除多余的结构， cobra 节点 就是下面这样的。\ntype Command struct { // 子命令 commands []*Command // 父命令 parent *Command } 当进行 命令树 组合的时候， 是通过 领养/挂靠 的方式实现的。\n// AddCommand adds one or more commands to this parent command. func (c *Command) AddCommand(cmds ...*Command) { for i, x := range cmds { if cmds[i] == c { panic(\u0026#34;Command can\u0026#39;t be a child of itself\u0026#34;) } // 为子命令设置父命令（认亲） cmds[i].parent = c // (1) // 省略 // 添加传入的子命令 c.commands = append(c.commands, x) // (2) } } (1) 在我们可以在任意节点调用 Execute 方法， 这个调用会通过 递归 找到最上层的 根 节点。\nfunc (c *Command) Execute() error { _, err := c.ExecuteC() return err } // ExecuteC executes the command. func (c *Command) ExecuteC() (cmd *Command, err error) { // Regardless of what command execute is called on, run on Root only // 递归寻找最上层 if c.HasParent() { return c.Root().ExecuteC() } } 再来看一次 Command 结构体定义\ntype Command struct { // 子命令 commands []*Command // 父命令 parent *Command } (2) 通过将传入的命令保存到 []*Command 切片中， 实现了命令树的 组合 。\nc.commands = append(c.commands, x) // (2) 且同时 实现了 同一个命令挂载到多个父命令上\nroot.AddCommand(sub1, sub2) // (a) sub1.AddCommand(sub2) // (b) commands 是一个切片， 用于保存 挂载 上来的子命令。 但是， 这里需要注意， 由于 *Command 是指针类型， 意味着在任何修改， 都可能影响其他调用的地方。\n对于 sub2 而言, (a)处父节点是 root。 (b)处父节点是 sub1。 最终父节点是 sub1。 但不影响 sub2 同时是 root 和 sub1 的子命令。\n总体来说， cobra 命令节点 独立而又统一\n","description":"cobra 的子命令 在 cobra 中， 每个 命令 都是独立的。 通过 parent.AddCommand(children) 的形式进行串连。\nvar root = \u0026amp;cobra.Command{} var child = \u0026amp;cobra.Command{} func init() { root.AddCommand(child) } 没了， 应用上就这么多。\ncobra 命令树 如果你用过 gin 的路由树的话， 可能会对 cobra 的命令树实现更为深刻。\n删除多余的结构， cobra 节点 就是下面这样的。\ntype Command struct { // 子命令 commands []*Command // 父命令 parent *Command } 当进行 命令树 组合的时候， 是通过 领养/挂靠 的方式实现的。\n// AddCommand adds one or more commands to this parent command. func (c *Command) AddCommand(cmds ."},{"id":36,"href":"/books/golang/cobra-in-action/05-2-gin-router-tree/","title":"5.2 gin 路由树的实现(扩展)","parent":"99. Cobra 实战项目","content":" gin 的路由树 与 cobra 相比， gin 的路由树实现就是另外一种方式了， 我称之为 生长。 换句话说， gin 路由的子节点不能独立于父节点 单独 定义。\n// Group creates a new router group. You should add all the routes that have common middlewares or the same path prefix. // For example, all the routes that use a common middleware for authorization could be grouped. func (group *RouterGroup) Group(relativePath string, handlers ...HandlerFunc) *RouterGroup { return \u0026amp;RouterGroup{ Handlers: group.combineHandlers(handlers), basePath: group.calculateAbsolutePath(relativePath), engine: group.engine, } } 从上面代码可以看出来， RouterGroup 是通过 Group 方法实现路由节点 生长 的， 在调用 Group 方法的时候，\n必须 要传入 子节点 的相对路径 使用私有方法计算出 basePath 的值。 这个特别像怀孕生孩子， 一代接一代。 绝对错不了。 O.o。\ngin 的 RouterGroup 能实现 认亲/挂靠 模式吗？ 肯定可以， 做个变形手术就好了。 这里挖个坑吧。\n","description":"gin 的路由树 与 cobra 相比， gin 的路由树实现就是另外一种方式了， 我称之为 生长。 换句话说， gin 路由的子节点不能独立于父节点 单独 定义。\n// Group creates a new router group. You should add all the routes that have common middlewares or the same path prefix. // For example, all the routes that use a common middleware for authorization could be grouped. func (group *RouterGroup) Group(relativePath string, handlers ...HandlerFunc) *RouterGroup { return \u0026amp;RouterGroup{ Handlers: group.combineHandlers(handlers), basePath: group.calculateAbsolutePath(relativePath), engine: group.engine, } } 从上面代码可以看出来， RouterGroup 是通过 Group 方法实现路由节点 生长 的， 在调用 Group 方法的时候，"},{"id":37,"href":"/books/golang/cobra-in-action/06-persistent-flag/","title":"6. 持久化命令与Go引用类型的使用","parent":"99. Cobra 实战项目","content":" DevOpsCamp第2期：从 《cobra - 06 持久化命令》 开始聊聊 Go语言 指针类型的使用注意事项 如果在 公众号 文章发现状态为 已更新， 建议点击 查看原文 查看最新内容。\n状态: 未更新\n原文链接: https://typonotes.com/posts/2023/02/19/devopscamp-cobra-06-persistent-run-and-flags/\n嗯， 在 cobra 中提供了一种叫做 Persistent 的 状态， 定向支持 函数 与 参数。\n下面这段代码是是使用时的定义。\nvar root = \u0026amp;cobra.Command{ Use: \u0026#34;root\u0026#34;, // Persistent Run (1) PersistentPreRun: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;PersistentPreRun in root\u0026#34;) }, Run: func(cmd *cobra.Command, args []string) { _ = cmd.Help() }, } var config string func init() { // Persistent Flag (2) root.PersistentFlags().StringVarP(\u0026amp;config, \u0026#34;config\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;~/.config.json\u0026#34;, \u0026#34;配置文件\u0026#34;) } 凡是定义了 Persistent Run(1) 和 Flag(2) 的节点， 其子孙节点都会 继承 这种状态。 这种状态也可以被子孙节点的自定义状态覆盖。\n注意： 这种状态是继承自 其父节点， 而非 上级节点 。\n父节点不是上级节点 这个的问题的发生原因， 还是在 xxx.AddCommand 的时候造成的。 因为 \u0026amp;cobra.Command{} 是指针对象/引用对象， 因此在不同的地方修改是会全局影响的。 这个是基础知识， 也是重要的 坑 点， 需要牢记。\n下面是一个代码案例， 帮助理解。\n案例代码在在 Github: https://github.com/tangx-labs/cobra06-demo\n代码中实现了一个如下图所示的 命令树 结构。 其中 sub2 同时挂载到了 root 和 sub1 节点。\n以下是代码执行结果执行结果， 注意看\n--config 的参数值 PersistentPreRun 的执行结果 sub2 的 Usage 路径， 无论从哪里进入， 都是 root sub1 sub2。 代码执行过程 ./cobra-demo6 # ./cobra-demo6 PersistentPreRun in root Flags: -c, --config string 配置文件 (default \u0026#34;~/.config.json\u0026#34;) ./cobra-demo6 sub1 # ./cobra-demo6 sub1 PersistentPreRun in sub1 Flags: -c, --config string 配置文件 (default \u0026#34;$HOME/.config.json\u0026#34;) ./cobra06-demo sub2 # ./cobra06-demo sub2 # (1) PersistentPreRun in sub1 # (2) Usage: root sub1 sub2 [flags] # (3) Global Flags: -c, --config string 配置文件 (default \u0026#34;$HOME/.config.json\u0026#34;) # (4) ./cobra06-demo sub1 sub2 # ./cobra06-demo sub1 sub2 #(1) PersistentPreRun in sub1 #(2) Usage: root sub1 sub2 [flags] #(3) Global Flags: -c, --config string 配置文件 (default \u0026#34;$HOME/.config.json\u0026#34;) #(4) 引用类型回顾 首先， 我们再来回顾一下一下 Cobra Command 的结构体\ntype Command struct { Use string parent *Command\t// 父命令 commands []*Command\t// 子命令 } 可以看到， parent *Command 是指针类型。 这意味着， 在任何地方修改都会影响全局引用。\n这里简单的回顾一下 引用对象。 A, B, C 都指向 指针地址， 而 指针地址 纸箱 真实数据地址。 当因为某个外力修改了 真实数据地址 中的内容的时候， 虽然 A, B, C 都没变化， 但是他们 取 到的东西发生了变化。\n举个例子，\n你去温泉之前寄存物品， 商家会给你一个 手牌（指针地址）， 你拿着手牌将 名贵手表（数据） 放入对应的 100号柜子（真实地址）。 在你泡温泉的时候， 某个人（外力） 打开了柜子， 把你的手表换成了 塑料手表（数据修改）。 等你回来的时候， 虽然你的手牌没变， 但是你打开柜子的时候， 你拿到的不再你期望的东西了。 而正好， 每次执行 xxx.AddCommand(children) 添加子命令的时候， children 节点的 parent 字段都会被修改。\nfunc (c *Command) AddCommand(cmds ...*Command) { for i, x := range cmds { if cmds[i] == c { panic(\u0026#34;Command can\u0026#39;t be a child of itself\u0026#34;) } cmds[i].parent = c // child 的父节点会被修改 // 省略 } } 当一个节点， 重复被假如到其他节点的时候， 会出现这个问题。\ncobra 树实现过程解析 下面， 我们对命令树的实现过程进行拆分。 注意 每个节点分为上下两层， 上层 表示父节点的名称， 下层 表示当前节点。\nparent ---------- node 当执行第一条命令时时候， 此时创建的命令树就有所差异了。 左侧时从 root 开始， 右侧是从 sub1 开始。\n当执行的第二条命令的时候， 都实现了相同结构的命令树（不看父节点差异的话）。\n但仔细分析其内部节点， 可以知道， 相同位置的节点， 其父节点不一样。\n","description":"DevOpsCamp第2期：从 《cobra - 06 持久化命令》 开始聊聊 Go语言 指针类型的使用注意事项 如果在 公众号 文章发现状态为 已更新， 建议点击 查看原文 查看最新内容。\n状态: 未更新\n原文链接: https://typonotes.com/posts/2023/02/19/devopscamp-cobra-06-persistent-run-and-flags/\n嗯， 在 cobra 中提供了一种叫做 Persistent 的 状态， 定向支持 函数 与 参数。\n下面这段代码是是使用时的定义。\nvar root = \u0026amp;cobra.Command{ Use: \u0026#34;root\u0026#34;, // Persistent Run (1) PersistentPreRun: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;PersistentPreRun in root\u0026#34;) }, Run: func(cmd *cobra.Command, args []string) { _ = cmd.Help() }, } var config string func init() { // Persistent Flag (2) root."},{"id":38,"href":"/books/golang/cobra-in-action/","title":"99. Cobra 实战项目","parent":"","content":"","description":""},{"id":39,"href":"/books/golang/linux-go-snippet/cut/","title":"cut 切割字符串","parent":"05. Go 实现: Shell 命令","content":"cut 有几个参数， 分别提供了不同的用法。\n1. -b 获取字符或字符串 $ echo abcdefg |cut -b 1,5 ae $ echo abcdefg |cut -b 1-5 abcde 这种情况， 相当于在 Go 中的切片操作\nfunc CutB() { s := \u0026#34;abcdefg\u0026#34; b1 := s[0] // (1) var b1 byte fmt.Println(string(b1)) // cut -b 1 fmt.Println(s[0:5]) // (2) cut -b 1-5 } 这里需要注意的是\n如果对字符串取 1个值， 则取出来的值是 byte 类型。 例如这里的 b1 Go 中的索引是 从 0 开始 计数； 且属于 左闭又开 模式， 即 左包含右不包含。 2. -d 指定分隔符， -f 指定分段位置 在使用 -d 的时候， 可以指定 分割符。\n$ a-bc-de-123-a |cut -d \u0026#39;-\u0026#39; -f 2 bc 在 Go 中， 使用标准库 strings.Split 进行字符串分割\nfunc CutSplit() { s := `a-bc-de-123-a` list := strings.Split(s, \u0026#34;-\u0026#34;) // (1) var list []string fmt.Println(list[1]) // 取第 2 个位置 // Output: bc s2 := strings.Join(list, \u0026#34;/\u0026#34;) // (2) fmt.Println(s2) // Output: a/bc/de/123/a } 这里需要注意的是，\n使用 strings.Split 拆分字符串后， 将会得到一个 切片。 如果指定的分隔符不存在， 也将得到一个长度为 1 的切片， 内容就是字符串本身。 拆分之后， 可以使用 strings.Join 将切片重新组合成一个字符串。 如果切片长度为 1， 则得到字符串本身（没有分隔符）。 ","description":"cut 有几个参数， 分别提供了不同的用法。\n1. -b 获取字符或字符串 $ echo abcdefg |cut -b 1,5 ae $ echo abcdefg |cut -b 1-5 abcde 这种情况， 相当于在 Go 中的切片操作\nfunc CutB() { s := \u0026#34;abcdefg\u0026#34; b1 := s[0] // (1) var b1 byte fmt.Println(string(b1)) // cut -b 1 fmt.Println(s[0:5]) // (2) cut -b 1-5 } 这里需要注意的是\n如果对字符串取 1个值， 则取出来的值是 byte 类型。 例如这里的 b1 Go 中的索引是 从 0 开始 计数； 且属于 左闭又开 模式， 即 左包含右不包含。 2. -d 指定分隔符， -f 指定分段位置 在使用 -d 的时候， 可以指定 分割符。"},{"id":40,"href":"/books/golang/linux-go-snippet/find/","title":"find 递归查找","parent":"05. Go 实现: Shell 命令","content":"在 Linux 中， find 是一个很强大的命令， 不仅能 递归 遍历所有子目录， 还提供了丰富的参数进行过滤。 更重要的是， 可以通过 管道 + xargs 将结果提供给其他命令。\n$ find ./ -type f -name \u0026#34;*.md\u0026#34; $ find ./ -type f -name \u0026#34;*.md\u0026#34; | xargs rm -f 在 Go 中， 同样使用 os.ReadDir 获取当前目录信息， 当目标是 文件夹 的时候进行递归遍历。\n// 递归查找 func walk(name string, handler func(name string)) { entries, err := os.ReadDir(name) if err != nil { panic(err) } for _, entry := range entries { // (0) 获取 完整 的相对路径 name := filepath.Join(name, entry.Name()) if entry.IsDir() { // (1) 递归查找 walk(name, handler) } // (2) 过滤参数: -type f if strings.HasSuffix(name, \u0026#34;.md\u0026#34;) { // _ = os.Remove(name) // (3) 管道应用 | xargs rm -f handler(name) } } } // rm -f func remove(name string) { err := os.Remove(name) if err != nil { panic(err) } } 需要注意的是：\nentry.Name 得到的时候 文件名， 不包含路径。 使用 filepath 进行拼接， 获取 完整 的相对路径。 在 entry.IsDir 判断为真的时候， 调用了 walk 函数本身， 进入下一级目录，进行递归查找。 使用 strings.HasSuffix 判断文件名是否具有某些特定结尾， 类似需求中的 *.md 向 handler(name) 中传入文件路径， 类似使用 | xargs \u0026lt;do_something\u0026gt; 时的 标准输入。 handler 是一个自定义函数， 可以执行任何处理。 在使用的时候， 将 remove 作为参数端的， 类似 xargs 后面接的命令。\nfunc OsWalkDelete() { walk(\u0026#34;/path/2/somefolder\u0026#34;, remove) } ","description":"在 Linux 中， find 是一个很强大的命令， 不仅能 递归 遍历所有子目录， 还提供了丰富的参数进行过滤。 更重要的是， 可以通过 管道 + xargs 将结果提供给其他命令。\n$ find ./ -type f -name \u0026#34;*.md\u0026#34; $ find ./ -type f -name \u0026#34;*.md\u0026#34; | xargs rm -f 在 Go 中， 同样使用 os.ReadDir 获取当前目录信息， 当目标是 文件夹 的时候进行递归遍历。\n// 递归查找 func walk(name string, handler func(name string)) { entries, err := os.ReadDir(name) if err != nil { panic(err) } for _, entry := range entries { // (0) 获取 完整 的相对路径 name := filepath."},{"id":41,"href":"/books/golang/linux-go-snippet/ls/","title":"ls 查看目录内容","parent":"05. Go 实现: Shell 命令","content":"在 Linux 中， 使用 ls 命令查看文件夹内容\nls /path/2/folder 在 Go 中， 使用 os.ReadDir 获取文件夹中的内容。\nfunc OsWalk(name string) { entries, err := os.ReadDir(name) if err != nil { panic(err) } for _, entry := range entries { if entry.IsDir() { fmt.Printf(\u0026#34;%s 是文件夹\\n\u0026#34;, entry.Name()) } fmt.Printf(\u0026#34;%s 是文件\\n\u0026#34;, entry.Name()) } } ","description":"在 Linux 中， 使用 ls 命令查看文件夹内容\nls /path/2/folder 在 Go 中， 使用 os.ReadDir 获取文件夹中的内容。\nfunc OsWalk(name string) { entries, err := os.ReadDir(name) if err != nil { panic(err) } for _, entry := range entries { if entry.IsDir() { fmt.Printf(\u0026#34;%s 是文件夹\\n\u0026#34;, entry.Name()) } fmt.Printf(\u0026#34;%s 是文件\\n\u0026#34;, entry.Name()) } } "},{"id":42,"href":"/books/golang/linux-go-snippet/md5sum/","title":"md5sum 计算md5值","parent":"05. Go 实现: Shell 命令","content":"在 Linux 中， 使用 MD5 值作为唯一性校验应该是最基本的了。\n# 字符串 echo \u0026#34;abc\u0026#34; | md5sum # 文件 md5sum /path/2/file.txt 计算字符串 md5 计算字符串 md5 值相对简单， 直接使用标准库中的 md5 库就可以了\nfunc MustMd5(s string) string { h := md5.New() _, err := io.WriteString(h, s) if err != nil { panic(err) } return fmt.Sprintf(\u0026#34;%x\u0026#34;, h.Sum(nil)) } 计算文件 md5 计算文件的就稍微多一个步骤， 就是读取文件内容。 读取完了， 直接丢到上一个函数中就可以了。\nfunc MustMd5File(name string) string { data, err := os.ReadFile(name) if err != nil { panic(err) } return MustMd5(string(data)) } ","description":"在 Linux 中， 使用 MD5 值作为唯一性校验应该是最基本的了。\n# 字符串 echo \u0026#34;abc\u0026#34; | md5sum # 文件 md5sum /path/2/file.txt 计算字符串 md5 计算字符串 md5 值相对简单， 直接使用标准库中的 md5 库就可以了\nfunc MustMd5(s string) string { h := md5.New() _, err := io.WriteString(h, s) if err != nil { panic(err) } return fmt.Sprintf(\u0026#34;%x\u0026#34;, h.Sum(nil)) } 计算文件 md5 计算文件的就稍微多一个步骤， 就是读取文件内容。 读取完了， 直接丢到上一个函数中就可以了。\nfunc MustMd5File(name string) string { data, err := os.ReadFile(name) if err != nil { panic(err) } return MustMd5(string(data)) } "},{"id":43,"href":"/books/golang/linux-go-snippet/mkdir/","title":"mkdir 创建目录","parent":"05. Go 实现: Shell 命令","content":"在 Linux 中， 创建目录使用 mkdir， 如果要多级创建使用 mkdir -p\nmkdir -p /path mkdir -p /path/to/abc 在 Go 中， 有对应的标准库 os.Mkdir\nfunc Mkdir() { os.Mkdir(\u0026#34;path\u0026#34;, os.ModePerm) // 创建一级目录 os.MkdirAll(\u0026#34;path/to/abc\u0026#34;, os.ModePerm) // 创建多级目录 } 在创建的时候， 需要指定目录权限， 通常使用 os.ModePerm 就可以了。\n","description":"在 Linux 中， 创建目录使用 mkdir， 如果要多级创建使用 mkdir -p\nmkdir -p /path mkdir -p /path/to/abc 在 Go 中， 有对应的标准库 os.Mkdir\nfunc Mkdir() { os.Mkdir(\u0026#34;path\u0026#34;, os.ModePerm) // 创建一级目录 os.MkdirAll(\u0026#34;path/to/abc\u0026#34;, os.ModePerm) // 创建多级目录 } 在创建的时候， 需要指定目录权限， 通常使用 os.ModePerm 就可以了。"},{"id":44,"href":"/books/golang/linux-go-snippet/random/","title":"random","parent":"05. Go 实现: Shell 命令","content":"","description":""},{"id":45,"href":"/books/golang/linux-go-snippet/sleep/","title":"sleep 时间等待","parent":"05. Go 实现: Shell 命令","content":"时间等待， 让程序 阻塞 一段时间\n在 Shell 中 在 Shell 中使用 sleep n ， n 的默认单位 秒\nsleep 2 在 Go 中 在 Go 中， 对应使用 time.Sleep(n) 方法。但是需要注意的是， n 的默认单位是 毫秒。\ntime.Sleep(200) 如果要实现如果实现 秒 级别等待，\n可以将数字扩大 1000 倍， n * 1000 可以使用单位 n * time.Second time.Sleep(2 * 1000) time.Sleep(2 * time.Second) 常见单位 const ( Nanosecond Duration = 1 // 纳秒 Microsecond = 1000 * Nanosecond // 微秒 Millisecond = 1000 * Microsecond // 毫秒 Second = 1000 * Millisecond Minute = 60 * Second Hour = 60 * Minute ) ","description":"时间等待， 让程序 阻塞 一段时间\n在 Shell 中 在 Shell 中使用 sleep n ， n 的默认单位 秒\nsleep 2 在 Go 中 在 Go 中， 对应使用 time.Sleep(n) 方法。但是需要注意的是， n 的默认单位是 毫秒。\ntime.Sleep(200) 如果要实现如果实现 秒 级别等待，\n可以将数字扩大 1000 倍， n * 1000 可以使用单位 n * time.Second time.Sleep(2 * 1000) time.Sleep(2 * time.Second) 常见单位 const ( Nanosecond Duration = 1 // 纳秒 Microsecond = 1000 * Nanosecond // 微秒 Millisecond = 1000 * Microsecond // 毫秒 Second = 1000 * Millisecond Minute = 60 * Second Hour = 60 * Minute ) "},{"id":46,"href":"/books/golang/tags/","title":"Tags","parent":"","content":"","description":""},{"id":47,"href":"/books/golang/linux-go-snippet/tr/","title":"tr 大小写转换","parent":"05. Go 实现: Shell 命令","content":" 大小写转换 tr 其中一个最常见的， 是 大小写 的转换。\necho \u0026#34;abcDefg\u0026#34; | tr \u0026#39;a-z\u0026#39; \u0026#39;A-Z\u0026#39; 对于这个使用 Go 中对应的标准库 strings\nfunc TrDemo() { s1 := strings.ToLower(\u0026#34;abcDEFg\u0026#34;) // 转小写 s2 := strings.ToUpper(\u0026#34;abcDEFg\u0026#34;) // 转大写 fmt.Println(s1, s2) } 删除字符 使用 tr -d 删除出现的字符\necho \u0026#34;abcabcabc\u0026#34; | tr -d \u0026#34;ac\u0026#34; 这种情况下， 可以使用 strings.NewReplacer 创建自己的过滤器\nfunc TrDeleteDemo(t *testing.T) { delAbc := strings.NewReplacer(\u0026#34;a\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;\u0026#34;) ret := delAbc.Replace(\u0026#34;abcabcabc\u0026#34;) fmt.Println(ret) } 其中, NewReplacer 的参数必须为双数， 两个一组(old -\u0026gt; new)。 例如这里的就是 a -\u0026gt; 空, c -\u0026gt; 空， 也就是删除的意思。\n","description":"大小写转换 tr 其中一个最常见的， 是 大小写 的转换。\necho \u0026#34;abcDefg\u0026#34; | tr \u0026#39;a-z\u0026#39; \u0026#39;A-Z\u0026#39; 对于这个使用 Go 中对应的标准库 strings\nfunc TrDemo() { s1 := strings.ToLower(\u0026#34;abcDEFg\u0026#34;) // 转小写 s2 := strings.ToUpper(\u0026#34;abcDEFg\u0026#34;) // 转大写 fmt.Println(s1, s2) } 删除字符 使用 tr -d 删除出现的字符\necho \u0026#34;abcabcabc\u0026#34; | tr -d \u0026#34;ac\u0026#34; 这种情况下， 可以使用 strings.NewReplacer 创建自己的过滤器\nfunc TrDeleteDemo(t *testing.T) { delAbc := strings.NewReplacer(\u0026#34;a\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;\u0026#34;) ret := delAbc.Replace(\u0026#34;abcabcabc\u0026#34;) fmt.Println(ret) } 其中, NewReplacer 的参数必须为双数， 两个一组(old -\u0026gt; new)。 例如这里的就是 a -\u0026gt; 空, c -\u0026gt; 空， 也就是删除的意思。"}]