<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>1. props 通信 on React 18/19</title><link>https://typonotes.com/books/react/react/communication/props/</link><description>Recent content in 1. props 通信 on React 18/19</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://typonotes.com/books/react/react/communication/props/index.xml" rel="self" type="application/rss+xml"/><item><title>1. 支持的数据类型</title><link>https://typonotes.com/books/react/react/communication/props/props/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/props/props/</guid><description>/src/components/communication/Parent2Children.jsx
props 可以传递任意数据 数字, 字符串, 布尔值 数组, 对象 函数, JSX function Parent() { return ( &amp;lt;div&amp;gt; &amp;lt;Child name={&amp;#34;Wangwu&amp;#34;} age={20} isTrue={true} list={[1, 2, 3]} obj={{ name: &amp;#34;Zhaoliu&amp;#34; }} func={() =&amp;gt; { console.log(&amp;#34;Hello&amp;#34;) }} child={&amp;lt;span&amp;gt;this is a span&amp;lt;/span&amp;gt;} /&amp;gt; &amp;lt;/div&amp;gt; ); } props 是 只读对象: 子组件 只能读取 props 中的数据， 不能直接修改。 如果要修改， 只能在父组件中 由父组件修改。 参考 子传父通信 3. 兄弟通信 状态提升</description></item><item><title>2. 父传子通信</title><link>https://typonotes.com/books/react/react/communication/props/parent-to-children/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/props/parent-to-children/</guid><description>/src/components/communication/Parent2Children.jsx
实现步骤
传递数据: 父组件 在 子组件 上 绑定属性 接收数据: 子组件 使用 props 参数接收数据。 function Parent() { const name = &amp;#34;Zhangsan&amp;#34;; const age = 18; return ( &amp;lt;div&amp;gt; &amp;lt;span&amp;gt;Parent Area: &amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;name=Zhangsan, age=18&amp;lt;/span&amp;gt; {/* 1. 通过属性给 Child 传递数据 */} &amp;lt;Child name={name} age={age} /&amp;gt; &amp;lt;/div&amp;gt; ); } // 2. 定义的时候， 使用 props 接收参数 function Child(props) { // 打印所有 props console.log(props); return ( &amp;lt;div&amp;gt; &amp;lt;span&amp;gt;Child Area: &amp;lt;/span&amp;gt; {/* 3. 使用的时候， 使用 props.</description></item><item><title>3. 特殊的 children 插槽</title><link>https://typonotes.com/books/react/react/communication/props/slot-children/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/props/slot-children/</guid><description>/src/components/communication/RootCommunication.jsx
export default function RootCommunication() { return ( &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt; 7. 组件通信&amp;lt;/h2&amp;gt; {/* 1. 自闭和标签 */} &amp;lt;Parent2Children /&amp;gt; {/* 2. 成对标签， 默认插槽 */} &amp;lt;PropChild&amp;gt; &amp;lt;span&amp;gt;span1&amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;span2&amp;lt;/span&amp;gt; &amp;lt;/PropChild&amp;gt; &amp;lt;/div&amp;gt; ); } 可以看到在使用 PropChild
使用的是 成对标签。 标签中放入了两个 span 标签。 function PropChild(props) { return ( &amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;7.1. 特殊的 props.children&amp;lt;/h3&amp;gt; {/* 拿到默认的 children 属性 */} &amp;lt;span&amp;gt;prop child: {props.children}&amp;lt;/span&amp;gt; &amp;lt;hr /&amp;gt; &amp;lt;/div&amp;gt; ) } 在 PropChild 内部， 使用 props.children 拿到了传过来的标签值
使用 React Developer Tool 可以更清晰的看到其属性</description></item><item><title>4. 子传父通信</title><link>https://typonotes.com/books/react/react/communication/props/children-to-parent/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/props/children-to-parent/</guid><description>/src/components/communication/Children2Parent.jsx
核心思路: 父组件可以给子组件传递一个函数， 子组件通过调用函数向父组件传递数据
父组件通过 props 向子组件传递数据， 但 在子组件中 props 是只读的。 因此 数据只能在父组件中被修改 function Parent() { const original = &amp;#34;Father.React&amp;#34; // 在父组件定义一个状态数据 const [name, setName] = useState(original) // 重置名字 function resetName() { setName(original) } // 1. 通过函数修改父组件的状态数据 function changeName(name) { setName(name) } return ( &amp;lt;div&amp;gt; &amp;lt;p&amp;gt;父组件名字: {name}&amp;lt;/p&amp;gt; &amp;lt;b&amp;gt;父组件区域: &amp;lt;/b&amp;gt; &amp;lt;button onClick={resetName}&amp;gt;重置名称&amp;lt;/button&amp;gt; &amp;lt;span&amp;gt;重置父组件名字&amp;lt;/span&amp;gt; {/* 1. 通过 props 将函数传递给子组件 2. props 属性名字加上 on 表示调用执行 */} &amp;lt;hr&amp;gt;&amp;lt;/hr&amp;gt; &amp;lt;Child onChangeName={changeName} /&amp;gt; &amp;lt;/div&amp;gt; ) } 在 父组件中</description></item><item><title>5. 兄弟通信</title><link>https://typonotes.com/books/react/react/communication/props/brothers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/props/brothers/</guid><description>/src/components/communication/Brothers.jsx
兄弟组件没有关联关系， 因此需要 通过共同的父组件 进行数据的传递。 这并不是一个新东西， 而是将 父传子、子传父 组合案例。
function Parent() { // 1. 在父节点定义状态数据 const [name, setName] = useState(&amp;#34;&amp;#34;) // 2. 在父节点定义修改状态数据的方法 function changeName(name) { setName(name) } return ( &amp;lt;div&amp;gt; {/* 3. 给 Child A 传递修改数据方法 */} &amp;lt;ChildA onChangeName={changeName} /&amp;gt; {/* 3. 给 Child B 传递数据 */} &amp;lt;ChildB name={name} /&amp;gt; &amp;lt;/div&amp;gt; ); } 在 父节点
使用 useState 定义状态数据 name 定义 修改函数 changeName 将修改传输传递给 ChildA, 将状态数据传递给 ChildB function ChildA({ onChangeName }) { return ( &amp;lt;div&amp;gt; &amp;lt;b&amp;gt;Child A: &amp;lt;/b&amp;gt; {/* 4.</description></item></channel></rss>