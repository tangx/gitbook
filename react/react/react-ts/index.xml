<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>9. React TS 支持 on React18</title><link>https://typonotes.com/books/react/react/react-ts/</link><description>Recent content in 9. React TS 支持 on React18</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://typonotes.com/books/react/react/react-ts/index.xml" rel="self" type="application/rss+xml"/><item><title>props - ts</title><link>https://typonotes.com/books/react/react/react-ts/props-ts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/react-ts/props-ts/</guid><description>1. 使用 type 或者 interface 注解 props 注解的本质， 就是 限定函数参数类型。
可是使用 type 或者 interface 进行注解 在使用 props 的时候 传递整个对象: const TypeProps = (props: Props) =&amp;gt; {} 解耦部分字段，注意不能省略注解类型: const IterfaceProps = ({ name }: IProps) =&amp;gt; {} type Props = { name: string age: number } // 使用 Type 注解 // 获取整个 props const TypeProps = (props: Props) =&amp;gt; { return ( &amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;Props Basic&amp;lt;/h3&amp;gt; &amp;lt;p&amp;gt;{props.</description></item><item><title>useRef - ts</title><link>https://typonotes.com/books/react/react/react-ts/use-ref-ts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/react-ts/use-ref-ts/</guid><description>https://github.com/panda-frontend/react-ts-todolist
/src/componenets/TodoList/Input/index.tsx
1. 指定 HTML Element 使用 useRef 的时候， 要指定 HTML Element。 全部元素在 https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement
// https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement const inputRef = useRef&amp;lt;HTMLInputElement&amp;gt;(null); 1.1. 判断 xxxRef.current 是否存在 由于 xxxRef.current 可能不存在， 因此使用的时候需要判断存在才能取值 xxxRef.current.value
方式一, 使用 问号
xxxRef.current?value 方式二， 使用 逻辑语句
const addItem = () =&amp;gt; { // 如果值为空，不添加 if (!inputRef.current?.value) { return } const item: ToDo = { id: Date.now(), title: inputRef.current?.value, completed: false } // dispath 调用 action 添加新条目 dispatch(addTodo(item)) // 添加完成后清空 input 框 inputRef.</description></item><item><title>useState - ts</title><link>https://typonotes.com/books/react/react/react-ts/use-state-ts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/react-ts/use-state-ts/</guid><description>1. 类型推导 类型推导的根本
不在于 是否简单类型还是复杂类型。 而是 在于初始化的时候，是否传入了明确的值。 如果有明确的值， 就可以推导。 // 简单类型推导 const [count, setCount] = useState(0); // const count: number // 复杂类型推导 const [names, setNames] = useState([&amp;#39;zhangsan&amp;#39;, &amp;#39;lisi&amp;#39;]); // const names: string[] // 自定义类型的类型推导 const p: Person = { name: &amp;#39;zhangsan&amp;#39;, age: 18 } const [person, setPerson] = useState(p); // const person: Person 2. 泛型参数 没有明确初始化值的时候， 可以指定 泛型参数 明确类型约束 当指定了泛型参数后， 如果没有指定参数， 则变量为联合类型（ 指定类型 + undefined ） 如果指定了明确参数， 则为指定的类型 // 简单类型 // 只指定 泛型类型， 不指定默认参数。 变量类型为联合类型， 多一个 undefined const [name, setName] = useState&amp;lt;string&amp;gt;() // const name: string | undefined // 复杂类型 const [ages, setAges] = useState&amp;lt;Array&amp;lt;number&amp;gt;&amp;gt;() // const arr: number[] | undefined const [numbers, setNumbers] = useState&amp;lt;number[]&amp;gt;() // const arr: number[] | undefined // 自定类型 const [person, setPerson] = useState&amp;lt;IPerson&amp;gt;() // const person: IPerson | undefined // 同时指定 泛型类型 和 指定参数。 变量类型固定。 const zhangsan: IPerson = { name: &amp;#39;zhangsan&amp;#39;, age: 18 } const [user, setUser] = useState&amp;lt;IPerson&amp;gt;(zhangsan) // const user: IPerson 3.</description></item></channel></rss>