<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>useEffect 生命周期管理 on React 18/19</title><link>https://typonotes.com/books/react/react/hooks/use-effect/</link><description>Recent content in useEffect 生命周期管理 on React 18/19</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://typonotes.com/books/react/react/hooks/use-effect/index.xml" rel="self" type="application/rss+xml"/><item><title>1. 基础语法</title><link>https://typonotes.com/books/react/react/hooks/use-effect/basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/use-effect/basic/</guid><description>1. 语法规则 import { useEffect } from &amp;#39;react&amp;#39; useEffect(()=&amp;gt;{}, []) useEffect 支持两个参数
参数一是 函数 ()=&amp;gt;{}。 可以称其为 副作用函数， 在函数内部可以放置要执行的操作。 如果函数由返回值， 则表示在 组件卸载时执行， 这个后面讨论。 参数二是 数组 []（可选）， 在数组里放置 依赖项。 不同依赖项数据量导致渲染行为不一致， 这个后面讨论。 在 /src/components/hooks/UseEffectBasic.jsx 中。
import { useEffect, useState } from &amp;#34;react&amp;#34; const URL = &amp;#39;http://geek.itheima.net/v1_0/channels&amp;#39; export default function UseEffectBasic() { const [channels, setChannels] = useState([]) // 定义副作用函数， 只执行一次 useEffect(() =&amp;gt; { console.</description></item><item><title>2. 不同依赖项行为</title><link>https://typonotes.com/books/react/react/hooks/use-effect/dependencies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/use-effect/dependencies/</guid><description>2. 不同依赖项的不同渲染行为 不同状态 的数组影响第一参数函数的执行。 1. 数据被省略时： 在组件加载时执行， 且在任意渲染时执行。 2. 数组为空时： 仅在组件加载时执行 （仅执行一次）。 3. 数组中有依赖项时： 在组件加载时执行， 且在 仅在依赖项变化时触发的渲染时执行
在 /src/components/hooks/UseEffectDependencies.jsx 中
import { useState, useEffect } from &amp;#34;react&amp;#34;; export default function UseEffectDependencies() { const [count, setCount] = useState(0) const [trigger, setTrigger] = useState(0) // (1) none dependency // 组件加载时，执行一次 // 无依赖项，每次组件更新时，都会执行 useEffect(() =&amp;gt; { console.log(&amp;#39;NONE: useEffect called&amp;#39;); }); // (2) empty dependency // 仅在组件加载时执行一次 useEffect(() =&amp;gt; { console.</description></item><item><title>3. 清理副作用</title><link>https://typonotes.com/books/react/react/hooks/use-effect/clear-side-effect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/use-effect/clear-side-effect/</guid><description>3. 清除函数副作用 useEffect 的第一个参数时一个函数。 当该函数有 return 返回值 statement 的时候， 会在 组件被卸载/取消挂载 的时候执行。
如下代码， return 返回的 箭头函数 会在其所在的组件的组件被卸载的时候 停止计时器 。
useEffect( () =&amp;gt; { const id = setInterval(() =&amp;gt; { console.log(&amp;#39;Child: setInterval called&amp;#39;); }, 1000); // 当省略清理函数时， // 组件卸载时，定时器不会被清除 // 当重新加载组件时，会创建新的定时器， 多个定时器会同时运行 return () =&amp;gt; { clearInterval(id); } }, [] // 依赖项为空数组，只有在加载时执行一次， 只有在组件卸载时才会执行清理函数 ) 如果没有这段 return 清空计时器的代码， 那么当所在组件 反复 被挂载时， 每次加载都会启动一个新的定时器， 结果就是 启动无数个 计时器。</description></item></channel></rss>