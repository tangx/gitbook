[{"id":0,"href":"/books/react/","title":"","parent":"","content":"react 18 notebook     所有文档      项目笔记  资源      黑马程序员前端React18入门到实战视频教程  React18 - 配套资料    ","description":"react 18 notebook     所有文档      项目笔记  资源      黑马程序员前端React18入门到实战视频教程  React18 - 配套资料    "},{"id":1,"href":"/books/react/demos/account-book/data-analysis/","title":"Data Analysis","parent":"3. Redux-Router 案例: 账本","content":"1. lodash 根据时间分组数据     安装\n$ npm install lodash 分组数据\nconst newList = lodash.groupBy(billList, (item) =\u0026gt; { return dayjs(item.date).format(\u0026#39;YYYY-MM\u0026#39;) }) console.log(\u0026#34;newList\u0026#34;, newList) 2. useMemo 缓存数据      useMemo 用于缓存数据， 依赖数据变化时， 才会重新计算。 类似 vue 中的 computed 用法与 useEffect 类似， 但是 useEffect 是用于处理副作用的， useMemo 是用于缓存数据的  // 获取原始数据 billList const { billList } = useSelector(state =\u0026gt; state.bill) const monthGroup = useMemo( // 计算函数  // 不需要传入参数， 因为依赖项已经在外部声明  // 错误示范 (billList)=\u0026gt;{return billList}  () =\u0026gt; { // return billList  return lodash.groupBy(billList, (item) =\u0026gt; { return dayjs(item.date).format(\u0026#39;YYYY-MM\u0026#39;) }) }, // 依赖项, 变更后重新触发计算  [billList] ) console.log(\u0026#34;monthGroup\u0026#34;, monthGroup); 3. 使用 Array.reduce() 方法计算月度盈余       设置两个依赖项, 并 提取 当前月份数据 currentList\n monthGroup 所有月份数据 currentDate 当前选择月份    使用 currentList.reduce() 统计收入、支出、盈余数据\n   注意: reduce() 方法如果不支持 pre 的默认值， 那么第一个元素将是默认值。\n currentList.reduce( // pre 是上一次的结果， cur 是当前的元素  (pre, cur) =\u0026gt; { }, // pre 的初始值。  // 如果不传入初始值， 则默认是数组的第一个元素  {} ) 下述代码由于只用了 current 数据统计， 如果省略默认值将丢数据。\n// #126 展示月度收支 const monthResult = useMemo( // 计算函数  () =\u0026gt; { // 获取当前月份的数据  const currentList = monthGroup[currentDate] // 如果当前月份没有数据， 则返回 0  if (!currentList) { return { pay: 0, income: 0, surplus: 0 } } // 设置统计数据初始值  let pay = 0 let income = 0 let surplus = 0 // 盈余  // console.log(\u0026#34;currentList\u0026#34;, currentList);  currentList.reduce( // pre 是上一次的结果， cur 是当前的元素  (pre, cur) =\u0026gt; { // console.log(\u0026#34;pre\u0026#34;, pre);  // console.log(\u0026#34;cur\u0026#34;, cur);  if (cur.type === \u0026#39;income\u0026#39;) { // console.log(\u0026#34;income: cur.money\u0026#34;, cur.money);  income += cur.money } if (cur.type === \u0026#39;pay\u0026#39;) { // console.log(\u0026#34;pay: cur.money\u0026#34;, cur.money);  pay += cur.money } }, // pre 的初始值。  // 如果不传入初始值， 则默认是数组的第一个元素  {} ) // 因为 pay 是负数， 所以是加法  surplus = pay + income return { pay, income, surplus } }, // 依赖项  // monthGroup: 按月分组数据  // currentDate: 格式化月份数据 // YYYY-MM  [monthGroup, currentDate] ) 随后在页面展示中使用数据即可。\n\u0026lt;div className=\u0026#39;twoLineOverview\u0026#39;\u0026gt; \u0026lt;div className=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;span className=\u0026#34;money\u0026#34;\u0026gt;{monthResult.pay}\u0026lt;/span\u0026gt; \u0026lt;span className=\u0026#34;type\u0026#34;\u0026gt;支出\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;span className=\u0026#34;money\u0026#34;\u0026gt;{monthResult.income}\u0026lt;/span\u0026gt; \u0026lt;span className=\u0026#34;type\u0026#34;\u0026gt;收入\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;span className=\u0026#34;money\u0026#34;\u0026gt;{monthResult.surplus}\u0026lt;/span\u0026gt; \u0026lt;span className=\u0026#34;type\u0026#34;\u0026gt;结余\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 4. 页面初始化时统计数据      https://www.bilibili.com/video/BV1ZB4y1Z7o8?p=72\n 本节课程本意是使用 useEffect 管理声明周期。\n其中 monthGroup?[nowDate] 中的 ? 是类型守卫。 防止 monthGroup 为 undefined 的时候取值报错。\nuseEffect( ()=\u0026gt;{ const nowDate = dayjs().format(\u0026#39;YYYY-MM\u0026#39;) setMonthList(monthGroup?[nowDate]) }, [monthGroup] ) 但是， 我在之前获取 monthResult 的 useMemo 是已经设置了多个 依赖项 其中就报错 currentDate， 已经实现了效果。\n","description":"1. lodash 根据时间分组数据     安装\n$ npm install lodash 分组数据\nconst newList = lodash.groupBy(billList, (item) =\u0026gt; { return dayjs(item.date).format(\u0026#39;YYYY-MM\u0026#39;) }) console.log(\u0026#34;newList\u0026#34;, newList) 2. useMemo 缓存数据      useMemo 用于缓存数据， 依赖数据变化时， 才会重新计算。 类似 vue 中的 computed 用法与 useEffect 类似， 但是 useEffect 是用于处理副作用的， useMemo 是用于缓存数据的  // 获取原始数据 billList const { billList } = useSelector(state =\u0026gt; state.bill) const monthGroup = useMemo( // 计算函数  // 不需要传入参数， 因为依赖项已经在外部声明  // 错误示范 (billList)=\u0026gt;{return billList}  () =\u0026gt; { // return billList  return lodash."},{"id":2,"href":"/books/react/SUMMARY/","title":"Summary","parent":"","content":"React 18 学习笔记      初始化项目  ","description":"React 18 学习笔记      初始化项目  "},{"id":3,"href":"/books/react/setup/initalize/","title":"0. 初始化项目","parent":"1. 环境配置","content":"","description":""},{"id":4,"href":"/books/react/demos/account-book/pash-alias/","title":"01. 使用 @ 路径别名","parent":"3. Redux-Router 案例: 账本","content":"注意： 非注释行 是新添加的。\n// import { defineConfig } from \u0026#39;vite\u0026#39; // import react from \u0026#39;@vitejs/plugin-react\u0026#39;  import path from \u0026#39;path\u0026#39; // https://vitejs.dev/config/ export default defineConfig({ // plugins: [react()],  resolve: { alias: { // @ =\u0026gt; src  \u0026#34;@\u0026#34;: path.resolve(__dirname, \u0026#34;src\u0026#34;) }, }, }) 当然还可以添加更多， https://typonotes.com/posts/2021/09/28/vue3-with-alias-path/\n","description":"注意： 非注释行 是新添加的。\n// import { defineConfig } from \u0026#39;vite\u0026#39; // import react from \u0026#39;@vitejs/plugin-react\u0026#39;  import path from \u0026#39;path\u0026#39; // https://vitejs.dev/config/ export default defineConfig({ // plugins: [react()],  resolve: { alias: { // @ =\u0026gt; src  \u0026#34;@\u0026#34;: path.resolve(__dirname, \u0026#34;src\u0026#34;) }, }, }) 当然还可以添加更多， https://typonotes.com/posts/2021/09/28/vue3-with-alias-path/"},{"id":5,"href":"/books/react/demos/account-book/setup/","title":"01. 初始化","parent":"3. Redux-Router 案例: 账本","content":" 这个 demo 不要随意发挥， 尤其是在命名上。 因为有很多 格式代码 要直接复制课件。\n 1. 使用 npm vite 创建项目     $ npm create vite@latest # React -\u0026gt; JavaScript 2. 安装依赖插件     2.1. sass     $ npm install sass --save 2.2. axios     $ npm install axios --save 2.3.     3. 使用 JsonServer 模拟数据     $ json-server --port 8888 /src/server/data/data/json 3.1. 配置 pakcage.json 同时启动 json-server 和 dev 环境     \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;npm run server \u0026amp; vite\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;vite build\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;eslint . --ext js,jsx --report-unused-disable-directives --max-warnings 0\u0026#34;, \u0026#34;preview\u0026#34;: \u0026#34;vite preview\u0026#34;, \u0026#34;server\u0026#34;:\u0026#34;json-server --port 3001 ./src/server/data/data.json\u0026#34; }, 4. 下载 Account Book 的课件笔记     已被后续使用\n ","description":"这个 demo 不要随意发挥， 尤其是在命名上。 因为有很多 格式代码 要直接复制课件。\n 1. 使用 npm vite 创建项目     $ npm create vite@latest # React -\u0026gt; JavaScript 2. 安装依赖插件     2.1. sass     $ npm install sass --save 2.2. axios     $ npm install axios --save 2.3.     3. 使用 JsonServer 模拟数据     $ json-server --port 8888 /src/server/data/data/json 3."},{"id":6,"href":"/books/react/demos/account-book/route/","title":"02. 初始化 route","parent":"3. Redux-Router 案例: 账本","content":" 安装 react-route  npm install react-router-dom 创建目录结构  tree . ├── components │ ├── Layout │ │ ├── Month │ │ │ └── index.jsx │ │ ├── Year │ │ │ └── index.jsx │ │ └── index.jsx │ └── New │ └── index.jsx 在 /src/routes/index.jsx 因为要写标签， 一定要用 jsx 中， 创建路由  import { createBrowserRouter } from \u0026#34;react-router-dom\u0026#34;; import Layout from \u0026#34;../components/Layout\u0026#34;; import Month from \u0026#34;../components/Layout/Month\u0026#34;; import Year from \u0026#34;../components/Layout/Year\u0026#34;; import New from \u0026#34;../components/New\u0026#34;; export default createBrowserRouter( [ { path: \u0026#34;/\u0026#34;, element: \u0026lt;Layout /\u0026gt;, children: [ { // path: \u0026#34;/month\u0026#34;,  index: true, element: \u0026lt;Month /\u0026gt; }, { path: \u0026#34;/year\u0026#34;, element: \u0026lt;Year /\u0026gt; } ] }, { path: \u0026#34;/new\u0026#34;, element: \u0026lt;New /\u0026gt; } ] ); 在 App.jsx 中使用 RouterProvider 使用路由策略  // import \u0026#39;./App.css\u0026#39; import { RouterProvider } from \u0026#39;react-router-dom\u0026#39; import router from \u0026#39;./routes\u0026#39; function App() { return ( \u0026lt;\u0026gt; \u0026lt;RouterProvider router={router} /\u0026gt; \u0026lt;/\u0026gt; ) } export default App ","description":"安装 react-route  npm install react-router-dom 创建目录结构  tree . ├── components │ ├── Layout │ │ ├── Month │ │ │ └── index.jsx │ │ ├── Year │ │ │ └── index.jsx │ │ └── index.jsx │ └── New │ └── index.jsx 在 /src/routes/index.jsx 因为要写标签， 一定要用 jsx 中， 创建路由  import { createBrowserRouter } from \u0026#34;react-router-dom\u0026#34;; import Layout from \u0026#34;../components/Layout\u0026#34;; import Month from \u0026#34;../components/Layout/Month\u0026#34;; import Year from \u0026#34;../components/Layout/Year\u0026#34;; import New from \u0026#34;."},{"id":7,"href":"/books/react/demos/account-book/redux/","title":"03. 使用 redux 管理数据","parent":"3. Redux-Router 案例: 账本","content":"1. 安装 redux 和 toolskit     $ npm install @reduxjs/toolkit react-redux 2. 初始化 redux store      在 /src/demos/AccountBook/src/store/modules/billStore/index.js 中  使用 createSlice 创建 billStore 初始化 name, initialState, reducers 默认导出 billStore.reduer 创建同步 action setBillList 创建异步 action getBillList， 并从 json-server 中获取数据 导出 getBillList。   在 /src/demos/AccountBook/src/store/index.js 中  使用 configureStore 创建 store 导入 billStore.reduer。 再导入 store.reducer 中， 并指定为 bill。 默认导出 store   在 /src/demos/AccountBook/src/demos/AccountBook/src/App.jsx 中  从 redux 中导入 Provider 使用 Provider 包裹 App， 并传递 store   在 /src/demos/AccountBook/src/demos/AccountBook/src/components/Layout/index.jsx 中  使用 useSelector 从 store 中获取到 state.account.billList 使用 billList.map 遍历并渲染 \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt;， 展示结果。    ","description":"1. 安装 redux 和 toolskit     $ npm install @reduxjs/toolkit react-redux 2. 初始化 redux store      在 /src/demos/AccountBook/src/store/modules/billStore/index.js 中  使用 createSlice 创建 billStore 初始化 name, initialState, reducers 默认导出 billStore.reduer 创建同步 action setBillList 创建异步 action getBillList， 并从 json-server 中获取数据 导出 getBillList。   在 /src/demos/AccountBook/src/store/index.js 中  使用 configureStore 创建 store 导入 billStore.reduer。 再导入 store.reducer 中， 并指定为 bill。 默认导出 store   在 /src/demos/AccountBook/src/demos/AccountBook/src/App."},{"id":8,"href":"/books/react/demos/account-book/antd-mobile-theme/","title":"04. andD-mobile 主题","parent":"3. Redux-Router 案例: 账本","content":"And Design Mobile 是一个 移动端 的样式库\n1. 安装     $ npm install --save antd-mobile # or $ yarn add antd-mobile 2. 使用     import { Button } from \u0026#39;antd-mobile\u0026#39; // 组件按钮 \u0026lt;Button type=\u0026#34;primary\u0026#34;\u0026gt;点我+1\u0026lt;/Button\u0026gt; // 原生按钮 \u0026lt;button\u0026gt;点我+1\u0026lt;/button\u0026gt; 3. 主题定制       全局定制: 整个应用范围 内的所有组件都生效  /* 蓝色 */ :root:root { --adm-color-primary: #006DFD; } 局部定制: 只有在某些元素 内部生效。  /* 紫色 */ .purple-theme { --adm-color-primary: #9E53D4; } ","description":"And Design Mobile 是一个 移动端 的样式库\n1. 安装     $ npm install --save antd-mobile # or $ yarn add antd-mobile 2. 使用     import { Button } from \u0026#39;antd-mobile\u0026#39; // 组件按钮 \u0026lt;Button type=\u0026#34;primary\u0026#34;\u0026gt;点我+1\u0026lt;/Button\u0026gt; // 原生按钮 \u0026lt;button\u0026gt;点我+1\u0026lt;/button\u0026gt; 3. 主题定制       全局定制: 整个应用范围 内的所有组件都生效  /* 蓝色 */ :root:root { --adm-color-primary: #006DFD; } 局部定制: 只有在某些元素 内部生效。  /* 紫色 */ .purple-theme { --adm-color-primary: #9E53D4; } "},{"id":9,"href":"/books/react/demos/account-book/tabbar/","title":"05. TabBar","parent":"3. Redux-Router 案例: 账本","content":"官网文档 TabBar\n 1. 准备工作     从课件中复制 TabBar 的 index.jsx 和 index.scss 到 /src/demos/AccountBook/src/components/Layout 中\n2. 切换路由     注意 看文档， 可能不同的样式库有不同的实现方式。\n 路由切换是在 TabBar 的 onChange 事件实现的。 而非在 TabBar.Item 中的 onClick 中实现。  import { useNavigate } from \u0026#39;react-router-dom\u0026#39; const Layout = () =\u0026gt; { const navigate = useNavigate() // 切换路由  const switchRouteActive = (path) =\u0026gt; { navigate(path) } // 返回  return ( \u0026lt;TabBar onChange={path =\u0026gt; switchRouteActive(path)}\u0026gt; {/* \u0026lt;TabBar onChange={path =\u0026gt; useNavigate(path)}\u0026gt; // 可行*/} {tabs.map(item =\u0026gt; ( // 而非在 TabBar.Item 中。  \u0026lt;TabBar.Item key={item.key} icon={item.icon} title={item.title} /\u0026gt; ))} \u0026lt;/TabBar\u0026gt; ) } ","description":"官网文档 TabBar\n 1. 准备工作     从课件中复制 TabBar 的 index.jsx 和 index.scss 到 /src/demos/AccountBook/src/components/Layout 中\n2. 切换路由     注意 看文档， 可能不同的样式库有不同的实现方式。\n 路由切换是在 TabBar 的 onChange 事件实现的。 而非在 TabBar.Item 中的 onClick 中实现。  import { useNavigate } from \u0026#39;react-router-dom\u0026#39; const Layout = () =\u0026gt; { const navigate = useNavigate() // 切换路由  const switchRouteActive = (path) =\u0026gt; { navigate(path) } // 返回  return ( \u0026lt;TabBar onChange={path =\u0026gt; switchRouteActive(path)}\u0026gt; {/* \u0026lt;TabBar onChange={path =\u0026gt; useNavigate(path)}\u0026gt; // 可行*/} {tabs."},{"id":10,"href":"/books/react/demos/account-book/date-picker-monthly/","title":"06. 时间选择器 - 月度统计","parent":"3. Redux-Router 案例: 账本","content":"1. 管理时间选择器状态      1.1. 使用 useState 管理时间选择器状态     const [dateVisable, setDateVisable] = useState(false) 1.2. 点击箭头展开时选择器      使用onClick 事件 打开时间选择器控件 使用 classNames 控制箭头显示状态  \u0026lt;div className=\u0026#34;date\u0026#34; // 打开时间选择器 onClick={() =\u0026gt; setDateVisable(true)}\u0026gt; {/* \u0026lt;span className=\u0026#39;arrow expand\u0026#39;\u0026gt;\u0026lt;/span\u0026gt; */} {/* 错误示范 */} {/* \u0026lt;span className=classNames={\u0026#39;arrow\u0026#39;, \u0026#39;expand\u0026#39;}\u0026gt;\u0026lt;/span\u0026gt; */} {/* 正确示范: classNames 是一个函数， 需要在外层 {} 开启 jsx 语法 */} \u0026lt;span className={classNames( \u0026#39;arrow\u0026#39;, { \u0026#39;expand\u0026#39;: dateVisable })}\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; 1.3. 使用时间选择器事件关闭状态      使用 onConfirm 调用自定函数  关闭窗口 传递 时间值 为后续提供使用   使用 onCancel, onClose 关闭窗口  const Month = () =\u0026gt; { // 确定提交时间  const onConfirmDatePicker = (date) =\u0026gt; { setDateVisable(false) // setCurrentDate(date)  // console.log(date);  } return ( \u0026lt;\u0026gt; \u0026lt;DatePicker className=\u0026#34;kaDate\u0026#34; title=\u0026#34;记账日期\u0026#34; precision=\u0026#34;month\u0026#34; // visible={false} visible={dateVisable} max={new Date()} // 确认选择时间 onConfirm={(date) =\u0026gt; { onConfirmDatePicker(date) }} // 关闭或取消关闭时间选择器 onClose={() =\u0026gt; setDateVisable(false)} onCancel={() =\u0026gt; setDateVisable(false)} /\u0026gt; \u0026lt;/\u0026gt; ) } 2. 使用 dayjs 格式化时间      $ npm install dayjs 2.1. (方法一) 每个地方直接使用 dayjs 管理时间     这种代码不好在没有统一地方处理时间格式。 一旦格式需求变更，则需要每个地方修改。\nconst Month = () =\u0026gt; { // useState 的第二个参数是一个函数， 会在初始化的时候执行一次， 用于初始化 state  // useState 传入一个函数， 会在初始化的时候执行一次， 用于初始化 state  const [currentDate, setCurrentDate] = useState(() =\u0026gt; { return dayjs(new Date()).format(\u0026#39;YYYY-MM\u0026#39;) }) // 确定提交时间  const onConfirmDatePicker = (date) =\u0026gt; { setDateVisable(false) // 设置当前时间  // 1. 格式化当前时间 YYYY-MM, 并保存  const formatedDate = dayjs(date).format(\u0026#39;YYYY-MM\u0026#39;) setCurrentDate(formatedDate) } return ( \u0026lt;div className=\u0026#34;monthlyBill\u0026#34;\u0026gt; \u0026lt;span className=\u0026#34;text\u0026#34;\u0026gt; {currentDate} \u0026lt;/span\u0026gt; \u0026lt;/div \u0026gt; ) } 2.2. (方法二) 创建一个函数统一管理时间格式     // 创建函数统一管理时间格式 const formatedDate = (date) =\u0026gt; { if (!date) { date = new Date() } return dayjs(date).format(\u0026#39;YYYY-MM\u0026#39;) } const Month = () =\u0026gt; { const [currentDate, setCurrentDate] = useState(formatedDate()) // 确定提交时间  const onConfirmDatePicker = (date) =\u0026gt; { setDateVisable(false) // 设置当前时间  // 1. 格式化当前时间 YYYY-MM, 并保存  // const formatedDate = dayjs(date).format(\u0026#39;YYYY-MM\u0026#39;)  setCurrentDate(formatedDate(date)) } } 2.3. (方法三) 自定义 hook 完成时间选择和格式管理      特别注意:\n  自定义 hook 本身 无法接收参数。 即使定义了形参数，也永远是 undefined。 需要在 返回的函数上定义形参, 例如下例的 onConfirmDate(date)。  // \u0026#39;data\u0026#39; is declared but its value is never read. const useSelectedDate = (date) =\u0026gt; { // console.log(\u0026#34;typeof date =\u0026gt;\u0026#34;, typeof date); // undefined  // 这里才是真正接受参数的地方  const onConfirmDate = (date) =\u0026gt; { // console.log(\u0026#34;typeof date =\u0026gt;\u0026#34;, typeof date); // object  setSelectedDate(formatedDate(date)) } // 返回 onConfirmDate 接受参数并处理  return [selectedDate, onConfirmDate] } 节选代码参考如下。 完整代码在 /src/demos/AccountBook/src/components/Layout/Month/index.jsx 中。\nimport { useState } from \u0026#39;react\u0026#39; import dayjs from \u0026#39;dayjs\u0026#39; // 方法2. 创建函数统一管理时间格式 const formatedDate = (date) =\u0026gt; { if (!date) { date = new Date() } return dayjs(date).format(\u0026#39;YYYY-MM\u0026#39;) } // 方法3. 自定义 hook 函数管理时间格式和选择 // \u0026#39;data\u0026#39; is declared but its value is never read. const useSelectedDate = (date) =\u0026gt; { // 这 3行 的 date 没什么用, 一致是 undefined, 可以不用传  // console.log(\u0026#34;date input\u0026#34;, date);  // console.log(\u0026#34;typeof date =\u0026gt;\u0026#34;, typeof date);  // const [currentDate, setCurrentDate] = useState(formatedDate(date))  // step1. 定义初始值  const [selectedDate, setSelectedDate] = useState(formatedDate()) // step2. 调用 useState 的方法， 修改状态值  // 注意: 这里是返回出去的函数， 才是 **真正被调用时可传入参数** 的函数。  const onConfirmDate = (date) =\u0026gt; { // console.log(\u0026#34;date onConfirmDatePicker\u0026#34;, date);  // console.log(\u0026#34;typeof onConfirmDatePicker date =\u0026gt;\u0026#34;, typeof date);  setSelectedDate(formatedDate(date)) } // step3. 这里是返回出去的数组， 用于解构赋值  return [selectedDate, onConfirmDate] } const Month = () =\u0026gt; { // 默认关闭时间选择其  const [dateVisable, setDateVisable] = useState(false) // 方法3. 自定义 hook 函数管理时间格式和选择  const [currentDate, onConfirmDate] = useSelectedDate() // 确定提交时间  const onConfirmDatePicker = (date) =\u0026gt; { setDateVisable(false) // 方法3. 自定义 hook 函数  onConfirmDate(date) } return ( \u0026lt;div className=\u0026#34;monthlyBill\u0026#34;\u0026gt; \u0026lt;span className=\u0026#34;text\u0026#34;\u0026gt; {currentDate} \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ) } ","description":"1. 管理时间选择器状态      1.1. 使用 useState 管理时间选择器状态     const [dateVisable, setDateVisable] = useState(false) 1.2. 点击箭头展开时选择器      使用onClick 事件 打开时间选择器控件 使用 classNames 控制箭头显示状态  \u0026lt;div className=\u0026#34;date\u0026#34; // 打开时间选择器 onClick={() =\u0026gt; setDateVisable(true)}\u0026gt; {/* \u0026lt;span className=\u0026#39;arrow expand\u0026#39;\u0026gt;\u0026lt;/span\u0026gt; */} {/* 错误示范 */} {/* \u0026lt;span className=classNames={\u0026#39;arrow\u0026#39;, \u0026#39;expand\u0026#39;}\u0026gt;\u0026lt;/span\u0026gt; */} {/* 正确示范: classNames 是一个函数， 需要在外层 {} 开启 jsx 语法 */} \u0026lt;span className={classNames( \u0026#39;arrow\u0026#39;, { \u0026#39;expand\u0026#39;: dateVisable })}\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; 1."},{"id":11,"href":"/books/react/demos/account-book/date-picker-daily/","title":"07. 时间选择器 - 按日统计","parent":"3. Redux-Router 案例: 账本","content":" 本篇是 按日 统计消费数据， 其逻辑和上一篇 按月 是一样的。 根据 视频弹幕提示 ， 并没有完全按照视频的思路进行， 而是\n 使用了 自定义 Hook 使用 lodash 的 map, groupBy, orderBy 等方法整理数据。  1. 自定义组件逻辑     在视频中的组件是 Month 直接嵌套 DailyBill。 但是我觉得继续在 Month 中写代码造成文件臃肿且复杂。\n因此额外抽了一层 DailyBillEntry， 现在就成了 Month -\u0026gt; DailyBillEntry -\u0026gt; DailyBill。 其中\n DailyBillEntry 承上启下： 接受 Month 传下来的数据， 并调用 useDailyResults 计算出结果数据， 传递给 DailyBill DailyBill 依旧只负责展示结果。  2. 自定义 Hook: useDailyResults     在 /src/demos/AccountBook/src/components/Layout/Month/Daily/hooks.js 中\n注意:\n 自定义Hook 就是一个具有 调用特殊性 的 普通函数， 其本身 是可以接受参数的。 返回值 中的 函数也可以接受参数， 并修改 Hook 中的变量值。 （函数闭包）  import classNames from \u0026#39;classnames\u0026#39; import \u0026#39;./index.scss\u0026#39; import lodash from \u0026#39;lodash\u0026#39; import dayjs from \u0026#39;dayjs\u0026#39; const formatDailyDate = (date) =\u0026gt; { if (!date) { date = new Date() } return dayjs(date).format(\u0026#39;YYYY-MM-DD\u0026#39;) } const useDailyResults = (DailyBillList) =\u0026gt; { // console.log(\u0026#34;DailyBillList\u0026#34;, DailyBillList);  // (1) lodash map: 格式化日期  const r1 = lodash.map(DailyBillList, (item) =\u0026gt; { return { ...item, date: formatDailyDate(item.date) } }) // console.log(\u0026#34;r1\u0026#34;, r1);  // (2) lodash groupBy: 按格式化日期分组  const r2 = lodash.groupBy(r1, (item) =\u0026gt; { return item.date }) // (3) 创建数组保存计算结果  const dailyResults = [] // (3.1) 使用 forEach 遍历数组  lodash.forEach(r2, (value, key) =\u0026gt; { // (3.2) 使用 Array.reduce 计算  const ret = value?.reduce( (pre, cur) =\u0026gt; { if (cur.type === \u0026#34;pay\u0026#34;) { pre.pay += cur.money } if (cur.type === \u0026#34;income\u0026#34;) { pre.income += cur.money } pre.balance = pre.pay + pre.income // 必须要 return pre 下一次才能拿到 pre， 否则就是 undefined  return pre }, { pay: 0, income: 0, balance: 0, date: key, } ) dailyResults.push(ret) }) // (4) lodash orderBy: 按统计后的日期排序  return lodash.orderBy(dailyResults, [\u0026#39;date\u0026#39;], [\u0026#39;desc\u0026#39;]) } export default useDailyResults 2.1. 传入数据格式     首先确定 Month 传下来的数据格式如下。 一个包含了当月所有记录的 数组\n 2.2. 使用 lodash.map 整理数据时间格式     使用 lodash.map 遍历所有数据， 并修改时间格式\nconst formatDailyDate = (date) =\u0026gt; { if (!date) { date = new Date() } return dayjs(date).format(\u0026#39;YYYY-MM-DD\u0026#39;) } // (1) lodash map: 格式化日期 const r1 = lodash.map(DailyBillList, (item) =\u0026gt; { return { ...item, date: formatDailyDate(item.date) } }) 可以看到， 返回的结果中 时间已经被格式化了。\n 2.3. 使用 lodash.groupBy 分组数据     使用 lodash.groupBy 根据时间进行分组。\n// (2) lodash groupBy: 按格式化日期分组  const r2 = lodash.groupBy(r1, (item) =\u0026gt; { return item.date }) // console.log(\u0026#34;r2=\u0026gt;\u0026gt;\u0026#34;, r2); // object 可以看到， 这里返回的是一个 对象 而非 列表。 数据已经按照时间进行分组了， key 就是时间\n 2.4. 使用 lodash.forEach 计算结果      创建 dailyResults 数据保存计算结果 使用 lodash.forEach 遍历 对象， 其中  key 对应的时间 value 对应的是数组   使用 Array.reduce(x) 方法计算 result 数据  reduce 方法末尾必须返回 pre， 否则下一次循环的时候， pre 的值为 undefined   使用 Array.push(x) 方法将数据保存到 dailyResults 中。  // 创建 dailyResults 保存计算结果  const dailyResults = [] // 使用 forEach 遍历对象  lodash.forEach(r2, (value, key) =\u0026gt; { // console.log(\u0026#34;lodash foreach\u0026#34;);  // console.log(\u0026#34;value\u0026#34;, value);  // console.log(\u0026#34;key\u0026#34;, key);  const ret = value?.reduce( (pre, cur) =\u0026gt; { if (cur.type === \u0026#34;pay\u0026#34;) { pre.pay += cur.money } if (cur.type === \u0026#34;income\u0026#34;) { pre.income += cur.money } pre.balance = pre.pay + pre.income // 必须要 return pre 下一次才能拿到 pre， 否则就是 undefined  return pre }, { pay: 0, income: 0, balance: 0, date: key, } ) dailyResults.push(ret) 2.5. 使用 lodash.orderBy 排序结果     按照 时间 进行 倒序 排列\nconst ordered = lodash.orderBy(dailyResults, [\u0026#39;date\u0026#39;], [\u0026#39;desc\u0026#39;]) 3. 使用 useDailyResults      使用 import 导入 自定义Hook 使用 useMemo 缓存计算结果 将计算结果传递给下一个组件。  // (1) 导入 hook import useDailyResults from \u0026#39;./hooks\u0026#39; import { useMemo } from \u0026#39;react\u0026#39; const DailyBillEntry = ({ dailyBills }) =\u0026gt; { // (2) 使用 useMemo 缓存计算结果  const dailyResults = useMemo( () =\u0026gt; { return useDailyResults(dailyBills) }, [dailyBills] ) // (3) 将计算结果传递给课件中的 DailyBill  return ( \u0026lt;\u0026gt; { dailyResults.map((item, index) =\u0026gt; { return ( \u0026lt;DailyBill key={index} item={item} /\u0026gt; ) }) } \u0026lt;/\u0026gt; ) } export default DailyBillEntry 4. 单日项目展示       这里已经完全和 视频课件 上不同了。\n 由于增加 单日项目展示 的需求， 出现以下几个问题\n 之前给 DailyBill 仅传递了 统计结束数据， 不包含明细。 所以 无法 用于展示 项目明细 之前封装的 useDailyResults 过于封闭。 例如 格式化、分组 这些功能可以单独提出来。  4.1. 拆分封装函数并导出     // hooks.js const formatDailyBillByDate = (dailyBillList) =\u0026gt; { return lodash.map(dailyBillList, (item) =\u0026gt; { return { ...item, date: formatDailyDate(item.date) } }) } export { formatDailyBillByDate } const groupByDate = (dailyBillList) =\u0026gt; { return lodash.groupBy(dailyBillList, (item) =\u0026gt; { return item.date }) } export { groupByDate } 4.2. 使用 useMemo 缓存分组数据并向下传递     在 DailyBillEntry 中，\n 通过 useMemo 缓存 按日期分组的数据项目 使用 循环 统计数据时的 日期 为 key 获取 详细数据， 并向下传递。  const DailyBillEntry = ({ dailyBills }) =\u0026gt; { const groupDailyBill = useMemo( () =\u0026gt; { const r1 = formatDailyBillByDate(dailyBills) return groupByDate(r1) }, [dailyBills] ) return ( \u0026lt;\u0026gt; { dailyResults.map((item, index) =\u0026gt; { // 按日期获取分组的消费详情  const dailyBillList = groupDailyBill[item.date] return ( \u0026lt;DailyBill key={index} // 统计数据改命成 result result={item} // 向下传入消费数据 dailyBillList={dailyBillList} /\u0026gt; ) }) } \u0026lt;/\u0026gt; ) } 4.3. 封装 DailyItem 详细数据组件并展示数据     课件中给的是一个 div 片段，\n 简单封装一下就是一个新的组件 根据代码提示， 接收并解耦 参数 billList （单日详情）  // 单日列表, 消费详情 const BillItem = ({ billList }) =\u0026gt; { return ( //  \u0026lt;div className=\u0026#34;billList\u0026#34;\u0026gt; {billList.map(item =\u0026gt; { return ( \u0026lt;div className=\u0026#34;bill\u0026#34; key={item.id}\u0026gt; \u0026lt;div className=\u0026#34;detail\u0026#34;\u0026gt; {/* 注意这里不是函数 */} \u0026lt;div className=\u0026#34;billType\u0026#34;\u0026gt;{item.useFor}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className={classNames(\u0026#39;money\u0026#39;, item.type)}\u0026gt; {item.money.toFixed(2)} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) })} \u0026lt;/div\u0026gt; ) } 随后将 DailyItem 嵌入 到 DailyBill 中。 注意嵌入位置\n\u0026lt;div className={classNames(\u0026#39;dailyBill\u0026#39;)}\u0026gt; \u0026lt;div className=\u0026#34;header\u0026#34;\u0026gt; {/* 时间和箭头 */} \u0026lt;div className=\u0026#34;dateIcon\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; {/* 统计信息 */} \u0026lt;div className=\u0026#34;oneLineOverview\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; {/* 单日消费详情 */} \u0026lt;BillItem billList={dailyBillList} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 4.4. 映射 useFor 字段为中文      将课件提供的内容复制到 src/constants/index.js 中。 导入查找方法 billTypeToName 使用查找方法映射数据。 注意这里并不是一个函数， 而是一个对象  \u0026lt;div className=\u0026#34;billType\u0026#34;\u0026gt;{billTypeToName[item.useFor]}\u0026lt;/div\u0026gt; 4.5. 展开/收起详细数据      使用 useState 创建状态数据 itemVisiable 使用 classNames 管理 箭头 状态  根据显示状态切换上下箭头 新增点击事件切换显示状态    \u0026lt;span className={ // 根据显示状态切换上/下箭头  classNames( \u0026#39;arrow\u0026#39;, { \u0026#39;expand\u0026#39;: itemVisable } )} // 增加点击事件切换显示状态  onClick={() =\u0026gt; setItemVisable(!itemVisable)} \u0026gt;\u0026lt;/span\u0026gt; 根据显示状态切换 BillItem 的显示状态。  (1) 这里使用的是 逻辑运算符 实现的。\n{/* 自定义组件没有 display 属性 */} {/* \u0026lt;BillItem billList={dailyBillList} /\u0026gt; */} {itemVisable \u0026amp;\u0026amp; \u0026lt;BillItem billList={dailyBillList} /\u0026gt;} (2) 在课件案例中使用了 style 的 display 属性。\n由于我们是自己实现的组件， style display 无法生效。\n\u0026lt;BillItem billList={dailyBillList} style={{ display: itemVisable ? \u0026#39;block\u0026#39; : \u0026#39;none\u0026#39; }} /\u0026gt; 但是， 可以在外部包裹一层 \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; 实现\n{/* (2) 自定义组件没有 style display 字段*/} {/* 但是可以包裹一层 div 实现 */} \u0026lt;div style={{ display: itemVisable ? \u0026#39;block\u0026#39; : \u0026#39;none\u0026#39; }}\u0026gt; \u0026lt;BillItem billList={dailyBillList} /\u0026gt; \u0026lt;/div\u0026gt; 4.6. 增加 Icon 显示       创建 Icon 组件， 并使用 img 标签展示。  const Icon = ({ type }) =\u0026gt; { // 默认值  if (!type) { type = \u0026#39;food\u0026#39; } return ( \u0026lt;img src={`https://yjy-teach-oss.oss-cn-beijing.aliyuncs.com/reactbase/ka/${type}.svg`} alt=\u0026#34;icon\u0026#34; style={{ width: 20, height: 20, }} /\u0026gt; ) } export default Icon 在 BillItem 中合适的位置插入即可， 并传递 props 属性  \u0026lt;div className=\u0026#34;bill\u0026#34; key={item.id}\u0026gt; {/* 插入 Icon */} \u0026lt;Icon type={item.useFor} /\u0026gt; \u0026lt;div className=\u0026#34;detail\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ","description":"本篇是 按日 统计消费数据， 其逻辑和上一篇 按月 是一样的。 根据 视频弹幕提示 ， 并没有完全按照视频的思路进行， 而是\n 使用了 自定义 Hook 使用 lodash 的 map, groupBy, orderBy 等方法整理数据。  1. 自定义组件逻辑     在视频中的组件是 Month 直接嵌套 DailyBill。 但是我觉得继续在 Month 中写代码造成文件臃肿且复杂。\n因此额外抽了一层 DailyBillEntry， 现在就成了 Month -\u0026gt; DailyBillEntry -\u0026gt; DailyBill。 其中\n DailyBillEntry 承上启下： 接受 Month 传下来的数据， 并调用 useDailyResults 计算出结果数据， 传递给 DailyBill DailyBill 依旧只负责展示结果。  2. 自定义 Hook: useDailyResults     在 /src/demos/AccountBook/src/components/Layout/Month/Daily/hooks.js 中"},{"id":12,"href":"/books/react/demos/account-book/new-bill/","title":"08. 新增账单","parent":"3. Redux-Router 案例: 账本","content":"1. 界面分析       在新增账单界面上， (1) 有两种类型： 支出(pay) 和 收入(income)。 根据对应的选择， 会将数据传递到 (3) 的进行渲染。 此处不需要额外的路由配置。  1.1. 复制课件资料     复制课件资料的时候， 注意代码中使用了 路径别名 @。 如果发现报错，注意进行本地化替换。\n// import { billListData } from \u0026#39;@/contants\u0026#39; import { billListData } from \u0026#39;../../constants\u0026#39; 2. 收入支出状态切换      点击按钮切换装题啊 适配显示数据  2.1. 点击切换收入支出按钮      使用 useState 创建一个 selected 选中状态变量。 使用 classNames 在 收入/支出按钮 上绑定 selected 属性。  判断是否与 selected 值相同而启用   为 收入/支持按钮 增加 onClick 事件， 变更 selected 的值。  const New = () =\u0026gt; { // 1. 增加选中状态  const [selected, setSelected] = useState(\u0026#39;pay\u0026#39;) const navigate = useNavigate() return ( \u0026lt;div className=\u0026#34;keepAccounts\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;kaType\u0026#34;\u0026gt; \u0026lt;Button shape=\u0026#34;rounded\u0026#34; // 2. 判断是否选择 className={classNames({ \u0026#39;selected\u0026#39;: selected === \u0026#39;pay\u0026#39; })} // 3. 点击切换状态 onClick={() =\u0026gt; setSelected(\u0026#39;pay\u0026#39;)} \u0026gt; 支出 \u0026lt;/Button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) 2.2. 切换显示列表     由于所有消费类型都是保存在 billListData 中的，在其中已经完成了 pay/income 的分类。\nbillListData = { pay: [ // ...  ], income: [ // ...  ], } 因此在使用时， 通过 billListData['pay'] 获取对应类型的数据即可。\nimport { billListData } from \u0026#39;../../constants\u0026#39; \u0026lt;div className=\u0026#34;kaTypeList\u0026#34;\u0026gt; {/* 切换传入数据 */} {billListData[selected].map(item =\u0026gt; { return ( \u0026lt;div className=\u0026#34;kaType\u0026#34; key={item.type}\u0026gt; {/* 省略 ..*/} \u0026lt;/div\u0026gt; ) })} \u0026lt;/div\u0026gt; 3. 提交账单信息     3.1. 收集账单信息      money: input 框金额  const [money, setMoney] = useState(0) \u0026lt;Input className=\u0026#34;input\u0026#34; placeholder=\u0026#34;0.00\u0026#34; type=\u0026#34;number\u0026#34; value={money} onChange={(value) =\u0026gt; setMoney(value)} /\u0026gt; useFor: 操作类型 （打车、食物、酒水）  根据选中类型高亮显示 保存选中类型。    const [useFor, setUseFor] = useState(\u0026#39;food\u0026#39;) // 管理类型操作 \u0026lt;div className={classNames( \u0026#39;item\u0026#39;, // 2.1. 根据类型判断选中状态  { \u0026#39;selected\u0026#39;: useFor === item.type } )} key={item.type} // 2.2. 保存操作类型 onClick={() =\u0026gt; setUseFor(item.type)} \u0026gt; {/*省略...*/} \u0026lt;/div\u0026gt; selected: 操作类型 （收入、支出）。 之前已经处理了。 date: 操作时间。（先设置为当前时间）  3.2. 组合账单信息     // 1. 构造 bill 对象 const bill = { type: selected, date: new Date(), // 根据类型判断输入值的正负  money: selected === \u0026#39;pay\u0026#39; ? -money : +money, useFor: useFor, } 3.3. 提交新账单信息     3.3.1. 在 redux 中创建异步操作保存数据     在 /src/demos/AccountBook/src/store/modules/billStore/index.js 中创建\n 同步方法 addNewBill 将数据保存到 state 中。 异步方法 submitNewBill 将数据 post 到后端服务器。 并调用 addNewBill 将后端返回的数据保存。  import { createSlice } from \u0026#39;@reduxjs/toolkit\u0026#39; import axios from \u0026#39;axios\u0026#39; const billStore = createSlice({ reducers: { // 新增账单信息  addNewBill: (state, action) =\u0026gt; { state.billList.push(action.payload) } } }) // 创建异步任务， 提交一个新账单 const { addNewBill } = billStore.actions const submitNewBill = (newBill) =\u0026gt; { return async (dispatch) =\u0026gt; { // 1. 向服务器提交数据  const resp = await axios.post(\u0026#39;http://localhost:8888/ka\u0026#39;, newBill) // 2. 将服务器返回的结构提交到reducer  dispatch(addNewBill(resp.data)) } } // 3. 暴露异步方法 export { submitNewBill } 3.3.2. 使用 dispatch 调用异步方法提交数据     常规操作了。\n 使用 useDispatch 调用 submitNewBill 异步函数。 将组合好的 new bill 作为参数传递给 submitNewBill 函数。  import { submitNewBill } from \u0026#39;../../store/modules/billStore\u0026#39; import { useDispatch } from \u0026#39;react-redux\u0026#39; const New = () =\u0026gt; { const dispatch = useDispatch() // 提交账单， 调用 redux 更新 state  const onSubmitBill = () =\u0026gt; { // 1. 构造 bill 对象  const bill = { type: selected, date: new Date(), money: selected === \u0026#39;pay\u0026#39; ? -money : +money, useFor: useFor, } // 2. 使用 dispatch 调用 reducer 更新 state  dispatch(submitNewBill(bill)) } } 3.4. 保存账单后返回界面      之前点击 🧑‍✈️ 进入了 创建 页面。 因此在 保存 后需要返回 之前的路由界面 ，或者跳转到指定 路由界面， 以完成创建。  这里使用 navigate(-1) 返回 之前的界面\nimport { useNavigate } from \u0026#39;react-router-dom\u0026#39; const navigate = useNavigate() // 提交账单， 调用 redux 更新 state const onSubmitBill = () =\u0026gt; { // ...  // 3. 路由返回上一页  navigate(-1) } 3.5. 金额为空不能保存     使用 alert 提示 金额为 0 不能保存\n // 提交账单， 调用 redux 更新 state const onSubmitBill = () =\u0026gt; { // 1. 构造 bill 对象  const bill = { // ...  } // 金额为空不能提交，并使用弹窗提示  if (money === 0) { // https://mobile.ant.design/zh/components/dialog#dialogalert  alert({ content: \u0026#39;金额不能为空\u0026#39;, title: \u0026#39;请输入金额\u0026#39; }) return } } 4. 优化时间显示     4.1. 使用状态变量管理时间并优化展示      使用 useState 创建状态变量 date 使用 date.toLocaleDateString() 方法优化展示  // #134.1 使用状态变量管理时间 const [date, setDate] = useState(new Date()) // 2024/03/12 \u0026lt;span className=\u0026#34;text\u0026#34;\u0026gt;{date.toLocaleDateString()}\u0026lt;/span\u0026gt;  4.2. DatePicker 管理      使用 useState 创建变量保存 DatePicker 的显示状态。  通过 visible 属性管理 DatePicker 显示状态。 使用 onClick 事件打开 DatePicker。   创建 onDatePickerConfirm 函数处理时间选中后的一系列行为。 使用 onCancel, onClose 关闭 DatePicker  // #134.2 DatePicker 操作管理 const [showDatePicker, setShowDatePicker] = useState(false) const onDatePickerConfirm = (value) =\u0026gt; { // 隐藏 DatePicker  setShowDatePicker(false) // 更新时间  setDate(value) } \u0026lt;div className=\u0026#34;kaForm\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;date\u0026#34; // 1. 点击显示 DatePicker onClick={() =\u0026gt; setShowDatePicker(true)} \u0026gt; \u0026lt;Icon type=\u0026#34;calendar\u0026#34; className=\u0026#34;icon\u0026#34; /\u0026gt; \u0026lt;span className=\u0026#34;text\u0026#34;\u0026gt;{date.toLocaleDateString()}\u0026lt;/span\u0026gt; \u0026lt;DatePicker className=\u0026#34;kaDate\u0026#34; title=\u0026#34;记账日期\u0026#34; // 1. 管理 DatePicker 显示隐藏状态 visible={showDatePicker} max={new Date()} // 2. 确认操作 onConfirm={(value) =\u0026gt; { onDatePickerConfirm(value) }} // 3. 取消操作 onCancel={() =\u0026gt; setShowDatePicker(false)} onClose={() =\u0026gt; setShowDatePicker(false)} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ","description":"1. 界面分析       在新增账单界面上， (1) 有两种类型： 支出(pay) 和 收入(income)。 根据对应的选择， 会将数据传递到 (3) 的进行渲染。 此处不需要额外的路由配置。  1.1. 复制课件资料     复制课件资料的时候， 注意代码中使用了 路径别名 @。 如果发现报错，注意进行本地化替换。\n// import { billListData } from \u0026#39;@/contants\u0026#39; import { billListData } from \u0026#39;../../constants\u0026#39; 2. 收入支出状态切换      点击按钮切换装题啊 适配显示数据  2.1. 点击切换收入支出按钮      使用 useState 创建一个 selected 选中状态变量。 使用 classNames 在 收入/支出按钮 上绑定 selected 属性。  判断是否与 selected 值相同而启用   为 收入/支持按钮 增加 onClick 事件， 变更 selected 的值。  const New = () =\u0026gt; { // 1."},{"id":13,"href":"/books/react/demos/bili-comment/","title":"1. B站评论","parent":"99. 项目案例","content":"1. 安装 sass 支持     npm install sass 2. 评论     使用 useState 管理评论状态\nconst [BiliComments, setBiliComments] = useState(defaultList) 2.1 评论: 使用 Map() 方法渲染     { BiliComments.map( item =\u0026gt; \u0026lt;div className=\u0026#34;content-wrap\u0026#34; key={item.rpid}\u0026gt; // ...  \u0026lt;/div\u0026gt; ) } 2.2. 删除按钮： 条件渲染     {user.uid === item.user.uid \u0026amp;\u0026amp; \u0026lt;span\u0026gt;删除\u0026lt;/span\u0026gt;} 2.3. 删除事件: 点击效果     需要使用一个箭头函数， 实现 点击触发 的效果。\nfunction deleteComment(rpid) { setBiliComments(BiliComments.filter(item =\u0026gt; item.rpid !== rpid)) } \u0026lt;span className=\u0026#34;delete-btn\u0026#34; onClick={() =\u0026gt; deleteComment(item.rpid)} \u0026gt;删除\u0026lt;/span\u0026gt; 2.4. 更新评论: 使用 filter 实现数据删除     const newList = BiliComments.filter(item =\u0026gt; item.rpid !== rpid) setBiliComments(newList) 2.5 头像: 添加标签     使用 src 属性展示头像\n\u0026lt;div className=\u0026#34;bili-avatar\u0026#34;\u0026gt; \u0026lt;img className=\u0026#34;bili-avatar-img\u0026#34; alt=\u0026#34;\u0026#34; src={item.user.avatar} /\u0026gt; \u0026lt;/div\u0026gt; 3. 评论管理     3.1 使用 ClassName 标签高亮     首先， 使用 useState 管理所选择的排序标签。 hot 作为默认值。\n创建函数 activeClassName 管理标签状态， 与状态类型一致时， 返回 active 类。 所选择的 tab 整体作为参数传入（实际这里只需要类型即可）\nconst [activeType, setActiveType] = useState(\u0026#34;hot\u0026#34;) // 渲染 active 的 tag function activeClassName(tab) { // 三元表达式  // return item.type === activeType ? \u0026#39;nav-item active\u0026#39; : \u0026#39;nav-item\u0026#39;  // go 写法  if (tab.type === activeType) { return \u0026#39;nav-item active\u0026#39; } return \u0026#39;nav-item\u0026#39; } 注意: 上述 三元表达式 和 Go 写法 都是正确的。 都是分支流程控制， 使用 JS Switch 语法 - MDN Web Docs 也是可以的。\n其次， 使用 数组Array 的 map 方法生成所有标签。\n\u0026lt;li className=\u0026#34;nav-sort\u0026#34;\u0026gt; {/* 高亮类名： active */} {/* \u0026lt;span className=\u0026#39;nav-item\u0026#39;\u0026gt;最新\u0026lt;/span\u0026gt; */} {/* \u0026lt;span className=\u0026#39;nav-item active\u0026#39;\u0026gt;最火\u0026lt;/span\u0026gt; */} { tabs.map( (tab) =\u0026gt; \u0026lt;span key={tab.type} className={activeClassName(tab)} \u0026gt;{tab.text}\u0026lt;/span\u0026gt; ) } \u0026lt;/li\u0026gt; 注意: 在标签中\n 一定不要忘记 key 属性 className 属性是 React 语法， 小驼峰。 多个 className 值合并， 中间使用 空格 分割， 例如 nav-item active。  3.2 评论排序     这里使用了第三方库 lodash 进行数据处理。\n安装 lodash 库\nnpm install lodash 导入 lodash 库。 不太清楚 官方 和 黑马 视频为什么要使用 下划线_ 作为导入后的包名， 但我自己选择使用 lodash。\n// 官方 // var _ require(\u0026#39;lodash\u0026#39;);  // 黑马视频 // import _ from \u0026#39;lodash\u0026#39;;  // 我自己 import lodash from \u0026#39;lodash\u0026#39;; 首先， 定义函数 selectTag 作为选择 排序标签 的事件 回调函数。\n 这里使用了 switch 控制分支流程。 使用 switch 的时候， 一直要注意使用 break 退出， 否则会默认一直下坠，直到遇到 退出控制 或 结束。  这一点与 Go 不同， Go 是用户通过指定 fallthrough 手动下坠的。   由于 评论列表 是通过 useState 管理且 只读不可变， 因此不能直接使用 Array.sort() 进行排序， 使用的 lodash.orderBy 指定排序方法。  // 选择排序芳芳  function selectTab(tab) { setActiveType(tab.type) // tab.type === \u0026#34;hot\u0026#34; ?  // setBiliComments(lodash.orderBy(BiliComments, \u0026#39;like\u0026#39;, \u0026#39;desc\u0026#39;)) :  // setBiliComments(lodash.orderBy(BiliComments, \u0026#39;ctime\u0026#39;, \u0026#39;desc\u0026#39;))  switch (tab.type) { case \u0026#34;hot\u0026#34;: setBiliComments(lodash.orderBy(BiliComments, \u0026#39;like\u0026#39;, \u0026#39;desc\u0026#39;)); // 一定不能忘记这个 break。 否则  // 1. 不再判断 case condition 是否成立  // 2. 继续执行随后的所有 case statement， 直到退出。  break; default: setBiliComments(lodash.orderBy(BiliComments, [\u0026#39;ctime\u0026#39;], [\u0026#39;desc\u0026#39;])); } } 注意：\n lodash.orderBy() 是支持多条件排序的， 需要使用 两个数组 提供 优先级条件字段 以及 排序方式， 一一对应。 如果只有一个字段， 可以省略不使用数组。  最后， 使用 onClick 事件调用函数即可。\n注意 点击事件中 一定 要使用 箭头 函数封装， 以实现点击触发的效果， 否则就直接执行了。\n\u0026lt;span key={tab.type} className={activeClassName(tab)} // 1. 传入变量 // onClick={(item) =\u0026gt; selectTab(item)} onClick={() =\u0026gt; selectTab(tab)} \u0026gt;{tab.text}\u0026lt;/span\u0026gt; 3.2.1. classNames 类名控制     classnames 是一个第三方库， 用于方便的管理 className。\n如果说之前的两种方式是 手动拼接 类名是 手动挡 的话， 那么使用 classnames 就是自动挡。\n首先 使用 npm 安装\n$ npm install classnames 其次 使用 import 导入\nimport classNames from \u0026#39;classnames\u0026#39;; 最后 根据实际需求，返回 className\n// 渲染 active 的 tag  function activeClassName(tab) { // 1. 三元表达式  // return item.type === activeType ? \u0026#39;nav-item active\u0026#39; : \u0026#39;nav-item\u0026#39;  // 2. Go 写法  // if (tab.type === activeType) {  // return \u0026#39;nav-item active\u0026#39;  // }  // return \u0026#39;nav-item\u0026#39;  // 3. classnames 三方库。 前两种是手动拼接， 容易出错  return classNames(\u0026#34;nav-item\u0026#34;, { active: tab.type === activeType }) } 经过 classNames 对参数的处理后， 会将满足条件的所有参数 拼接 成 字符串。\n  (1) 为 静态 属性， 始终会返回。 (2,3) 为 动态 属性， 根据条件表达式结果返回。 (2) 是 属性名。 (3) 是 布尔表达式， 控制当前属性是否可用。 最终 classNames 返回的就是一个 空格 分割的字符串。  3.3. 添加评论     使用 useState 创建一个状态数据， 用于实现 input框 的数据双向绑定。\n// 添加评论 // 1. 获取评论内容 // 使用 useState 管理需要操作的数据 const [inputValue, setInputValue] = useState(\u0026#34;\u0026#34;) 使用 onChange 实现数据的双向绑定\n 使用 value={inputValue} 实现数据 从 State 到 UI 使用 onChange 实现数据 从 UI 到 State  {/* 评论框 */} \u0026lt;textarea className=\u0026#34;reply-box-textarea\u0026#34; placeholder=\u0026#34;发一条友善的评论\u0026#34; value={inputValue} onChange={(e) =\u0026gt; setInputValue(e.target.value)} /\u0026gt; 创建函数， 实现模拟数据的发布。  注意： 这里是函数内部， 使用 inputValue 就是内部变量。 就不再需要使用 {inputValue} 这种模版格式了。\nfunction postComment() { console.log(\u0026#39;postComment\u0026#39;); // 2. 构建评论对象  const newComment = { rpid: 1, user: { uid: \u0026#39;30009257\u0026#39;, avatar: \u0026#39;https://www.haoba.cc/logo\u0026#39;, uname: \u0026#39;黑马前端\u0026#39;, }, content: inputValue, ctime: \u0026#39;10-19 09:00\u0026#39;, like: 66, } // 3. 添加到评论列表  setCommentList([ ...commentList, newComment ]) } commentList 是 只读 的， 需要使用 ES 结构 语法。 ...commentList\n在发布按钮上绑定 onClick 事件， 调用 postComment 发布数据。  注意: 这里按钮对象实际上是两层（一层框， 一层文字）， 需要将 onClick 事件绑定到框上。\n{/* 发布按钮 */} \u0026lt;div className=\u0026#34;reply-box-send\u0026#34; onClick={postComment} \u0026gt; \u0026lt;div className=\u0026#34;send-text\u0026#34;\u0026gt;发布\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 4. 优化1: 使用 useEffect 从服务端获取数据     4.1. 模拟数据服务器      安装 json-server 模拟服务器。  $ npm install json-server 启动服务  数据在 /src/demos/bili-comments/json-server/db.json 中\n$ src/demos/bili-comments/json-server $ make # npx json-server db.json --port 9001 4.2. 使用 axios 请求服务器数据      安装 axios  $ npm install axios 清空 defaultList 或者留下一条 提示数据 依旧使用 useState 管理评论数据。 在使用 异步函数 和 axios 获取评论数据 依赖项 数据设置为空，只下载一次数据。 由于没有完成对应的评论提交功能。  const [commentList, setCommentList] = useState(defaultList) useEffect(() =\u0026gt; { // 定义异步获取函数  async function getComments() { await axios.get(\u0026#39;http://localhost:9001/comments\u0026#39;) .then(res =\u0026gt; { console.log(\u0026#39;res\u0026#39;, res); setCommentList(res.data) }).catch(err =\u0026gt; { console.log(\u0026#39;err\u0026#39;, err); }) } // 执行异步函数， 获取数据  getComments() }, // 由于没有完成 post 请求更新 json-server 发表评论逻辑。 因此设置  // 依赖项为空数组， 只会执行一次  // 无法真正更新数据。  [] ) 5. 优化2: 自定义 Hook 函数封装获取评论数据     这里的自定义 Hook 封装就比较简单了。\n 将 useState 和 useEffect 放在统一的自定义 Hook 中统一管理。 数据初始化好成功后， 已经将 commentList 和 setCommentList 返回给外部调用  // 自定义获取 Comments 的 Hook function useGetComments() { const [commentList, setCommentList] = useState(defaultList) useEffect(() =\u0026gt; { // 定义异步获取函数  async function getComments() { await axios.get(\u0026#39;http://localhost:9001/comments\u0026#39;) .then(res =\u0026gt; { console.log(\u0026#39;res\u0026#39;, res); setCommentList(res.data) }).catch(err =\u0026gt; { console.log(\u0026#39;err\u0026#39;, err); }) } // 获取数据  getComments() }, // 由于没有完成 post 请求更新 json-server 发表评论逻辑。 因此设置  // 依赖项为空数组， 只会执行一次  // 无法真正更新数据。  [] ) return [commentList, setCommentList] } 从外部使用来看， 从此不再关心数据是 defaultList 中的默认数据， 还是从 json-server 获取的远端数据。  const BiliComments = () =\u0026gt; { // 原本使用 useState 管理数据  // const [commentList, setCommentList] = useState(defaultList)  // ... 使用 useEffect 从远端获取评论数据  // 直接使用自定义 Hook 函数获取数据。 将 useState 和 useEffect 封装在再内  const [commentList, setCommentList] = useGetComments() // ... 其他使用方式不变。 } 6. 优化3: 封装评论项 Item 组件      抽象原则：\n 外部组件作为 智能组件 负责数据交互 Item 组件作为 UI 组件 负责数据渲染  6.1 定义 Item 组件     基本上， 就是直接结构全部复制过来。\nItem 和外部组件是一个典型的 父子解构。\n因此在定义 Item 的时候， 使用 解构赋值 获取 item 和 onDeleteComment 进行展示和操作数据。\n// 定义 Item 组件 // 使用 结构方法获取传递的 props 参数 function Item({ item, onDeleteComment }) { return ( \u0026lt;div className=\u0026#34;reply-item\u0026#34;\u0026gt; // ... 省略  {/* 判断渲染删除按钮 */} {user.uid === item.user.uid \u0026amp;\u0026amp; \u0026lt;span className=\u0026#34;delete-btn\u0026#34; onClick={() =\u0026gt; onDeleteComment(item.rpid)} \u0026gt;删除\u0026lt;/span\u0026gt;} // ... 省略  \u0026lt;/div\u0026gt; ) } 6.2 调用 Item 组件     在外部组件， 还是简单的使用 数组 的 map 方法便利内容。 将 item 数据传递给 Item 组件。\n注意: 这里提供 删除回调函数 的时候， 使用了 on前缀。 表示调用执行。\nconst BiliComments = () =\u0026gt; { const [commentList, setCommentList] = useGetComments() function deleteComment(rpid) { // ... 省略  } return ( \u0026lt;div className=\u0026#34;app\u0026#34; \u0026gt; {/* 评论列表 */} \u0026lt;div className=\u0026#34;reply-list\u0026#34;\u0026gt; {/* 评论项 */} {/* 使用 Item 组件 */} {commentList.map( item =\u0026gt; \u0026lt;Item key={item.rpid} // 定义唯一值 item={item} // 传递 item 数据 onDeleteComment={deleteComment} // 传递删除函数 /\u0026gt; )} \u0026lt;/div\u0026gt; \u0026lt;/div \u0026gt; ) } ","description":"1. 安装 sass 支持     npm install sass 2. 评论     使用 useState 管理评论状态\nconst [BiliComments, setBiliComments] = useState(defaultList) 2.1 评论: 使用 Map() 方法渲染     { BiliComments.map( item =\u0026gt; \u0026lt;div className=\u0026#34;content-wrap\u0026#34; key={item.rpid}\u0026gt; // ...  \u0026lt;/div\u0026gt; ) } 2.2. 删除按钮： 条件渲染     {user.uid === item.user.uid \u0026amp;\u0026amp; \u0026lt;span\u0026gt;删除\u0026lt;/span\u0026gt;} 2.3. 删除事件: 点击效果     需要使用一个箭头函数， 实现 点击触发 的效果。"},{"id":14,"href":"/books/react/javascript/loop/for/","title":"1. for","parent":"7. 循环/迭代","content":" for for\u0026hellip;in for\u0026hellip;of for await\u0026hellip;of  1. for     for 循环与 Golang 的使用方式一致。\nfor (initialization; condition; afterthought) { statement } 注意:\n 在定义变量的时候， 只能使用 let。 因为 const 是常量，不能被重新赋值。 在 (let i=1; y; z) 条件语句中定义的变量， 只能在 for 的 scope 中使用。  for (let i = 1; i \u0026lt;= 9; i++) { console.log(`${i}`); } // console.log(i); // i is not defined 1.1. 省略 for 条件     (x; y; z) 中的 x,y,z 可以 省略任意一个或多个\n此处省略了 变量初始化放在了 for 外部， 同时 i 的作用域也变大了。\nlet i = 0; for (; i \u0026lt; 3; i++) { console.log(i); // 1, 2, 3 } console.log(i) // 3 省略全部 条件和行为是， 循环语法 结构依旧要保留 (;;)。 这一点与 Golang 不一样。\n// js let i = 1 for (; ;) { console.log(i); // 1, 2, 3  i++; if (i \u0026gt;= 3) { break; } } // go // for { // statement // } 1.2. 省略 for body     The following for cycle calculates the offset position of a node in the afterthought section, and therefore it does not require the use of a statement section, a semicolon is used instead.\n省略 for body\n1.3. 嵌套 for     // 1. 九九乘法表 for (let i = 1; i \u0026lt;= 9; i++) { for (let j = 1; j \u0026lt;= i; j++) { console.log(`${j}* ${i}= ${j * i}`) } } 2. 查 index: for ... in     使用 for...in 语法查询 可迭代对象(ex, 数组, obj, map) 的 index 或 key。 类似 Golang 的 for k := range iterable {}\n注意 由于这里拿到的是 指针位置， 所以通过指针时可以操作原对象的。\n// js // for (let item in arr) { console.log(item); // 0,1,2,3,4  arr[item] += 10 } console.log(arr); // [11,12,13,14,15]  // go // // for k := range arr { // arr[k]+=10 // } 3. 查 value: for ... of     使用 for...in 语法查询 可迭代对象(ex, 数组, obj, map) 的 value。 类似 Golang 的 for _,v := range iterable {}\n注意: for...of 拿到的是 副本拷贝\n 如果是 简单对象 则修改 不影响 数据源  // js // const arr = [1, 2, 3, 4, 5]; for (let item of arr) { console.log(item); // 1,2,3,4,5  item += 10 } console.log(arr); // [1,2,3,4,5]  // go // // for _,v := range arr { // v+=10 // } 如果是 索引对象 则修改 可以影响数据源  for (let item of arr3) { if (item[\u0026#34;name\u0026#34;] === \u0026#34;Jerry\u0026#34;) { item[\u0026#34;age\u0026#34;] += 100 } } console.log(arr3); // ... {name: \u0026#39;Jerry\u0026#39;, age: 120 } ... 4. for await ... of     异步循环， 以后再说。\n","description":"for for\u0026hellip;in for\u0026hellip;of for await\u0026hellip;of  1. for     for 循环与 Golang 的使用方式一致。\nfor (initialization; condition; afterthought) { statement } 注意:\n 在定义变量的时候， 只能使用 let。 因为 const 是常量，不能被重新赋值。 在 (let i=1; y; z) 条件语句中定义的变量， 只能在 for 的 scope 中使用。  for (let i = 1; i \u0026lt;= 9; i++) { console.log(`${i}`); } // console.log(i); // i is not defined 1.1. 省略 for 条件     (x; y; z) 中的 x,y,z 可以 省略任意一个或多个"},{"id":15,"href":"/books/react/javascript/control-flow/if-else/","title":"1. if-else","parent":"6. 控制流/分支语句","content":"if\u0026hellip;else\nif...else 条件分支。\nconst a = 1, b = 2 if (a \u0026gt; b) { console.log(\u0026#39;a is less than b\u0026#39;) } else { console.log(\u0026#39;a is not greater than b\u0026#39;) } 2. else 分支可以省略     if (a \u0026lt; b) { console.log(\u0026#39;a is greater than b\u0026#39;) } 3. 多个分支条件     类似 switch\nconst c = 3 if (a \u0026gt; b) { console.log(\u0026#39;a is greater than b\u0026#39;) } else if (a \u0026lt; c) { console.log(\u0026#39;a is less than c\u0026#39;) } else { console.log(\u0026#39;a is not greater than b\u0026#39;) } 4. 嵌套 if...else     if (a \u0026lt; b) { console.log(\u0026#39;a is greater than b\u0026#39;) if (a \u0026lt; c) { console.log(\u0026#39;a is less than c\u0026#39;) } } 5. 并列条件     使用 逻辑运算符 多条件判断\nif (a \u0026lt; b \u0026amp;\u0026amp; a \u0026lt; c) { console.log(\u0026#39;a is less than b and c\u0026#39;) } ","description":"if\u0026hellip;else\nif...else 条件分支。\nconst a = 1, b = 2 if (a \u0026gt; b) { console.log(\u0026#39;a is less than b\u0026#39;) } else { console.log(\u0026#39;a is not greater than b\u0026#39;) } 2. else 分支可以省略     if (a \u0026lt; b) { console.log(\u0026#39;a is greater than b\u0026#39;) } 3. 多个分支条件     类似 switch\nconst c = 3 if (a \u0026gt; b) { console.log(\u0026#39;a is greater than b\u0026#39;) } else if (a \u0026lt; c) { console."},{"id":16,"href":"/books/react/react/jsx/","title":"1. jsx 基础用法","parent":"10. React","content":"","description":""},{"id":17,"href":"/books/react/react/jsx/introduce/","title":"1. jsx 的介绍","parent":"1. jsx 基础用法","content":"之前在 /src/App.js 中说到了 className 是 react 语法。 更准确的说是 JSX 语法。\n这是一个带有变量的例子\n// 定义 变量 const message = \u0026#34;this is a message\u0026#34; function App() { // return 中的内容是 jsx 语法  return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; // className 不是 HTML 语法  {message} // 使用变量  \u0026lt;/div\u0026gt; ); } 1. 什么是 jsx     jsx 是 js 的一种扩展语法， 继承了 js 和 xml 的优点。\n 可以使用 HTML 的声明式模版。 可以使用 js 的可编程能力。  由于 jsx 本身不是标准语法。 因此需要使用 Babel 进行编译后， 才能在 浏览器 上运行。 TypeScript同理， 也是需要编译成 js 后才能在浏览器上运行。\n 可以到 Babel 官网查看编译后的结果\n其他      Babel 官网: https://babeljs.io/repl  ","description":"之前在 /src/App.js 中说到了 className 是 react 语法。 更准确的说是 JSX 语法。\n这是一个带有变量的例子\n// 定义 变量 const message = \u0026#34;this is a message\u0026#34; function App() { // return 中的内容是 jsx 语法  return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; // className 不是 HTML 语法  {message} // 使用变量  \u0026lt;/div\u0026gt; ); } 1. 什么是 jsx     jsx 是 js 的一种扩展语法， 继承了 js 和 xml 的优点。\n 可以使用 HTML 的声明式模版。 可以使用 js 的可编程能力。  由于 jsx 本身不是标准语法。 因此需要使用 Babel 进行编译后， 才能在 浏览器 上运行。 TypeScript同理， 也是需要编译成 js 后才能在浏览器上运行。"},{"id":18,"href":"/books/react/javascript/data-types/number/number-nan/","title":"1. NaN","parent":"1. 数字","content":"2. 特殊数字 NaN      反正: 用之前， 最好先测试一下\n  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN\n  NaN 表示 Not a number。 NaN 是数字类型。  可以符合逻辑的想法:\n 任何 数字 相关的操作， 如果 执行错误，则返回 NaN  但是也有很多不符合逻辑的 例外:\n 字符串 -\u0026gt; 数字 有 隐式 转换。  // 数字函数处理 **数字行字符串** // parseInt: console.log(parseInt(10)); // 10 console.log(parseInt(\u0026#34;10.5\u0026#34;)); // 10 console.log(parseFloat(\u0026#34;10.5\u0026#34;)); // 10.5 console.log(parseInt(\u0026#34;10.5abc\u0026#34;)); // 10 console.log(parseInt(\u0026#34;abc10.5\u0026#34;)); // NaN  // Number 类型转换字符串 console.log(Number(\u0026#34;10.5abc\u0026#34;)); // NaN console.log(Number(\u0026#34;abc10.5\u0026#34;)); // NaN 任何 NaN 相关 运算和操作  NaN 的 数学运算 是 NaN NaN 的 大小比较运算(\u0026gt;, \u0026lt;, \u0026gt;=, \u0026lt;=)* 结果是 false NaN 通过 (==, !=, ===, and !==) 与其他 任何值，包括 NaN 本身， 进行比较。 等于运算 结果是 NaN=    更多案例参考 /javascript/data-types/number.js\n// NaN 数学运算 console.log(10 + NaN); // NaN console.log(Math.abs(NaN)); // NaN  // NaN 大小判断 console.log(NaN \u0026gt; 10); // false console.log(NaN \u0026lt;= 10); // false console.log(NaN \u0026gt; NaN); // false console.log(NaN \u0026lt;= NaN); // false  // 使用 == / === 的判断 console.log(NaN == NaN); // false console.log(NaN != NaN); // true console.log(NaN === 10); // false console.log(NaN !== 10); // true 但是 NaN 使用 Object.is 判断\n// NaN compare console.log(NaN === NaN); // false console.log(Object.is(NaN, NaN)); // true 更多执行结果合集     // NaN // 在现代浏览器中，NaN 是不可配置、不可写的属性。 即使情况并非如此，也请避免覆盖它。 console.log(1 / 0); // Infinity  // NaN conculate console.log(NaN + 10); // NaN console.log(NaN * 10); // NaN console.log(NaN === NaN); // false console.log(isNaN(NaN)); // true  // parseInt, but string conver to string console.log(parseInt(10)); // 10 console.log(parseInt(\u0026#34;10.5\u0026#34;)); // 10 console.log(parseFloat(\u0026#34;10.5\u0026#34;)); // 10.5 console.log(parseInt(\u0026#34;10.5abc\u0026#34;)); // 10  // parseInt string console.log(parseInt(\u0026#34;abc10.5\u0026#34;)); // NaN console.log(Number(\u0026#34;10.5abc\u0026#34;)); // NaN console.log(Number(\u0026#34;abc10.5\u0026#34;)); // NaN  // other type console.log(Math.abs(undefined)); // NaN console.log(Number(null)); // 0 console.log(Number(undefined)); // NaN console.log(Number(true)); // 1  // Number(x) console.log(Number(\u0026#39;\u0026#39;)); // 0 console.log(Number(\u0026#39; \u0026#39;)); // 0 console.log(Number(\u0026#39; 10 \u0026#39;)); // 10 console.log(Number(\u0026#39;10.5\u0026#39;)); // 10.5 console.log(Number(\u0026#39;10.5abc\u0026#39;)); // NaN  // Number Array and object, empty and not empty console.log(Number([])); // 0 console.log(Number([1])); // 1  console.log(Number({})); // NaN console.log(Number({ a: 1 })); // NaN  // Number x Infinity console.log(0 * Infinity); // NaN console.log(0 * -Infinity); // NaN console.log(Infinity / Infinity); // NaN  // isNan(x) console.log(isNaN(10)); // false console.log(isNaN(\u0026#34;10\u0026#34;)); // false console.log(isNaN(\u0026#34;a\u0026#34;)); // true console.log(isNaN(NaN)); // true  console.log(Number.isNaN(NaN)); // true console.log(Number.isNaN(10)); // false console.log(Number.isNaN(\u0026#34;10\u0026#34;)); // false console.log(Number.isNaN(\u0026#34;a\u0026#34;)); // false  // NaN mathematical operation console.log(10 + NaN); // NaN console.log(10 * NaN); // NaN console.log(Math.abs(NaN)); // NaN  // NaN compare console.log(NaN === NaN); // false console.log(Object.is(NaN, NaN)); // true  // NaN big or small console.log(NaN \u0026gt; 10); // false console.log(NaN \u0026lt; 10); // false console.log(NaN \u0026gt;= 10); // false console.log(NaN \u0026lt;= 10); // false console.log(NaN \u0026gt; NaN); // false console.log(NaN \u0026lt; NaN); // false console.log(NaN \u0026gt;= NaN); // false console.log(NaN \u0026lt;= NaN); // false  // NaN compares unequal (via ==, !=, ===, and !==) to any other value — including to another NaN value. console.log(NaN == NaN); // false console.log(NaN != NaN); // true console.log(NaN === NaN); // false console.log(NaN !== NaN); // true console.log(NaN == 10); // false console.log(NaN === 10); // false console.log(NaN != 10); // true console.log(NaN !== 10); // true ","description":"2. 特殊数字 NaN      反正: 用之前， 最好先测试一下\n  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN\n  NaN 表示 Not a number。 NaN 是数字类型。  可以符合逻辑的想法:\n 任何 数字 相关的操作， 如果 执行错误，则返回 NaN  但是也有很多不符合逻辑的 例外:\n 字符串 -\u0026gt; 数字 有 隐式 转换。  // 数字函数处理 **数字行字符串** // parseInt: console.log(parseInt(10)); // 10 console.log(parseInt(\u0026#34;10.5\u0026#34;)); // 10 console.log(parseFloat(\u0026#34;10.5\u0026#34;)); // 10.5 console.log(parseInt(\u0026#34;10.5abc\u0026#34;)); // 10 console.log(parseInt(\u0026#34;abc10.5\u0026#34;)); // NaN  // Number 类型转换字符串 console.log(Number(\u0026#34;10.5abc\u0026#34;)); // NaN console."},{"id":19,"href":"/books/react/setup/initalize/npx/","title":"1. npx 初始化项目","parent":"0. 初始化项目","content":"2. 创建项目     npx create-react-app react-basic  npx 是 node.js 的工具命令， 查找并执行后续包命令。 create-react-app 是 核心包（固定写法）， 用于创建 react 项目 react-basic 是 react 项目名称， 可以自定义。  3. 项目配置     ## 启动命令 npm start ## 编译命令 npm run build # 注意这个 run 用不用都可以 可以在 package.json 中看到核心组建与启动命令\n// 依赖组建 \u0026quot;dependencies\u0026quot;: { \u0026quot;@testing-library/jest-dom\u0026quot;: \u0026quot;^5.17.0\u0026quot;, \u0026quot;@testing-library/react\u0026quot;: \u0026quot;^13.4.0\u0026quot;, \u0026quot;@testing-library/user-event\u0026quot;: \u0026quot;^13.5.0\u0026quot;, \u0026quot;react\u0026quot;: \u0026quot;^18.2.0\u0026quot;, \u0026quot;react-dom\u0026quot;: \u0026quot;^18.2.0\u0026quot;, \u0026quot;react-scripts\u0026quot;: \u0026quot;5.0.1\u0026quot;, \u0026quot;web-vitals\u0026quot;: \u0026quot;^2.1.4\u0026quot; }, // 启动命令 \u0026quot;scripts\u0026quot;: { \u0026quot;start\u0026quot;: \u0026quot;react-scripts start\u0026quot;, \u0026quot;build\u0026quot;: \u0026quot;react-scripts build\u0026quot;, \u0026quot;test\u0026quot;: \u0026quot;react-scripts test\u0026quot;, \u0026quot;eject\u0026quot;: \u0026quot;react-scripts eject\u0026quot; }, 4. 清理文件     /src 是代码目录， 清理暂时不用的文件， 留下核心\n4.1. 删除文件     删除除了 index.js, App.js 以外的文件。\n此时， 需要在 index.js 和 App.js 中删除引用\ninjex.js\nimport React from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom/client\u0026#39;; // import \u0026#39;./index.css\u0026#39;; import App from \u0026#39;./App\u0026#39;; // import reportWebVitals from \u0026#39;./reportWebVitals\u0026#39;; App.js, 删除引用文件， 并修改返回内容。\n// import logo from \u0026#39;./logo.svg\u0026#39;; // import \u0026#39;./App.css\u0026#39;;  function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; this is my app \u0026lt;/div\u0026gt; ); } export default App; 4.2. 关闭严格模式     在 index.js 中，注释 StrictMode\nconst root = ReactDOM.createRoot(document.getElementById(\u0026#39;root\u0026#39;)); root.render( // \u0026lt;React.StrictMode\u0026gt;  \u0026lt;App /\u0026gt; // \u0026lt;/React.StrictMode\u0026gt; ); 4.3. 关闭性能监控     在 index.js 中注释 reportWebVitals() 关闭性能监控\n// // If you want to start measuring performance in your app, pass a function // // to log results (for example: reportWebVitals(console.log)) // // or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals // reportWebVitals(); 5. 说明     5.1. DOM 初始化     在 index.js 中,\n 通过 React.createRoot 创建了一个 DOM。 并通过 document.getElementById('root') 绑定到了 public/index.html 中的 root 节点上上。  // 这个 root 节点在 public/index.html 中定义。 const root = ReactDOM.createRoot(document.getElementById(\u0026#39;root\u0026#39;)); root.render( // \u0026lt;React.StrictMode\u0026gt;  \u0026lt;App /\u0026gt; // \u0026lt;/React.StrictMode\u0026gt; ); 5.2. 组件     在 App.js 中\n// App -引入-\u0026gt; index.js -渲染-\u0026gt; index.html function App() { return ( // return 出去  \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; this is my app \u0026lt;/div\u0026gt; ); }  组件的渲染流程大概如下: App -引入-\u0026gt; index.js -渲染-\u0026gt; index.html 所有组件中都有一个 return 将结果丢给 React. 注意 \u0026lt;className=\u0026quot;App\u0026quot;\u0026gt; 不是 index 语法了， 而是 react 语法了。  其他      中文官网： https://zh-hans.react.dev/learn/start-a-new-react-project B站视频： https://www.bilibili.com/video/BV1ZB4y1Z7o8?p=3\u0026amp;vd_source=0259bb47833cfe6d7c4749c69a49a9d2  ","description":"2. 创建项目     npx create-react-app react-basic  npx 是 node.js 的工具命令， 查找并执行后续包命令。 create-react-app 是 核心包（固定写法）， 用于创建 react 项目 react-basic 是 react 项目名称， 可以自定义。  3. 项目配置     ## 启动命令 npm start ## 编译命令 npm run build # 注意这个 run 用不用都可以 可以在 package.json 中看到核心组建与启动命令\n// 依赖组建 \u0026quot;dependencies\u0026quot;: { \u0026quot;@testing-library/jest-dom\u0026quot;: \u0026quot;^5.17.0\u0026quot;, \u0026quot;@testing-library/react\u0026quot;: \u0026quot;^13.4.0\u0026quot;, \u0026quot;@testing-library/user-event\u0026quot;: \u0026quot;^13.5.0\u0026quot;, \u0026quot;react\u0026quot;: \u0026quot;^18.2.0\u0026quot;, \u0026quot;react-dom\u0026quot;: \u0026quot;^18.2.0\u0026quot;, \u0026quot;react-scripts\u0026quot;: \u0026quot;5.0.1\u0026quot;, \u0026quot;web-vitals\u0026quot;: \u0026quot;^2.1.4\u0026quot; }, // 启动命令 \u0026quot;scripts\u0026quot;: { \u0026quot;start\u0026quot;: \u0026quot;react-scripts start\u0026quot;, \u0026quot;build\u0026quot;: \u0026quot;react-scripts build\u0026quot;, \u0026quot;test\u0026quot;: \u0026quot;react-scripts test\u0026quot;, \u0026quot;eject\u0026quot;: \u0026quot;react-scripts eject\u0026quot; }, 4."},{"id":20,"href":"/books/react/javascript/data-types/number/number/","title":"1. Number","parent":"1. 数字","content":"1. 数字     JavaScript 只有 一种 数字类型： number。\n不分 正数(int), 浮点数(float)\n数字类型可以进行 四则运算。 优先级 左右相同， 上下递减\n *, / 和 % 求模（余数） +, -  Js 的 % 与其他语言不同， 不会舍弃 小数。\nconsole.log(0.4 / 1); // 0.4 console.log(11.5 % 4); // 3.5 圆括号 具有最高优先级。 即可以改变优先级\nconsole.log(5 / 2 + 3); // 5.5 console.log(5 / (2 + 3)); // 1 2. 特殊数字 NaN      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN\n  NaN 表示 Not a number。 NaN 是数字类型。   难点在于 隐式转换: 更多参考 特殊数字 NaN\n 可以符合逻辑的想法:\n 任何 数字 相关的操作， 如果 执行错误，则返回 NaN  但是也有很多不符合逻辑的 例外:\n 字符串 -\u0026gt; 数字 有 隐式 转换。 任何 NaN 相关 运算和操作  NaN 的 数学运算 是 NaN NaN 的 大小比较运算(\u0026gt;, \u0026lt;, \u0026gt;=, \u0026lt;=)* 结果是 false NaN 通过 (==, !=, ===, and !==) 与其他 任何值，包括 NaN 本身， 进行比较。 等于运算 结果是 NaN=    3. 小数精度问题     Js 中的小数精度问题\nconsole.log(0.8 % 0.5); // 0.30000000000000004 {{ }}\n","description":"1. 数字     JavaScript 只有 一种 数字类型： number。\n不分 正数(int), 浮点数(float)\n数字类型可以进行 四则运算。 优先级 左右相同， 上下递减\n *, / 和 % 求模（余数） +, -  Js 的 % 与其他语言不同， 不会舍弃 小数。\nconsole.log(0.4 / 1); // 0.4 console.log(11.5 % 4); // 3.5 圆括号 具有最高优先级。 即可以改变优先级\nconsole.log(5 / 2 + 3); // 5.5 console.log(5 / (2 + 3)); // 1 2. 特殊数字 NaN      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN"},{"id":21,"href":"/books/react/react/events/on-click/","title":"1. onClick 点击事件","parent":"2. 事件绑定","content":" 事件名称统一为 onXXXX Hanlder 函数支持多种方式定义， 变量形式 与 函数形式  // 不接受参数 // 变量形式 const handler1 = () =\u0026gt; { console.log(count); count = count + 1 } // 接收事件 // 函数形式 function handler2(event) { console.log(event) // count = count + 2 } 这里是是 onClick 点击事件。\n1. 不接受参数     这种最简单， 只需要在 标签 中的 属性 中， 使用 onClick 事件时 指定 调用 handler 函数 即可。\n\u0026lt;button onClick={handler1}\u0026gt;button +1\u0026lt;/button\u0026gt; 如上， 是在 button 中接收了的 onClick 事件。 注意\n 需要使用 花括号{} 开启 jsx 执行函数(表达式)。 handler 函数 不需要被执行， 即没有跟 园括号。  function EventOnClick() { let count = 0 // 不接受参数  // 变量形式  const handler1 = () =\u0026gt; { console.log(count); count = count + 1 } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count={count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handler1}\u0026gt;button +1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default EventOnClick; 2. 接收事件参数     在事件触发是， React 是 默认 传递 事件参数 的，\n handler 函数只需要准备好 形参 接收即可。 在调用时 不需要 额外手工参数 实参。  这一点与 传递自定义参数 不同， 可以对比接下来的 第 3 点。\nfunction EventOnClick() { let count = 0 // 接收事件  // 函数形式  function handler2(event) { console.log(event) // count = count + 2  } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count={count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handler2}\u0026gt;button e\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default EventOnClick; 3. 接收自定义参数     其实就是在普通的 handler 函数的基础上， 在 调用 的时候使用 箭头 函数封装了一次。\n// 调用 onClick={() =\u0026gt; { handler3(count) }} 这里你可以看到有连个 花括号\n 外层： 是启用 jsx 的语法。 内层： 箭头函数的函数体边界。 其实这里也可以省略成以下形式  // 调用 onClick={() =\u0026gt; handler3(count) } 完整代码如下\nfunction EventOnClick() { let count = 0 // 接受参数  function handler3(n) { console.log(n); count = count + 3 } // 接受参数和事件  const handler4 = (n, event) =\u0026gt; { console.log(n, event); count = count + 4 } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count={count}\u0026lt;/p\u0026gt; {/* 注意这里是箭头函数 */} \u0026lt;button onClick={() =\u0026gt; { handler3(count) }}\u0026gt;button(+3)\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; handler3(count) }\u0026gt;button(+3)\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default EventOnClick; 4. 接收自定义参数与事件参数     同时接收 自定义参数 和 事件参数： 其实也很简单， 就是在上一个的技术上， 通过 箭头 函数获取了 事件参数， 再传给了 handler 函数。 可以说是 2,3 的结合体。\n注意： 在传递参数时， 需要注意参数的位置。\nfunction EventOnClick() { let count = 0 // 接受参数和事件  const handler4 = (n, event) =\u0026gt; { console.log(n, event); count = count + 4 } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count={count}\u0026lt;/p\u0026gt; {/* 1. 箭头函数， 2 参数位置 */} \u0026lt;button onClick={(event) =\u0026gt; { handler4(count, event) }}\u0026gt;button(+4,e)\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default EventOnClick; 其他      Event handlers - React Learn  ","description":"事件名称统一为 onXXXX Hanlder 函数支持多种方式定义， 变量形式 与 函数形式  // 不接受参数 // 变量形式 const handler1 = () =\u0026gt; { console.log(count); count = count + 1 } // 接收事件 // 函数形式 function handler2(event) { console.log(event) // count = count + 2 } 这里是是 onClick 点击事件。\n1. 不接受参数     这种最简单， 只需要在 标签 中的 属性 中， 使用 onClick 事件时 指定 调用 handler 函数 即可。\n\u0026lt;button onClick={handler1}\u0026gt;button +1\u0026lt;/button\u0026gt; 如上， 是在 button 中接收了的 onClick 事件。 注意"},{"id":22,"href":"/books/react/react/communication/props/","title":"1. props 通信","parent":"5. 组件通信","content":"","description":""},{"id":23,"href":"/books/react/react/communication/redux/counter-demo/","title":"1. Redux计数器（纯网页版）","parent":"3. redux","content":"在不使用 React 框架的情况下。 仅使用 Redux 实现一个计数器功能。\n 使用步骤      定义一个 reducer 函数。 （根据当前想要做的修改返回一个心的状态） 使用 createStore 方法传入 reducer， 生成一个 store 实例对象 使用 store 实例的 subscribe 方法 订阅数据变化。 （数据一旦变化， 可以得到通知） 使用 store 实例的 dispatch 方法提交 action 对象 触发数据变化。 （告诉 reducer 所需要执行的操作） 使用 store 实例 getState 方法 获取最新的状态数据， 并更新到试图中。  注意： Redux 不会主动更新视图， 需要主动调用 document DOM 绑定数据。\n示例代码     本案例中使用 redux@4.2.1， 最新版本 5.0.x API 有新变化， 页面代码不兼容。 （2024-02-18）\n在 /src/components/communication/redux/redux.html 中。\n注意: 在导入外部 redux.js 是时候 注意下载地址。 不要使用成了富文本网页。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 展示界面 --\u0026gt; \u0026lt;button id=\u0026#34;decrement\u0026#34;\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;span id=\u0026#34;counter\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;button id=\u0026#34;increment\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;!-- 导入外部 redux --\u0026gt; \u0026lt;!-- 网页地址, 非 RAW : https://unpkg.com/browse/redux@5.0.1/dist/redux.d.ts --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;https://unpkg.com/redux@4.2.1/dist/redux.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 手写 redux 控制 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; // 1. 创建 reducer  // 作用： 根据不同的 action 修改 state 状态  // state: 管理当前数据的初始化状态  // action: 对象。 通过 type 属性来判断执行的操作  function reducer(state = { count: 0 }, action) { if (action.type === \u0026#39;INCREMENT\u0026#39;) { return { count: state.count + 1 } } if (action.type === \u0026#39;DECREMENT\u0026#39;) { return { count: state.count - 1 } } } // 2. 使用 reducer 创建 store  // 使用 redux 提供的 createStore 方法创建 store  // 这里必须使用 `Redux.createStore`， 直接使用 createStore 报错。  const store = Redux.createStore(reducer) // 3. 使用 dispatch 修改 state 状态  const inBtn = document.getElementById(\u0026#39;increment\u0026#39;) inBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 增加  store.dispatch({ type: \u0026#39;INCREMENT\u0026#39; }) }) const deBtn = document.getElementById(\u0026#39;decrement\u0026#39;) deBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 减少  store.dispatch({ type: \u0026#39;DECREMENT\u0026#39; }) }) // 4. 使用 subscribe 订阅 store  store.subscribe(() =\u0026gt; { console.log(\u0026#39;state 更新了\u0026#39;); // 5. 使用 getState 获取最新的 state 状态更新到视图  // 获取最新的 state  const state = store.getState() // 更新界面  document.getElementById(\u0026#39;counter\u0026#39;).innerText = state.count }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","description":"在不使用 React 框架的情况下。 仅使用 Redux 实现一个计数器功能。\n 使用步骤      定义一个 reducer 函数。 （根据当前想要做的修改返回一个心的状态） 使用 createStore 方法传入 reducer， 生成一个 store 实例对象 使用 store 实例的 subscribe 方法 订阅数据变化。 （数据一旦变化， 可以得到通知） 使用 store 实例的 dispatch 方法提交 action 对象 触发数据变化。 （告诉 reducer 所需要执行的操作） 使用 store 实例 getState 方法 获取最新的状态数据， 并更新到试图中。  注意： Redux 不会主动更新视图， 需要主动调用 document DOM 绑定数据。\n示例代码     本案例中使用 redux@4.2.1， 最新版本 5.0.x API 有新变化， 页面代码不兼容。 （2024-02-18）"},{"id":24,"href":"/books/react/react/react19/use/","title":"1. use 替代 useEffect","parent":"10. React 19 支持","content":"替代 useEffect      https://react.dev/reference/react/use#streaming-data-from-server-to-client\n 定义函数，从服务器获取资源\ntype MovieType = { title: string } // 获取资源，返回 Promise async function fetchMovie() { const resp = await axios.get\u0026lt;MovieType[]\u0026gt;(\u0026#34;http://localhost:8080/\u0026#34;) return resp.data[0] } useEffect 版本     export default function MovieUseEffectContainer() { // 使用 useState 管理数据状态  const [movie, setMovie] = useState\u0026lt;MovieType | undefined\u0026gt;(undefined) // 使用 useEffect 获取资源  useEffect(() =\u0026gt; { fetchMovie().then(setMovie) }, []) return ( \u0026lt;div\u0026gt; \u0026lt;Suspense fallback={\u0026lt;h2\u0026gt;MovieUseEffect, Loading ...\u0026lt;/h2\u0026gt;}\u0026gt; \u0026lt;h1\u0026gt;{movie?.title}\u0026lt;/h1\u0026gt; \u0026lt;/Suspense\u0026gt; \u0026lt;/div\u0026gt; ) } use 版本     import axios from \u0026#39;axios\u0026#39; import { Suspense, use } from \u0026#39;react\u0026#39; // 对外组件 export default function MovieContainer() { // // 调用函数获取值  // const movie = fetchMovie()  return ( \u0026lt;div\u0026gt; \u0026lt;Suspense\u0026gt; // \u0026lt;Movie moviePromise={movie} /\u0026gt;  \u0026lt;Movie moviePromise={fetchMovie()} /\u0026gt; \u0026lt;/Suspense\u0026gt; \u0026lt;/div\u0026gt; ) } // 使用 use 获取值 type MovieProps = { moviePromise: Promise\u0026lt;MovieType\u0026gt; } // 需要传递一个 PromiseLike 的值， 才能使用 use 获取值 function Movie({ moviePromise }: MovieProps) { const movie = use(moviePromise) return \u0026lt;h1\u0026gt;{movie.title}\u0026lt;/h1\u0026gt; } 不能舍弃的 moviePromise     从上可以看到， 虽然舍弃了 useEffect, 但是还多创建了一个 Movie 组件管理 moviePromise 的状态。\n !! 能不能使用 多一层的 Movie 组件？\n // 不使用 Movie Promise 组件。 export default function MovieContainer() { // // 调用函数获取值  const moviePromise = fetchMovie() const movie = use(moviePromise) return ( \u0026lt;div\u0026gt; \u0026lt;Suspense\u0026gt; \u0026lt;h1\u0026gt;{movie.title}\u0026lt;/h1\u0026gt; \u0026lt;/Suspense\u0026gt; \u0026lt;/div\u0026gt; ) } 这样是有问题的， 结果表现为 网络一直重复请求！！\n为什么会无限循环？      根据 ChatGPT 的解释为: 直接调用函数会导致 每次渲染都创建新的 Promise，形成无限循环。\n  use() 需要传入 一个已挂起的 Promise ，而不是一个每次调用都会返回新 Promise 的函数。 你在 use(fetchMoive()) 里直接调用了 fetchMoive()，这会在每次渲染时创建一个新的 Promise。 React 发现 use() 里传入的是一个新的 Promise ，它会重新开始 Suspense 处理，并重新渲染组件，这样就形成了无限循环。  ","description":"替代 useEffect      https://react.dev/reference/react/use#streaming-data-from-server-to-client\n 定义函数，从服务器获取资源\ntype MovieType = { title: string } // 获取资源，返回 Promise async function fetchMovie() { const resp = await axios.get\u0026lt;MovieType[]\u0026gt;(\u0026#34;http://localhost:8080/\u0026#34;) return resp.data[0] } useEffect 版本     export default function MovieUseEffectContainer() { // 使用 useState 管理数据状态  const [movie, setMovie] = useState\u0026lt;MovieType | undefined\u0026gt;(undefined) // 使用 useEffect 获取资源  useEffect(() =\u0026gt; { fetchMovie().then(setMovie) }, []) return ( \u0026lt;div\u0026gt; \u0026lt;Suspense fallback={\u0026lt;h2\u0026gt;MovieUseEffect, Loading ."},{"id":25,"href":"/books/react/react/communication/zustand/zustand/","title":"1. Zustand 安装与使用","parent":"4. zustand","content":"1. Zustand 安装      官网: https://zustand-demo.pmnd.rs/ Github: https://github.com/pmndrs/zustand  $ npm install zustand 2. 同步方法       从 zustand 中导入函数 create。\n  使用 create 创建时接受 回调函数 set =\u0026gt; ({ ??? })\n 回调函数 必须 使用 set 作为形参， 用于更新状态数据。 回调函数返回一个 对象。 该对象包含 状态数据 与 修改方法    修改方法 使用 set 更新数据。 set 的参数可以是\n 一个状态对象。 一个返回状态对象的 回调函数。 如果 要使用状态值， 则通过 state 给 set 传递参数。 如果 不使用状态值， 则可以直接 替换/覆盖    import { create } from \u0026#39;zustand\u0026#39; // 使用 create 创建状态。 // create 接收一个函数， 函数接收一个 set 参数， set 是一个函数， 用于更新状态。 const useStore = create(set =\u0026gt; ( { count: 0, // 1. set 接收一个对象  set1001: () =\u0026gt; set({ count: 1001 }), // 2. set 接收一个回调函数， 返回一个对象  set2002: () =\u0026gt; set(() =\u0026gt; ({ count: 2002 })), // 3. set 使用已有状态， 回调函数需要使用 state 参数  add1: (payload) =\u0026gt; set((state) =\u0026gt; ({ count: state.count + payload })), // 4. set 不使用已有状态， 不需要传入 state  setn: (payload) =\u0026gt; set({ count: payload }), } )) export default () =\u0026gt; { // 使用状态 1， 解构赋值获取状态和方法  const { count, set1001, set2002, add1, setn } = useStore() return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;7.6.1 Zustand 同步方法\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt; Count: {count}\u0026lt;/h4\u0026gt; {/* 调用 */} \u0026lt;button onClick={() =\u0026gt; set1001()}\u0026gt;Set 1001\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; set2002(2002)}\u0026gt;Set 2002\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; add1(1)}\u0026gt;Add +1\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setn(100)}\u0026gt;Set 100\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } 3. 异步方法     异步方法与同步方法的定义方式一样。 不同在于\n 使用 async...wait 定义成 异步方法 在异步方法内部使用 set 进行数据更新， 使用方法是同步一致。  import { create } from \u0026#39;zustand\u0026#39; import axios from \u0026#39;axios\u0026#39; const URL = `http://geek.itheima.net/v1_0/channels` // channelList=[{id: 1, name: \u0026#39;推荐\u0026#39;}]  const useAsyncStore = create(set =\u0026gt; ( { channelList: [], // 1. 外部定义异步方法  getChannelList: async () =\u0026gt; { const resp = await axios.get(URL) // 2. 内部调用 set 更新状态  // set 的使用方法与同步状态一致  set({ channelList: resp.data.data.channels }) } } )) export default () =\u0026gt; { const { channelList, getChannelList } = useAsyncStore() return ( \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; { channelList.map((item, index) =\u0026gt; { return \u0026lt;li key={item.id}\u0026gt;{index} - {item.name}\u0026lt;/li\u0026gt; }) } \u0026lt;/ul\u0026gt; {/* 外部调用 */} \u0026lt;button onClick={() =\u0026gt; getChannelList()}\u0026gt;GetChannelList\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } ","description":"1. Zustand 安装      官网: https://zustand-demo.pmnd.rs/ Github: https://github.com/pmndrs/zustand  $ npm install zustand 2. 同步方法       从 zustand 中导入函数 create。\n  使用 create 创建时接受 回调函数 set =\u0026gt; ({ ??? })\n 回调函数 必须 使用 set 作为形参， 用于更新状态数据。 回调函数返回一个 对象。 该对象包含 状态数据 与 修改方法    修改方法 使用 set 更新数据。 set 的参数可以是\n 一个状态对象。 一个返回状态对象的 回调函数。 如果 要使用状态值， 则通过 state 给 set 传递参数。 如果 不使用状态值， 则可以直接 替换/覆盖    import { create } from \u0026#39;zustand\u0026#39; // 使用 create 创建状态。 // create 接收一个函数， 函数接收一个 set 参数， set 是一个函数， 用于更新状态。 const useStore = create(set =\u0026gt; ( { count: 0, // 1."},{"id":26,"href":"/books/react/javascript/introduce/","title":"1. 入门简介","parent":"2. JavaScript","content":"视频课程     黑马程序员 JavaScript 入门到精通: https://www.bilibili.com/video/BV1Y84y1L7Nn\n","description":"视频课程     黑马程序员 JavaScript 入门到精通: https://www.bilibili.com/video/BV1Y84y1L7Nn"},{"id":27,"href":"/books/react/javascript/func-class/func/","title":"1. 函数","parent":"5. 函数和类","content":" function default parameters rest parameters  函数的基本定义\n 关键字 function 函数名 func1 代码块 {}  另外, 函数也可以赋值给其他变量，并调用。\n1. 具名函数定义     function func1() { console.log(\u0026#39;func1\u0026#39;); } // call func func1(); // func1  // 赋值给新变量 const newFunc1 = func1; newFunc1(); // func1 2. 匿名函数赋值变量     将 匿名函数 赋值给赋值给一个变量。\nconst varFunc = function () { console.log(\u0026#34;var function\u0026#34;); }; varFunc(); // var function 2. 接受参数     default parameters\n2.1. 接收固定参数 (必须参数)     function func2(name, age) { console.log(`name: ${name}, age: ${age}`); } // call func func2(\u0026#39;John\u0026#39;, 25); // name: John, age: 25 2.2. 可选参数 (默认值)      在参数定义的时候使用 y=5 赋值默认值。 可以使用 undefined 占位， 跳过传参并使用默认值。 如果省略的参数在尾部， 可以直接 不写。  // english: volume // chinese: 体积 function volume(x, y = 5, z = 10) { return x * y * z; } // ignore y, 跳过中间 使用 undefined 占位 const vr4 = volume(4, undefined, 3); console.log(vr4); // 60 = 4*5*3  // ignore z, 跳过尾部参数， 直接省略。 const vr3 = volume(4, 3); console.log(vr3); // 120 = 4*3 * 10 默认值的实现， 其实就是 编译器 帮我们实现了 undefined 的判断\nfunction multiply(a, b) { // 如果 b = undefined， 则使用默认值。  b = typeof b !== \u0026#34;undefined\u0026#34; ? b : 1; return a * b; } multiply(5, 2); // 10 multiply(5); // 5 2.3. 不定长参数/剩余参数(rest parameters)     rest parameters\n// english: rest parameter // chinese: 不定参数长度 function sum(name, ...numbers) { let result = 0; for (let i = 0; i \u0026lt; numbers.length; i++) { result += numbers[i]; } console.log(`${name}: ${result}`); } sum(\u0026#39;sum\u0026#39;, 1, 2, 3, 4, 5); // sum: 15 sum(\u0026#39;total\u0026#39;, 1, 2, 3); // sum: 6 解构剩余参数\n剩余参数可以被解构，这意味着他们的数据可以被解包到不同的变量中。请参阅 解构赋值\nfunction f(...[a, b, c]) { return a + b + c; } f(1); // NaN (b and c are undefined) f(1, 2, 3); // 6 f(1, 2, 3, 4); // 6 (the fourth parameter is not destructured) 剩余参数和 arguments对象的区别 主要有三个：\n 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。 arguments 对象不是一个真正的数组，而剩余参数是真正的 Array 实例，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach或pop。 arguments 对象还有一些附加的属性（如 callee 属性）。  3. 函数返回值     js 中函数返回值的 数量和类型， 不需要在声明时指定， 直接使用 return 即可。\n 返回简单类型  // 1.3 function return value function area(width, height) { if (width \u0026gt; 0 \u0026amp;\u0026amp; height \u0026gt; 0) { return width * height; } return 0 } // 获取返回值: 简单类型 const r1 = area(5, 10); console.log(r1); 返回复杂类型, obj  function getInfo(name, age) { return { name: name, age: age }; } // 获取返回值 const info = getInfo(\u0026#39;Jerry\u0026#39;, 15); console.log(info); // { name: \u0026#39;Jerry\u0026#39;, age: 15 } console.log(info.name); // Jerry  // 获取返回值: 解构赋值 const { name, age } = getInfo(\u0026#34;Tom\u0026#34;, 30) console.log(name, age); // Tom 30 4. 函数二义性     function 函数二义性 - B站\n","description":"function default parameters rest parameters  函数的基本定义\n 关键字 function 函数名 func1 代码块 {}  另外, 函数也可以赋值给其他变量，并调用。\n1. 具名函数定义     function func1() { console.log(\u0026#39;func1\u0026#39;); } // call func func1(); // func1  // 赋值给新变量 const newFunc1 = func1; newFunc1(); // func1 2. 匿名函数赋值变量     将 匿名函数 赋值给赋值给一个变量。\nconst varFunc = function () { console.log(\u0026#34;var function\u0026#34;); }; varFunc(); // var function 2. 接受参数     default parameters"},{"id":28,"href":"/books/react/react/hooks/use-effect/basic/","title":"1. 基础语法","parent":"useEffect 生命周期管理","content":"1. 语法规则     import { useEffect } from \u0026#39;react\u0026#39; useEffect(()=\u0026gt;{}, []) useEffect 支持两个参数\n 参数一是 函数 ()=\u0026gt;{}。 可以称其为 副作用函数， 在函数内部可以放置要执行的操作。  如果函数由返回值， 则表示在 组件卸载时执行， 这个后面讨论。   参数二是 数组 []（可选）， 在数组里放置 依赖项。  不同依赖项数据量导致渲染行为不一致， 这个后面讨论。    在 /src/components/hooks/UseEffectBasic.jsx 中。\nimport { useEffect, useState } from \u0026#34;react\u0026#34; const URL = \u0026#39;http://geek.itheima.net/v1_0/channels\u0026#39; export default function UseEffectBasic() { const [channels, setChannels] = useState([]) // 定义副作用函数， 只执行一次  useEffect(() =\u0026gt; { console.log(\u0026#39;useEffect\u0026#39;) // 定义异步函数  // https://juejin.cn/post/6844903858422956040  // https://blog.51cto.com/u_15283585/5220471  async function fetchData() { const res = await fetch(URL) .catch(console.error) // 捕获错误  // 如果请求成功  if (res?.status === 200) { const resJson = await res.json() setChannels(resJson.data.channels) } } // 调用异步函数  fetchData() }, []) return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;UseEffect 基本信息\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;asss \u0026lt;/li\u0026gt; { channels.map((item, index) =\u0026gt; { return \u0026lt;li key={index}\u0026gt;{item.name}\u0026lt;/li\u0026gt; }) } \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } 在 fetch 请求处理网络错误 #55 处理了 异步请求 的访问错误问题。\n 使用 catch 捕获错误。 这点和 axios 差不多。 返回的 res 时 void 或者 Response。 所以在判断 res?.status 的时候， 需要使用 ?  ","description":"1. 语法规则     import { useEffect } from \u0026#39;react\u0026#39; useEffect(()=\u0026gt;{}, []) useEffect 支持两个参数\n 参数一是 函数 ()=\u0026gt;{}。 可以称其为 副作用函数， 在函数内部可以放置要执行的操作。  如果函数由返回值， 则表示在 组件卸载时执行， 这个后面讨论。   参数二是 数组 []（可选）， 在数组里放置 依赖项。  不同依赖项数据量导致渲染行为不一致， 这个后面讨论。    在 /src/components/hooks/UseEffectBasic.jsx 中。\nimport { useEffect, useState } from \u0026#34;react\u0026#34; const URL = \u0026#39;http://geek.itheima.net/v1_0/channels\u0026#39; export default function UseEffectBasic() { const [channels, setChannels] = useState([]) // 定义副作用函数， 只执行一次  useEffect(() =\u0026gt; { console."},{"id":29,"href":"/books/react/javascript/variables/variable/","title":"1. 声明","parent":"2. 变量","content":"变量特点\n 使用 let 定义。 但 同一个变量名 并不能被重复定义。 变量可以重新赋值  1. 变量定义     // 使用 let 定义 let a = 1 console.log(a); // 1 // 重新赋值 a = 2 console.log(a); // 2  // 重复定义 // let a = 3 // SyntaxError: Identifier \u0026#39;a\u0026#39; has already been declared 其他定义和使用方式\n// 多个变量定义 let x = 1, y = 2 // 先定义后赋值 let z z = 1 2. 变量命名规则      变量名支持  大小写字母 [a-zA-Zs] 数字 `[0-9] 下划线 _ 美元符号 $   不能以数字开头  // 建议用 let _abc = 123 let Abc = 123 let aBc = 123 // 语法错误 // let 1abc = 123 // SyntaxError: Invalid or unexpected token 虽然变量名中包含 $ 是合法的， 甚至是在变量名中间。 但是不建议用。 其他语言没有这种规则， 何必徒添烦恼。\n// 不建议用， 其他语言没有这种用法 let $abc = 123 console.log($abc); // 123  let a$bc = 213 console.log(a$bc); // 213 3. 不再实用 var 定义     有很多问题， 诸如 重复定义， 先使用再定义 之类的。\n反正不要用就对了。\n{{ }}\n","description":"变量特点\n 使用 let 定义。 但 同一个变量名 并不能被重复定义。 变量可以重新赋值  1. 变量定义     // 使用 let 定义 let a = 1 console.log(a); // 1 // 重新赋值 a = 2 console.log(a); // 2  // 重复定义 // let a = 3 // SyntaxError: Identifier \u0026#39;a\u0026#39; has already been declared 其他定义和使用方式\n// 多个变量定义 let x = 1, y = 2 // 先定义后赋值 let z z = 1 2. 变量命名规则      变量名支持  大小写字母 [a-zA-Zs] 数字 `[0-9] 下划线 _ 美元符号 $   不能以数字开头  // 建议用 let _abc = 123 let Abc = 123 let aBc = 123 // 语法错误 // let 1abc = 123 // SyntaxError: Invalid or unexpected token 虽然变量名中包含 $ 是合法的， 甚至是在变量名中间。 但是不建议用。 其他语言没有这种规则， 何必徒添烦恼。"},{"id":30,"href":"/books/react/react/router/setup/","title":"1. 安装","parent":"6. React-Router","content":"ReactRouter 为 React 提供路由管理的组件。\n安装     $ npm install react-router-dom 在 package.json 中， 可以看到版本为 6.22.1\n\u0026#34;dependencies\u0026#34;: { \u0026#34;react-router-dom\u0026#34;: \u0026#34;^6.22.1\u0026#34;, }, 使用     在 /src/components/router/RootRouter.jsx 中\n 使用 createBrowserRouter 创建 路由列表 router。 在组件中， 使用 RouterProvider 使用路由页面。  注意： 当前路由中使用的是 element 字段， 而非 componenet。\n之后就可以访问 http://localhost:3000/page1 或者 http://localhost:3000/page2 切换页面了。\n import { createBrowserRouter, RouterProvider } from \u0026#34;react-router-dom\u0026#34;; // 创建路由 const router = createBrowserRouter([ { path: \u0026#34;/page1\u0026#34;, element: \u0026lt;div\u0026gt;Page1\u0026lt;/div\u0026gt;, }, { path: \u0026#34;/page2\u0026#34;, element: \u0026lt;div\u0026gt;Page2\u0026lt;/div\u0026gt; } ]) export default function RootRouter() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;8. 路由页面 Root Page\u0026lt;/h2\u0026gt; {/* 使用路由 */} \u0026lt;RouterProvider router={router} /\u0026gt; \u0026lt;/div\u0026gt; ); } 什么是前端路由     一个 路径（path） 对应一个 组件（componenet）。 当我们在浏览器中访问 path 的时候， path 对应的组件会在页面中渲染。\n ","description":"ReactRouter 为 React 提供路由管理的组件。\n安装     $ npm install react-router-dom 在 package.json 中， 可以看到版本为 6.22.1\n\u0026#34;dependencies\u0026#34;: { \u0026#34;react-router-dom\u0026#34;: \u0026#34;^6.22.1\u0026#34;, }, 使用     在 /src/components/router/RootRouter.jsx 中\n 使用 createBrowserRouter 创建 路由列表 router。 在组件中， 使用 RouterProvider 使用路由页面。  注意： 当前路由中使用的是 element 字段， 而非 componenet。\n之后就可以访问 http://localhost:3000/page1 或者 http://localhost:3000/page2 切换页面了。\n import { createBrowserRouter, RouterProvider } from \u0026#34;react-router-dom\u0026#34;; // 创建路由 const router = createBrowserRouter([ { path: \u0026#34;/page1\u0026#34;, element: \u0026lt;div\u0026gt;Page1\u0026lt;/div\u0026gt;, }, { path: \u0026#34;/page2\u0026#34;, element: \u0026lt;div\u0026gt;Page2\u0026lt;/div\u0026gt; } ]) export default function RootRouter() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;8."},{"id":31,"href":"/books/react/react/communication/props/props/","title":"1. 支持的数据类型","parent":"1. props 通信","content":"/src/components/communication/Parent2Children.jsx\n props 可以传递任意数据  数字, 字符串, 布尔值 数组, 对象 函数, JSX    function Parent() { return ( \u0026lt;div\u0026gt; \u0026lt;Child name={\u0026#34;Wangwu\u0026#34;} age={20} isTrue={true} list={[1, 2, 3]} obj={{ name: \u0026#34;Zhaoliu\u0026#34; }} func={() =\u0026gt; { console.log(\u0026#34;Hello\u0026#34;) }} child={\u0026lt;span\u0026gt;this is a span\u0026lt;/span\u0026gt;} /\u0026gt; \u0026lt;/div\u0026gt; ); }  props 是 只读对象:  子组件 只能读取 props 中的数据， 不能直接修改。 如果要修改， 只能在父组件中 由父组件修改。 参考 子传父通信    3. 兄弟通信     状态提升\n","description":"/src/components/communication/Parent2Children.jsx\n props 可以传递任意数据  数字, 字符串, 布尔值 数组, 对象 函数, JSX    function Parent() { return ( \u0026lt;div\u0026gt; \u0026lt;Child name={\u0026#34;Wangwu\u0026#34;} age={20} isTrue={true} list={[1, 2, 3]} obj={{ name: \u0026#34;Zhaoliu\u0026#34; }} func={() =\u0026gt; { console.log(\u0026#34;Hello\u0026#34;) }} child={\u0026lt;span\u0026gt;this is a span\u0026lt;/span\u0026gt;} /\u0026gt; \u0026lt;/div\u0026gt; ); }  props 是 只读对象:  子组件 只能读取 props 中的数据， 不能直接修改。 如果要修改， 只能在父组件中 由父组件修改。 参考 子传父通信    3. 兄弟通信     状态提升"},{"id":32,"href":"/books/react/javascript/data-types/number/","title":"1. 数字","parent":"3. 数据类型","content":" Number NaN BigInt  ","description":" Number NaN BigInt  "},{"id":33,"href":"/books/react/javascript/data-types/array/array/","title":"1. 数组","parent":"5. 数组","content":"","description":""},{"id":34,"href":"/books/react/demos/redux-meituan/setup/","title":"1. 环境准备","parent":"2. Redux 案例 - 美团","content":"1. 解压项目     解压 /src/demos/redux-meituan.tgz\n2. mock 数据     创建 /src/demos/redux-meituan/mock 目录， 创建mock 数据。\n$ npm install json-server 启动服务\n$ json-server --watch data.json --port 3101 3. 对外提供数据     对外提供数据\nconst takeawayURL = \u0026#39;http://localhost:3101/takeaway\u0026#39; export { takeawayURL } ","description":"1. 解压项目     解压 /src/demos/redux-meituan.tgz\n2. mock 数据     创建 /src/demos/redux-meituan/mock 目录， 创建mock 数据。\n$ npm install json-server 启动服务\n$ json-server --watch data.json --port 3101 3. 对外提供数据     对外提供数据\nconst takeawayURL = \u0026#39;http://localhost:3101/takeaway\u0026#39; export { takeawayURL } "},{"id":35,"href":"/books/react/setup/","title":"1. 环境配置","parent":"","content":"","description":""},{"id":36,"href":"/books/react/react/components/what-is-component/","title":"1. 组件式开发","parent":"3. 组件","content":"1. 组件是什么     组件是用户界面的一部分， 他可以有自己的的逻辑和外观。\n 组件之间 可以互相嵌套 组件 可以多次重复使用   组件化开发， 可以让开发者像搭积木一样构建一个庞大而完整的新系统。\n2. 如何定义组件     ","description":"1. 组件是什么     组件是用户界面的一部分， 他可以有自己的的逻辑和外观。\n 组件之间 可以互相嵌套 组件 可以多次重复使用   组件化开发， 可以让开发者像搭积木一样构建一个庞大而完整的新系统。\n2. 如何定义组件     "},{"id":37,"href":"/books/react/css/class-selector/","title":"1. 选择器","parent":"5. CSS","content":"选择器       通用选择选择器 *\n  元素选择器 h1, div ...\n  类选择器 .name\n  ID选择器 #name\n  元素选择器 [name]\n  * {} h1 {} .left {} #app {} [title] {} 1. 选择器关系 （组合使用）     这里的所有代词都可以替换为上述选择器。\n1. 后代关系       包含 亲子关系 及以后的所有后代。 选择器之间使用 空格 连接。\nfather .son, father grandson ...。\nfather son {} div grandson {} 1.1. 父子关系 \u0026gt;     只包含 父子 这一代。\nfather\u0026gt;son\nfather\u0026gt;son {} 1.2 兄弟关系(毗邻关系): +     选中的两个标签位置必须相邻， 不能相隔。\nspan+p { color: red; } 例如\n\u0026lt;div\u0026gt; \u0026lt;span\u0026gt;毗邻关系\u0026lt;/span\u0026gt; \u0026lt;p\u0026gt;第一行: 只有这一行生效\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;第二行\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 1.3 交集关系     直接将两个选择器 连着 写在一起。 既要、又要\nh1.left {} \u0026lt;h1 class=\u0026#34;left\u0026#34;\u0026gt;Title\u0026lt;/h1\u0026gt; .left.active {} .left#app {} 例如\n\u0026lt;h1 class=\u0026#34;left\u0026#34;\u0026gt;Title\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;left active\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;left\u0026#34; id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 1.4. 并集关系 ,     使用逗号分割。\n/* 可以单行 */ h1, .left {} .left, #app {} /* 可以换行方便查看 */ .left, .active { } 例如\n\u0026lt;h1\u0026gt;Title\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;left\u0026#34; id=\u0026#34;app\u0026#34;\u0026gt;this is a div\u0026lt;/div\u0026gt; 2. 属性选择器     属性选择器有以下几种匹配方式\n [title]: 选择所有具有 title 属性内容 [title=xxxx]: 选择 title 值为 xxx 的内容。 匹配模式  [title^=abc]: 选择 title 值以 abc 开头的内容。 [title$=xyz]: 选择 title 值以 xyz 结尾的内容。 [title~=mn] : 选贼 title 至包含了 mn 的内容。    ","description":"选择器       通用选择选择器 *\n  元素选择器 h1, div ...\n  类选择器 .name\n  ID选择器 #name\n  元素选择器 [name]\n  * {} h1 {} .left {} #app {} [title] {} 1. 选择器关系 （组合使用）     这里的所有代词都可以替换为上述选择器。\n1. 后代关系       包含 亲子关系 及以后的所有后代。 选择器之间使用 空格 连接。\nfather .son, father grandson ...。\nfather son {} div grandson {} 1."},{"id":38,"href":"/books/react/setup/install/","title":"1. 配置开发环境","parent":"1. 环境配置","content":"安装 NodeJS      安装 NodeJS  wget -c https://nodejs.org/dist/v20.11.0/node-v20.11.0-darwin-arm64.tar.gz tar xf node-v20.11.0-darwin-arm64.tar.gz mv node-v20.11.0-darwin-arm64 /usr/local/nodejs 配置环境变量  export NODE_ROOT=/usr/local/nodejs export PATH=$NODE_ROOT/bin:$PATH alias cnpm=\u0026#39;npm --registry=https://registry.npmmirror.com \u0026#39; 配置国内源  yarn config set registry https://registry.npmmirror.com npm config set registry https://registry.npmmirror.com Chrome 插件      React Developer Tools  ","description":"安装 NodeJS      安装 NodeJS  wget -c https://nodejs.org/dist/v20.11.0/node-v20.11.0-darwin-arm64.tar.gz tar xf node-v20.11.0-darwin-arm64.tar.gz mv node-v20.11.0-darwin-arm64 /usr/local/nodejs 配置环境变量  export NODE_ROOT=/usr/local/nodejs export PATH=$NODE_ROOT/bin:$PATH alias cnpm=\u0026#39;npm --registry=https://registry.npmmirror.com \u0026#39; 配置国内源  yarn config set registry https://registry.npmmirror.com npm config set registry https://registry.npmmirror.com Chrome 插件      React Developer Tools  "},{"id":39,"href":"/books/react/react/","title":"10. React","parent":"","content":"基于 React18\n","description":"基于 React18"},{"id":40,"href":"/books/react/react/react19/","title":"10. React 19 支持","parent":"10. React","content":"","description":""},{"id":41,"href":"/books/react/react/communication/context/","title":"2. context 跨层级通信","parent":"5. 组件通信","content":"和 Golang 的 context 差不多。 在 context.Provider 下的所有节点都可以通过关键字 useContext 获取数据。\n解决了 props 中不相关的组件之间需要传递数据时 状态提升 的复杂操作。\n  使用 createContext 方法创建一个 上下文对象 Ctx 在顶层组件 (如图, App) 中使用 Ctx.Provider 组件提供数据。 在下层组件 (如图, B) 中使用 useContext 钩子获取消费数据。   在 /src/components/communication/UseContext.jsx 中， 定义三个组件形成嵌套关系\n UseContext, 对应上图中的 App A 对应 A B 对应 B  1. 定义 MsgContext     在文件级别， 使用 createContext 创建 Context 对象\n注意: 经测试， 创建时提供的 default value 并不起作用。 实际 可用数据 还是需要在 \u0026lt;MsgContext.Provider\u0026gt; value={xxx} 中提供。\nimport { createContext, useContext } from \u0026#39;react\u0026#39; // 创建 context 对象 const MsgContext = createContext(\u0026#39;default value\u0026#39;) 2. 传递 MsgContext     在 UseContext 中， 定义 data 并传递数据\n 使用 useState 定义状态数据 data 使用 button 点击事件， 调用 changeData 函数修改 data 的值 使用 MsgContext.Provider 包裹 组件A， 并使用 value={data} 传入数据  export default function UseContext() { // 定义状态数据  const original = { \u0026#34;name\u0026#34;: \u0026#34;zhangsan\u0026#34;, \u0026#34;age\u0026#34;: 10 } const [data, setdata] = useState(original) // 定义函数修改 data 的值  function changeData() { setdata({ \u0026#34;name\u0026#34;: \u0026#34;wangwu\u0026#34;, \u0026#34;age\u0026#34;: 20 }) } return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;7.4 Context 跨层级传递\u0026lt;/h3\u0026gt; {/* 传入 data */} \u0026lt;MsgContext.Provider value={data}\u0026gt; \u0026lt;A /\u0026gt; \u0026lt;/MsgContext.Provider\u0026gt; \u0026lt;button onClick={changeData}\u0026gt;点我修改 data\u0026lt;/button\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;/div\u0026gt; ) } 3. 使用 MsgContext     由于 MsgContext 已经包裹在了最外层， 因此 包括 A 在内的所有子孙组件 都可以使用 Context。\n 创建 A 包裹 B 在 B 中使用 useContext(ContextName) 获取数据， 并使用。  // A 单纯的用于组件嵌套 function A() { return ( \u0026lt;div\u0026gt; \u0026lt;b\u0026gt;this a A area\u0026lt;/b\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;B /\u0026gt; \u0026lt;/div\u0026gt; ) } // 使用 useContext 获取 MsgContext 的值， 并使用 function B() { const msg = useContext(MsgContext) return ( \u0026lt;div\u0026gt; \u0026lt;b\u0026gt;this is B area: \u0026lt;/b\u0026gt; \u0026lt;span\u0026gt;{msg.name}\u0026lt;/span\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;/div\u0026gt; ) } ","description":"和 Golang 的 context 差不多。 在 context.Provider 下的所有节点都可以通过关键字 useContext 获取数据。\n解决了 props 中不相关的组件之间需要传递数据时 状态提升 的复杂操作。\n  使用 createContext 方法创建一个 上下文对象 Ctx 在顶层组件 (如图, App) 中使用 Ctx.Provider 组件提供数据。 在下层组件 (如图, B) 中使用 useContext 钩子获取消费数据。   在 /src/components/communication/UseContext.jsx 中， 定义三个组件形成嵌套关系\n UseContext, 对应上图中的 App A 对应 A B 对应 B  1. 定义 MsgContext     在文件级别， 使用 createContext 创建 Context 对象\n注意: 经测试， 创建时提供的 default value 并不起作用。 实际 可用数据 还是需要在 \u0026lt;MsgContext."},{"id":42,"href":"/books/react/javascript/","title":"2. JavaScript","parent":"","content":"","description":""},{"id":43,"href":"/books/react/react/jsx/basic-syntax/","title":"2. jsx 的常用用法","parent":"1. jsx 基础用法","content":"在 jsx 中， 可以通过 大括号语法{} 识别 JavaScript 中的表达式。\n常见的包括\n 常量调用 变量调用 函数调用 方法调用 使用 js 对象 等等  1. 常量调用     在 BasicSyntax 内部使用 {'this is const string'}\n// BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;1. 常量调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{\u0026#39;this is const string\u0026#39;}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } 2. 变量调用      在 BasicSyntax 组建外部定义 变量 val。 在内部使用 {val} 调用  // BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;2. 变量调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{val}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } // 定义变量 let val = \u0026#39;this is const variable\u0026#39; 3. 函数调用      在 BasicSyntax 组建外部定义 函数 hello 在内部使用 {hello()} 调用。  注意： 调用函数时，必须要使用 圆括号() 函数才会被执行。\n// BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;3. 函数调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{hello()}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } // 定义函数 function hello() { return \u0026#34;Hello React18, from function\u0026#34; } 4. 方法调用     方法 本质上就是 具有一定限制函数。 因此方法调用与函数调用类似。\n// BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;4. 方法调用\u0026lt;/h3\u0026gt; {/* 字符串方法 */} \u0026lt;p\u0026gt;{hello().toUpperCase()}\u0026lt;/p\u0026gt; {/* 创建对象，并调用时间方法 */} \u0026lt;p\u0026gt;{new Date().getDate()}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } // 定义变量 let val = \u0026#39;this is const variable\u0026#39; 5. JS 对象调用     需要注意的是， 这里并不是使用的 双花括号 {{content}}， 而是两个不同意义的花括号。\n 外层 是 jsx 语法的花括号， 表示内部为 js 语法。 内层 是 js 语法的中 style 的定义 style={color:'red'}  // BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;5. js 对象调用\u0026lt;/h3\u0026gt; {/* 注意这里不是不是 双括号 */} {/* 外层括号是 {} 是 jsx 表达式 */} {/* 内层括号是 js 调用, 相当于 style={color:\u0026#39;red\u0026#39;} */} \u0026lt;div style={{ color: \u0026#39;red\u0026#39; }}\u0026gt; this is in div \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } 6. 数学计算     数学计算\n// BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;6. 数学计算\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{1 + 2}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } 7. 注释      注释也是使用 花括号{} 开启 JS 语法 然后使用 JS 中的多行注释语法。  // BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;7. 注释\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;这里看不到内容\u0026lt;/p\u0026gt; {/* 这里可以看到 */} \u0026lt;/div\u0026gt; ); } 其他     完整代码可以在 /src/components/jsx/BasicSyntax.js 中看到\nfunction BasicSyntax() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;2.2. jsx 基础语法\u0026lt;/h1\u0026gt; \u0026lt;h3\u0026gt;1. 常量调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{\u0026#39;this is const string\u0026#39;}\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;2. 变量调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{val}\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;3. 函数调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{hello()}\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;4. 方法调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{hello().toUpperCase()}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{new Date().getDate()}\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;5. js 对象调用\u0026lt;/h3\u0026gt; {/* 注意这里不是不是 双括号 */} {/* 外层括号是 {} 是 jsx 表达式 */} {/* 内层括号是 js 调用, 相当于 style={color:\u0026#39;red\u0026#39;} */} \u0026lt;div style={{ color: \u0026#39;red\u0026#39; }}\u0026gt; this is in div \u0026lt;/div\u0026gt; \u0026lt;h3\u0026gt;6. 数学计算\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{1 + 2}\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;7. 注释\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;这里看不到内容\u0026lt;/p\u0026gt; {/* 这里可以看到 */} \u0026lt;/div\u0026gt; ); } export default BasicSyntax; // 定义变量 let val = \u0026#39;this is const variable\u0026#39; // 定义函数 function hello() { return \u0026#34;Hello React18, from function\u0026#34; } ","description":"在 jsx 中， 可以通过 大括号语法{} 识别 JavaScript 中的表达式。\n常见的包括\n 常量调用 变量调用 函数调用 方法调用 使用 js 对象 等等  1. 常量调用     在 BasicSyntax 内部使用 {'this is const string'}\n// BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;1. 常量调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{\u0026#39;this is const string\u0026#39;}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } 2. 变量调用      在 BasicSyntax 组建外部定义 变量 val。 在内部使用 {val} 调用  // BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;2."},{"id":44,"href":"/books/react/react/events/on-change/","title":"2. onChange 数据双向绑定","parent":"2. 事件绑定","content":" 在 /src/components/event/EventOnChange.js 中实现了 数据的双向绑定。 即\n 使用 useState 管理变量 username 的状态 使用 {username} 实现数据 从 state 到 UI 的单向绑定。 使用 onChange 捕捉控件的变化事件。 随后通过 箭头函数 获取 当前事件目标的值(e.target.value) 并通过 setUsername 保存数据， 从而数据 从 UI 到 state 的单向绑定。 当数据更新到 state 后， React 又刷新了页面。  // Path: src/components/event/EventOnClick.js  import { useState } from \u0026#34;react\u0026#34; export default function EventOnChange() { const [username, setUsername] = useState(\u0026#34;zhangsan\u0026#34;) return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;OnChange 事件实现数据双向绑定\u0026lt;/h2\u0026gt; {/* 1. {username} 实现数据从 state 到 UI 的单向绑定 2. onChange(e) 实现数据从 UI 到 state 的单向绑定 */} \u0026lt;input value={username} onChange={(e) =\u0026gt; setUsername(e.target.value)} /\u0026gt; \u0026lt;span\u0026gt;{username}\u0026lt;/span\u0026gt; \u0026lt;/div \u0026gt; ) } ","description":"在 /src/components/event/EventOnChange.js 中实现了 数据的双向绑定。 即\n 使用 useState 管理变量 username 的状态 使用 {username} 实现数据 从 state 到 UI 的单向绑定。 使用 onChange 捕捉控件的变化事件。 随后通过 箭头函数 获取 当前事件目标的值(e.target.value) 并通过 setUsername 保存数据， 从而数据 从 UI 到 state 的单向绑定。 当数据更新到 state 后， React 又刷新了页面。  // Path: src/components/event/EventOnClick.js  import { useState } from \u0026#34;react\u0026#34; export default function EventOnChange() { const [username, setUsername] = useState(\u0026#34;zhangsan\u0026#34;) return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;OnChange 事件实现数据双向绑定\u0026lt;/h2\u0026gt; {/* 1. {username} 实现数据从 state 到 UI 的单向绑定 2."},{"id":45,"href":"/books/react/react/communication/redux/redux-react-setup/","title":"2. Redux 与 React - 环境准备","parent":"3. redux","content":"官方要求安装两个其他插件\n  Redux Toolkit (RTK): 官方推荐编写 Redux 逻辑的方式， 是一套工具的集合， 可以 简化书写方式\n 简化 store 的配置 内置 immer 支持可变状态的修改 内置 thunk 更好的支持 异步创建    react-redux: 用于 链接 Redux 和 React 的中间件\n   1. 插件安装     $ npm install @reduxjs/toolkit react-redux 安装后可以在 package.json 中查看版本。\n\u0026#34;dependencies\u0026#34;: { \u0026#34;@reduxjs/toolkit\u0026#34;: \u0026#34;^2.2.1\u0026#34;, \u0026#34;react-redux\u0026#34;: \u0026#34;^9.1.0\u0026#34;, }, 比 教学视频 的版本高。 (2024-02-20)\n\u0026#34;dependencies\u0026#34;: { \u0026#34;@reduxjs/toolkit\u0026#34;: \u0026#34;^1.9.3\u0026#34;, \u0026#34;react-redux\u0026#34;: \u0026#34;^8.0.5\u0026#34;, }, 2. store 目录结构设计     创建 /src/store 根目录，\n 通常集中状态管理部分都会 单独创建 store 目录， 一般位置为 /src/store/ 应用通常会有很多个 子 store 模块， 所以创建一个 /src/store/modules/ 目录， 在目录内 通过文件独立维护子 store 创建 入口文件 /src/store/index.js， 用于组合 modules 中的所有子模块， 并导出 store。   ","description":"官方要求安装两个其他插件\n  Redux Toolkit (RTK): 官方推荐编写 Redux 逻辑的方式， 是一套工具的集合， 可以 简化书写方式\n 简化 store 的配置 内置 immer 支持可变状态的修改 内置 thunk 更好的支持 异步创建    react-redux: 用于 链接 Redux 和 React 的中间件\n   1. 插件安装     $ npm install @reduxjs/toolkit react-redux 安装后可以在 package.json 中查看版本。\n\u0026#34;dependencies\u0026#34;: { \u0026#34;@reduxjs/toolkit\u0026#34;: \u0026#34;^2.2.1\u0026#34;, \u0026#34;react-redux\u0026#34;: \u0026#34;^9.1.0\u0026#34;, }, 比 教学视频 的版本高。 (2024-02-20)\n\u0026#34;dependencies\u0026#34;: { \u0026#34;@reduxjs/toolkit\u0026#34;: \u0026#34;^1.9.3\u0026#34;, \u0026#34;react-redux\u0026#34;: \u0026#34;^8.0.5\u0026#34;, }, 2. store 目录结构设计     创建 /src/store 根目录，"},{"id":46,"href":"/books/react/demos/redux-meituan/","title":"2. Redux 案例 - 美团","parent":"99. 项目案例","content":"","description":""},{"id":47,"href":"/books/react/javascript/control-flow/switch/","title":"2. switch","parent":"6. 控制流/分支语句","content":"switch\nswitch (expression) { case caseExpression1: statements case caseExpression2: statements // …  case caseExpressionN: statements default: statements }  如果所有分支都匹配不成功， 则进入 default 分支。 注意 default 分支是可选的。  switch (a) { case 1: console.log(\u0026#39;a is 1\u0026#39;) break default: console.log(\u0026#39;a is not 1\u0026#39;) // a is not 1 } switch (a) { case 1: console.log(\u0026#39;a is 1\u0026#39;) break } switch 的分支逻辑是 默认下沉 的。 即 一旦某一个分支匹配成功， 则以下所有分支都会被执行,   这一点和 Golang 逻辑正好相反。 Go 默认不下沉 而是使用 fallthrough 关键字主动控制。\n let a = 2 switch (a) { case 1: console.log(\u0026#39;a is 1\u0026#39;) case 2: console.log(\u0026#39;a is 2\u0026#39;) // a is 2  case 3: console.log(\u0026#39;a is 3\u0026#39;) // a is 3  default: console.log(\u0026#39;a is not 1, 2, or 3\u0026#39;) // a is not 1, 2, or 3 } 注意: 如果要跳出分支， 则需要使用 break 关键字\nlet a = 2 switch (a) { case 1: console.log(\u0026#39;a is 1\u0026#39;) break case 2: console.log(\u0026#39;a is 2\u0026#39;) // a is 2  break case 3: console.log(\u0026#39;a is 3\u0026#39;) break default: console.log(\u0026#39;a is not 1, 2, or 3\u0026#39;) } ","description":"switch\nswitch (expression) { case caseExpression1: statements case caseExpression2: statements // …  case caseExpressionN: statements default: statements }  如果所有分支都匹配不成功， 则进入 default 分支。 注意 default 分支是可选的。  switch (a) { case 1: console.log(\u0026#39;a is 1\u0026#39;) break default: console.log(\u0026#39;a is not 1\u0026#39;) // a is not 1 } switch (a) { case 1: console.log(\u0026#39;a is 1\u0026#39;) break } switch 的分支逻辑是 默认下沉 的。 即 一旦某一个分支匹配成功， 则以下所有分支都会被执行,   这一点和 Golang 逻辑正好相反。 Go 默认不下沉 而是使用 fallthrough 关键字主动控制。"},{"id":48,"href":"/books/react/setup/initalize/vite/","title":"2. vite 初始化项目","parent":"0. 初始化项目","content":"1. 使用 vite 初始化项目     使用 vite guide 创建第一个项目\n$ npm create vite@latest # ✔ Project name: … my-vite-react # ✔ Select a framework: › React # ✔ Select a variant: › JavaScript # Scaffolding project in /private/tmp/vite-demo/my-vite-react... # Done. Now run: # cd my-vite-react # npm install # npm run dev 这里创建的是 React + JSX,\n 入口文件: index.html, 可以在代码中看到，引用了 main.jsx 项目文件: main.jsx, App.jsx  2. npx 迁移到 vite     2.1. index.html     复制 index.html 到项目更目录\n2.2. package.json     可以通过 vite 命令创建任意项目， 然后将 package.json 中的内容复制到 原项目 中 添加或覆盖\n// package.json { \u0026#34;name\u0026#34;: \u0026#34;my-vue-app\u0026#34;, \u0026#34;private\u0026#34;: true, \u0026#34;version\u0026#34;: \u0026#34;0.0.0\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;module\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;vite\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;vite build\u0026#34;, \u0026#34;preview\u0026#34;: \u0026#34;vite preview\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@types/react\u0026#34;: \u0026#34;^18.2.56\u0026#34;, \u0026#34;@types/react-dom\u0026#34;: \u0026#34;^18.2.19\u0026#34;, \u0026#34;@vitejs/plugin-react\u0026#34;: \u0026#34;^4.2.1\u0026#34;, \u0026#34;vite\u0026#34;: \u0026#34;^5.1.4\u0026#34; } } 完成之后， 运行 npm install 命令安装新依赖。\n 注意： npx 项目支持使用 Xxxx.js 文件作为 模块(Componenet)文件, 但是 vite 不支持。 必须全部重命名为 Xxxx.jsx ， 否则会报错。\n ","description":"1. 使用 vite 初始化项目     使用 vite guide 创建第一个项目\n$ npm create vite@latest # ✔ Project name: … my-vite-react # ✔ Select a framework: › React # ✔ Select a variant: › JavaScript # Scaffolding project in /private/tmp/vite-demo/my-vite-react... # Done. Now run: # cd my-vite-react # npm install # npm run dev 这里创建的是 React + JSX,\n 入口文件: index.html, 可以在代码中看到，引用了 main.jsx 项目文件: main.jsx, App.jsx  2. npx 迁移到 vite     2."},{"id":49,"href":"/books/react/setup/vscode/","title":"2. VSCode","parent":"1. 环境配置","content":"1. 插件      Quokka.js, Video Demo Path Intellisense JavaScript and TypeScript Nightly ES7+ React/Redux/React-Native snippets Auto Rename Tag  2. 工具      Code Inspector - Video Demo  ","description":"1. 插件      Quokka.js, Video Demo Path Intellisense JavaScript and TypeScript Nightly ES7+ React/Redux/React-Native snippets Auto Rename Tag  2. 工具      Code Inspector - Video Demo  "},{"id":50,"href":"/books/react/javascript/loop/while/","title":"2. while","parent":"7. 循环/迭代","content":" while do\u0026hellip;while  1. while     语法结构\nwhile (condition) { // code block to be executed } Demo\nlet i = 0; while (i \u0026lt; 3) { console.log(i); // 0, 1, 2  i++; } 可以使用 for 循环 代替 while 循环\nlet j = 0 for (; j \u0026lt; 3; j++) { console.log(j); } 2. do\u0026hellip;while     基本不用\n","description":"while do\u0026hellip;while  1. while     语法结构\nwhile (condition) { // code block to be executed } Demo\nlet i = 0; while (i \u0026lt; 3) { console.log(i); // 0, 1, 2  i++; } 可以使用 for 循环 代替 while 循环\nlet j = 0 for (; j \u0026lt; 3; j++) { console.log(j); } 2. do\u0026hellip;while     基本不用"},{"id":51,"href":"/books/react/react/hooks/use-effect/dependencies/","title":"2. 不同依赖项行为","parent":"useEffect 生命周期管理","content":"2. 不同依赖项的不同渲染行为     不同状态 的数组影响第一参数函数的执行。 1. 数据被省略时： 在组件加载时执行， 且在任意渲染时执行。 2. 数组为空时： 仅在组件加载时执行 （仅执行一次）。 3. 数组中有依赖项时： 在组件加载时执行， 且在 仅在依赖项变化时触发的渲染时执行\n 在 /src/components/hooks/UseEffectDependencies.jsx 中\nimport { useState, useEffect } from \u0026#34;react\u0026#34;; export default function UseEffectDependencies() { const [count, setCount] = useState(0) const [trigger, setTrigger] = useState(0) // (1) none dependency  // 组件加载时，执行一次  // 无依赖项，每次组件更新时，都会执行  useEffect(() =\u0026gt; { console.log(\u0026#39;NONE: useEffect called\u0026#39;); }); // (2) empty dependency  // 仅在组件加载时执行一次  useEffect(() =\u0026gt; { console.log(\u0026#39;EMPTY: useEffect called\u0026#39;); }, []); // (3) strict dependency  // 组件加载时执行一次  // 仅在依赖项发生变化时，才会执行  useEffect(() =\u0026gt; { console.log(\u0026#39;STRICT: useEffect called\u0026#39;); }, [count]); return ( \u0026lt;div\u0026gt; \u0026lt;h4\u0026gt;4.1 UseEffict 依赖项行为差异\u0026lt;/h4\u0026gt; {/* \u0026lt;span\u0026gt;Count: {count}, Trigger: {trigger}\u0026lt;/span\u0026gt; */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Count\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setTrigger(trigger + 1)}\u0026gt;trigger\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } ","description":"2. 不同依赖项的不同渲染行为     不同状态 的数组影响第一参数函数的执行。 1. 数据被省略时： 在组件加载时执行， 且在任意渲染时执行。 2. 数组为空时： 仅在组件加载时执行 （仅执行一次）。 3. 数组中有依赖项时： 在组件加载时执行， 且在 仅在依赖项变化时触发的渲染时执行\n 在 /src/components/hooks/UseEffectDependencies.jsx 中\nimport { useState, useEffect } from \u0026#34;react\u0026#34;; export default function UseEffectDependencies() { const [count, setCount] = useState(0) const [trigger, setTrigger] = useState(0) // (1) none dependency  // 组件加载时，执行一次  // 无依赖项，每次组件更新时，都会执行  useEffect(() =\u0026gt; { console.log(\u0026#39;NONE: useEffect called\u0026#39;); }); // (2) empty dependency  // 仅在组件加载时执行一次  useEffect(() =\u0026gt; { console."},{"id":52,"href":"/books/react/javascript/introduce/position/","title":"2. 书写位置","parent":"1. 入门简介","content":"书写位置包括以下三部分\n 1. 内部     在 html body 内部书写， 使用 script 标签包裹。 通常写在最后， 即 \u0026lt;/body\u0026gt; 的前方，以便在 script 中获取 html 中的元素信息。\n 注意: 将 \u0026lt;script\u0026gt; 放到 HTML文件底部 附近时因为浏览器会按照代码在文件中的位置 顺序加载。 如果加载的 script 期望修改器下方的 HTML 元素，那么就因为因为元素为被加载而失败。 因此 将 js 代码放在 HTML 页面底附近通常是最好的策略。\n 2. 外部     即 引用js文件。\n head 中引用： 公共库一般放在这里。 body 中引用： 自己写的一般放在这里， 位置参考 内部script  注意: 闭合标签中不在写其他内容。\n\u0026lt;head\u0026gt; \u0026lt;script src=\u0026#34;http://cdn.example.com/jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;name\u0026#34;\u0026gt;点我\u0026lt;/button\u0026gt; \u0026lt;script src=\u0026#34;./position.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 3. 内联     写在元素内部， 属性 的位置\n\u0026lt;body\u0026gt; \u0026lt;!-- 3. 内联 --\u0026gt; \u0026lt;botton onclick=\u0026#34;alert(\u0026#39;内联 js\u0026#39;)\u0026#34;\u0026gt;内联\u0026lt;/botton\u0026gt; \u0026lt;/body\u0026gt; demo     position.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;1.2. 书写位置\u0026lt;/title\u0026gt; \u0026lt;!-- 2.1. 外部 --\u0026gt; \u0026lt;script src=\u0026#34;http://cdn.example.com/position.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 2.2. 外部 --\u0026gt; \u0026lt;script src=\u0026#34;./position.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 1. 内部  console.log(\u0026#39;script标签可以放在body标签内部\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;!-- 3. 内联 --\u0026gt; \u0026lt;botton onclick=\u0026#34;alert(\u0026#39;内联 js\u0026#39;)\u0026#34;\u0026gt;内联\u0026lt;/botton\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","description":"书写位置包括以下三部分\n 1. 内部     在 html body 内部书写， 使用 script 标签包裹。 通常写在最后， 即 \u0026lt;/body\u0026gt; 的前方，以便在 script 中获取 html 中的元素信息。\n 注意: 将 \u0026lt;script\u0026gt; 放到 HTML文件底部 附近时因为浏览器会按照代码在文件中的位置 顺序加载。 如果加载的 script 期望修改器下方的 HTML 元素，那么就因为因为元素为被加载而失败。 因此 将 js 代码放在 HTML 页面底附近通常是最好的策略。\n 2. 外部     即 引用js文件。\n head 中引用： 公共库一般放在这里。 body 中引用： 自己写的一般放在这里， 位置参考 内部script  注意: 闭合标签中不在写其他内容。\n\u0026lt;head\u0026gt; \u0026lt;script src=\u0026#34;http://cdn.example.com/jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;name\u0026#34;\u0026gt;点我\u0026lt;/button\u0026gt; \u0026lt;script src=\u0026#34;."},{"id":53,"href":"/books/react/react/events/","title":"2. 事件绑定","parent":"10. React","content":"","description":""},{"id":54,"href":"/books/react/css/pseudo-class-selector/","title":"2. 伪类选择器","parent":"5. CSS","content":"伪类(pseudo class) 即 类所处的一种状体。 使用 冒号 : 连接 类 与 状态\na:link { color: green; } div:hover{ font-size: 30px; } 常见的状态有 (lvha), 效果与定义顺序有关系。\n link : (\u0026lt;a\u0026gt; 特有属性) 表示 未访问过的 链接状态。 visited: (\u0026lt;a\u0026gt; 特有属性) 表示 访问过的 链接状态。 hover: 通用属性， 表示 鼠标悬浮 时的状态。 active: 通用属性， 表示 鼠标点击但未抬起 时的状体。  ","description":"伪类(pseudo class) 即 类所处的一种状体。 使用 冒号 : 连接 类 与 状态\na:link { color: green; } div:hover{ font-size: 30px; } 常见的状态有 (lvha), 效果与定义顺序有关系。\n link : (\u0026lt;a\u0026gt; 特有属性) 表示 未访问过的 链接状态。 visited: (\u0026lt;a\u0026gt; 特有属性) 表示 访问过的 链接状态。 hover: 通用属性， 表示 鼠标悬浮 时的状态。 active: 通用属性， 表示 鼠标点击但未抬起 时的状体。  "},{"id":55,"href":"/books/react/demos/redux-meituan/initial-store/","title":"2. 使用 redux 管理数据","parent":"2. Redux 案例 - 美团","content":"1. 创建 takeaway slice     在 /src/demos/redux-meituan/store/modules/takeaway.js\n 使用 @reduxjs/toolkit 提供的 createSlice 创建 state 对象 并导出 reducer  import { createSlice } from \u0026#39;@reduxjs/toolkit\u0026#39; import { defaultFoodsList } from \u0026#39;./default\u0026#39; const takeaway = createSlice({ // 名称  name: \u0026#39;takeaway\u0026#39;, // 初始数据  initialState: { foodsList: defaultFoodsList, }, // actions  reducers: { } }) // 导出 reducer 在 store/index.js 中合并 const takeawayReducer = takeaway.reducer export default takeawayReducer 初始化 foodsList 的时候使用了 精简版 的默认值， 保证数据解构完整性。 以避免从服务器获取数据失败时的渲染报错。\n// 设置默认数据， 避免数据为空时异常 const defaultFoodsList = [ { \u0026#34;tag\u0026#34;: \u0026#34;318569657\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;一人套餐\u0026#34;, \u0026#34;foods\u0026#34;: [ { \u0026#34;id\u0026#34;: 8078956697, \u0026#34;name\u0026#34;: \u0026#34;烤羊肉串(10串)\u0026#34;, \u0026#34;like_ratio_desc\u0026#34;: \u0026#34;好评度100%\u0026#34;, \u0026#34;month_saled\u0026#34;: 40, \u0026#34;unit\u0026#34;: \u0026#34;10串\u0026#34;, \u0026#34;food_tag_list\u0026#34;: [\u0026#34;点评网友推荐\u0026#34;], \u0026#34;price\u0026#34;: 90, \u0026#34;picture\u0026#34;: \u0026#34;https://zqran.gitee.io/images/waimai/8078956697.jpg\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;318569657\u0026#34; } ] } ] export { defaultFoodsList } 2. 创建 store     在 /src/demos/redux-meituan/store/index.js 中\n 使用 @reduxjs/toolkit 提供的 configureStore 创建 store 并导出  import { configureStore } from \u0026#34;@reduxjs/toolkit\u0026#34; import takeawayReducer from \u0026#39;./modules/takeaway\u0026#39; const store = configureStore({ reducer: { takeaway: takeawayReducer } }) export default store 3. 使用 Provider 提供 store     创建 入口组件 /src/demos/redux-meituan/index.jsx\n使用 react-redux 提供的 Provider 提供 store\nimport { Provider } from \u0026#39;react-redux\u0026#39; import ReduxMeituan from \u0026#39;./ReduxMeituan\u0026#39; import store from \u0026#39;./store\u0026#39; export default function RootReduxMeituan() { return ( \u0026lt;div\u0026gt; \u0026lt;Provider store={store}\u0026gt; \u0026lt;ReduxMeituan /\u0026gt; \u0026lt;/Provider\u0026gt; \u0026lt;/div\u0026gt; ) } 4. 使用 useSelector 获取 store 数据     在 /src/demos/redux-meituan/ReduxMeituan.jsx 中\n使用 useSelector 解构 reducer 中提供的 foodsList 数据。 并删除原来静态定义的 foodsList。\n// const foodsList = []  const ReduxMeituan = () =\u0026gt; { const { foodsList } = useSelector(state =\u0026gt; state.takeaway) // 省略... }  5. 创建 thunk 异步函数从服务端获取数据     在 /src/demos/redux-meituan/store/modules/takeaway.js 中，\n 添加 reducer 的 action 方法 setFoodsList 并创建 thunk 异步函数， 使用 dispatch 触发修改 使用 axios 从 json-server 获取数据  import axios from \u0026#39;axios\u0026#39; import { takeawayURL } from \u0026#39;../../mock/index\u0026#39; const takeaway = createSlice({ // ...省略  // actions  reducers: { setFoodsList: (state, action) =\u0026gt; { state.foodsList = action.payload } } }) // 2. 创建异步 thunk 获取数据 const { setFoodsList } = takeaway.actions const getFoodsList = () =\u0026gt; { return async (dispatch) =\u0026gt; { // 异步请求 不再返回 resp  await axios .get(takeawayURL) // 直接在 .then 中进行正常逻辑处理  .then( resp =\u0026gt; { // console.log(\u0026#39;resp\u0026#39;, resp);  // return resp  dispatch(setFoodsList(resp.data)) } ) // 使用 .catch 捕获异常  .catch( err =\u0026gt; console.log(\u0026#39;err\u0026#39;, err) ); // 未处理网络错误代码  // const resp = await axios.get(url)  // console.log(\u0026#39;resp\u0026#39;, resp);  // // dispatch action  // if (resp?.status === 200) {  // dispatch(setFoodsList(resp.data))  // }  } } export { getFoodsList } export { getFoodsList } 6. 使用 useDispatch 修改 store 数据     在 /src/demos/redux-meituan/ReduxMeituan.jsx 中\n 使用 useEffect 实现在页面加载时触发数据获取动作。 使用 react-redux 提供的 useDispatch 触发 store 的数据修改行为  import { useDispatch } from \u0026#39;react-redux\u0026#39; import { getFoodsList } from \u0026#39;./store/modules/takeaway\u0026#39; import { useEffect } from \u0026#39;react\u0026#39; const ReduxMeituan = () =\u0026gt; { // 使用 useSelector 获取 store 数据  const { foodsList } = useSelector(state =\u0026gt; state.takeaway) // 使用 dispatch 修改 store 数据  const dispatch = useDispatch() useEffect(() =\u0026gt; { dispatch(getFoodsList()) }, [dispatch]) // 省略... }  7. 使用 store 数据修改 Menu 菜单     在 /src/demos/redux-meituan/components/Menu/index.js 中\n 使用 useSelector 从 state.takeaway 中获取数据 并替换原来的 foodsList 即可。  import { useSelector } from \u0026#39;react-redux\u0026#39; const Menu = () =\u0026gt; { // 删除  // const foodsList = []  // 使用 useSelector 获取 store 中的数据  const { foodsList } = useSelector(state =\u0026gt; state.takeaway) } ","description":"1. 创建 takeaway slice     在 /src/demos/redux-meituan/store/modules/takeaway.js\n 使用 @reduxjs/toolkit 提供的 createSlice 创建 state 对象 并导出 reducer  import { createSlice } from \u0026#39;@reduxjs/toolkit\u0026#39; import { defaultFoodsList } from \u0026#39;./default\u0026#39; const takeaway = createSlice({ // 名称  name: \u0026#39;takeaway\u0026#39;, // 初始数据  initialState: { foodsList: defaultFoodsList, }, // actions  reducers: { } }) // 导出 reducer 在 store/index.js 中合并 const takeawayReducer = takeaway.reducer export default takeawayReducer 初始化 foodsList 的时候使用了 精简版 的默认值， 保证数据解构完整性。 以避免从服务器获取数据失败时的渲染报错。"},{"id":56,"href":"/books/react/javascript/variables/","title":"2. 变量","parent":"2. JavaScript","content":"","description":""},{"id":57,"href":"/books/react/react/communication/zustand/multiple/","title":"2. 多状态管理","parent":"4. zustand","content":"1. 切片模式      https://www.bilibili.com/video/BV1ZB4y1Z7o8?p=145\n import { create } from \u0026#39;zustand\u0026#39; // 创建counter相关切片 const createCounterStore = (set) =\u0026gt; { return { count: 0, setCount: () =\u0026gt; { set(state =\u0026gt; ({ count: state.count + 1 })) } } } // 创建channel相关切片 const createChannelStore = (set) =\u0026gt; { return { channelList: [], fetchGetList: async () =\u0026gt; { const res = await fetch(URL) const jsonData = await res.json() set({ channelList: jsonData.data.channels }) } } } // 组合切片 const useStore = create((...a) =\u0026gt; ({ ...createCounterStore(...a), ...createChannelStore(...a) })) function App() { const {count, inc, channelList, fetchChannelList } = useStore() return ( \u0026lt;\u0026gt; \u0026lt;button onClick={inc}\u0026gt;{count}\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; {channelList.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/\u0026gt; ) } 2. 多状态模式（我自己取的名字）     相比切片模式， 我觉得 定义多个状态更方便 。\nimport { create } from \u0026#34;zustand\u0026#34; // 定义第一个状态 const useCountStore = create(set =\u0026gt; ( { count: 100, add1: (payload) =\u0026gt; set((state) =\u0026gt; ({ count: state.count + payload })), } )) // 定义第二个状态 const useNumberStore = create(set =\u0026gt; ( { number: 200, add1: (payload) =\u0026gt; set((state) =\u0026gt; ({ number: state.number + payload })), } )) export default () =\u0026gt; { // 使用第一个状态  const { count, add1 } = useCountStore() // 使用第二个状态。 同名方法冲突，使用别名  const { number, add1: addNumber1 } = useNumberStore() return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;7.6.3. zustand 多个状态\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;{count}\u0026lt;/h4\u0026gt; \u0026lt;button onClick={() =\u0026gt; add1(1)}\u0026gt;Count +1\u0026lt;/button\u0026gt; \u0026lt;h4\u0026gt;{number}\u0026lt;/h4\u0026gt; \u0026lt;button onClick={() =\u0026gt; addNumber1(1)}\u0026gt;Number +1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } ","description":"1. 切片模式      https://www.bilibili.com/video/BV1ZB4y1Z7o8?p=145\n import { create } from \u0026#39;zustand\u0026#39; // 创建counter相关切片 const createCounterStore = (set) =\u0026gt; { return { count: 0, setCount: () =\u0026gt; { set(state =\u0026gt; ({ count: state.count + 1 })) } } } // 创建channel相关切片 const createChannelStore = (set) =\u0026gt; { return { channelList: [], fetchGetList: async () =\u0026gt; { const res = await fetch(URL) const jsonData = await res.json() set({ channelList: jsonData."},{"id":58,"href":"/books/react/react/components/define-component/","title":"2. 如何定义组件","parent":"3. 组件","content":"组件的定义方式有两种。\n 函数式组件： 最常用 类式组件  组件名通常使用 大驼峰 命名方式， 即 首字母大写的驼峰\n例如， MyButton, UserInfoDisplay\n1. 组件的定义     1.1. 函数式组件     在 /src/components/component/FuncComponent.js 中\nfunction FunctionButtion() { return ( \u0026lt;button\u0026gt;function buttion\u0026lt;/button\u0026gt; ) } export default FunctionButtion; 1.2. 箭头函数式组件     箭头函数也是函数， 所以和上面 function 定义没什么区别。 也在 /src/components/component/FuncComponent.js 中\nexport const ArrowFuncButtion = () =\u0026gt; { return ( \u0026lt;button\u0026gt;arrow func button\u0026lt;/button\u0026gt; ) } 1.3. 类式组件     这个有有点特别了， 在 React 18 中， 已经不怎么用了。\n在 /src/components/component/ClassComponent.js 中\n 必须要 import React 创建的类要 继承 自 React.Component 必须存在 类方法 render。 render 最终返回一对 标签， 与 函数式组件 一样了。  // 必须要引入 React import React from \u0026#34;react\u0026#34;; // 1. 创建类式组件 class MyClassComponent extends React.Component { // 1. 构建函数 「不是必须存在」  // 2. render 必须存在  // render 是放在哪里的？ -- MyClassComponent 类 的原型对象上， 供实例使用。  // render 中的 this 是谁？ -- MyClassComponent 的实例对象。  render() { console.log(this); return ( \u0026lt;button\u0026gt;class component\u0026lt;/button\u0026gt; ) } } export default MyClassComponent; 2. 组件的导出     同一文件中的组件是可以互相引用的。 如果允许组件被外部引用， 则需要使用 export 关键字。\n 每个文件 最多只有一个 export default。 最少可以没有， 及没有默认导出。 参考  FunctionComponent MyClassComponenet   如果有其他组件还需要导出， 则可以在定义的所在位置使用 export 关键字  参考 ArrowFuncComponenet    3. 组件的引用     在 /src/components/component/RootComponent.js 中\n组件的使用， 与 标准HTML标签 的使用方式一样。\n 自闭和标签 成对标签  import MyClassComponent from \u0026#34;./ClassComponent\u0026#34; import FunctionButtion, { ArrowFuncButtion } from \u0026#34;./FuncComponent\u0026#34;; function RootComponent() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;4. 组件的定义和使用\u0026lt;/h2\u0026gt; {/* 组件的使用 {/* 1. 自闭和标签 */} \u0026lt;FunctionButtion /\u0026gt; {/* 2. 成对标签 */} \u0026lt;ArrowFuncButtion\u0026gt;\u0026lt;/ArrowFuncButtion\u0026gt; {/* 引用外部文件组件 */} \u0026lt;MyClassComponent /\u0026gt; \u0026lt;/div\u0026gt; ) } 在使用标签之前， 需要确定标签是否被引用到本文件。\n  如果 当前组件(RootComponenet) 与 被引用组件 在同一个文件中， 不需要使用 import\n  如果 被引用组件 是 默认导出组件， 则直接 import\n  import FunctionButtion from \u0026#34;./FuncComponent\u0026#34;; 如果 被引用组件 是 非默认导出组件， 则需要使用 花括号{} 包裹引用组件名。  import { ArrowFuncButtion } from \u0026#34;./FuncComponent\u0026#34;; 如果一个文件有多个组件被引用， 可以合并写在一行  import FunctionButtion, { ArrowFuncButtion, OtherButton } from \u0026#34;./FuncComponent\u0026#34;; 默认导出组件名 可以与其 所在文件名 不同。  import MyClassComponent from \u0026#34;./ClassComponent\u0026#34; ","description":"组件的定义方式有两种。\n 函数式组件： 最常用 类式组件  组件名通常使用 大驼峰 命名方式， 即 首字母大写的驼峰\n例如， MyButton, UserInfoDisplay\n1. 组件的定义     1.1. 函数式组件     在 /src/components/component/FuncComponent.js 中\nfunction FunctionButtion() { return ( \u0026lt;button\u0026gt;function buttion\u0026lt;/button\u0026gt; ) } export default FunctionButtion; 1.2. 箭头函数式组件     箭头函数也是函数， 所以和上面 function 定义没什么区别。 也在 /src/components/component/FuncComponent.js 中\nexport const ArrowFuncButtion = () =\u0026gt; { return ( \u0026lt;button\u0026gt;arrow func button\u0026lt;/button\u0026gt; ) } 1.3. 类式组件     这个有有点特别了， 在 React 18 中， 已经不怎么用了。"},{"id":59,"href":"/books/react/javascript/data-types/string/","title":"2. 字符串","parent":"3. 数据类型","content":" string - MDN\n 1. 字符串     字符串 所有使用以下引号包括的内容就是\n单引号: ' 双引号: \u0026quot; 反引号: ` 例如\nconst a = `abc` const b = \u0026#34;abc123\u0026#34; const c = \u0026#39;123\u0026#39; 2. 模版字符串     只有在 反引号 中要在字符串才是 模版字符串说， 因此其中 变量 或 表达式 才会生效\n// 只有反引号(`)才能使用模板字符串 console.log(`a=${a}`); // a=abc console.log(\u0026#39;b=${b}\u0026#39;); // b=${b} console.log(\u0026#34;c=${c}\u0026#34;); // c=${c} 3. 字符串的拼接     字符串的拼接出了用 模版字符串 之外，\n还可以使用 连接符 +, 直接使用 变量名 即可。\nconsole.log(a + b); // abcabc123 console.log(a + c); // abc123 console.log(a + 10); // abc10 console.log(a + 10 + 20); // abc1020 console.log(a + (10 + 20)); // abc30 console.log(10 + a); // 10abc  console.log(a + true); // abctrue console.log(a + [1, 2, 3]); // abc1,2,3 console.log(a + { name: \u0026#39;abc\u0026#39; }); // abc[object Object]  console.log(a + null); // abcnull console.log(a + undefined); // abcundefined console.log(a + NaN); // abcNaN console.log(a + Infinity); // abcInfinity 4. 字符串比较大小     字符串可以 按位 进行比较大小， 使用 ASCII 对应的数字比较。\nconsole.log(\u0026#39;a\u0026#39; \u0026gt; \u0026#39;b\u0026#39;); // false console.log(\u0026#39;a\u0026#39; \u0026gt; \u0026#39;A\u0026#39;); // true console.log(\u0026#39;a\u0026#39; \u0026gt; \u0026#39;1\u0026#39;); // true console.log(\u0026#39;a\u0026#39; === \u0026#39;a\u0026#39;); // true console.log(\u0026#39;aa\u0026#39; \u0026lt; \u0026#39;ab\u0026#39;); // true 字符串与其他类型数据比较， 结果各有不同。\n 有些比较结果都是 false 有些比较可以 true 和 false  console.log(\u0026#39;a\u0026#39; \u0026gt; 10); // false console.log(\u0026#39;a\u0026#39; \u0026lt; 10); // true  console.log(\u0026#39;a\u0026#39; \u0026lt; true); // false console.log(\u0026#39;a\u0026#39; \u0026gt; true); // false  console.log(\u0026#39;a\u0026#39; \u0026gt; [1, 2, 3]); // true console.log(\u0026#39;a\u0026#39; \u0026gt; { name: \u0026#39;abc\u0026#39; }); // true  console.log(\u0026#39;a\u0026#39; \u0026gt; null); // true console.log(\u0026#39;a\u0026#39; \u0026lt; null); // false  console.log(\u0026#39;a\u0026#39; \u0026gt; undefined); // false console.log(\u0026#39;a\u0026#39; \u0026lt; undefined); // false  console.log(\u0026#39;a\u0026#39; \u0026gt; NaN); // false console.log(\u0026#39;a\u0026#39; \u0026lt; NaN); // false  console.log(\u0026#39;a\u0026#39; \u0026gt; Infinity); // false console.log(\u0026#39;a\u0026#39; \u0026lt; Infinity); // true 5. 转换成 number     字符串可以通过以下方法转换成 number, 前提是 字符串字面量 符合 number 规则。\n// string 转换成 number console.log(Number(\u0026#39;123\u0026#39;)); // 123 console.log(Number(\u0026#39;123.456\u0026#39;)); // 123.456 console.log(Number(\u0026#39;\u0026#39;)); // 0 console.log(Number(\u0026#39; \u0026#39;)); // 0 console.log(parseInt(\u0026#39;100.123\u0026#39;));// 100 console.log(parseFloat(\u0026#39;100.123\u0026#39;));// 100.123  // 正号(+)转换成 number console.log(+\u0026#34;123\u0026#34;); // 123 console.log(+\u0026#34;123.456\u0026#34;); // 123.456  // 非法number console.log(Number(\u0026#39;123.456.789\u0026#39;)); // NaN console.log(Number(\u0026#39;123px\u0026#39;)); // NaN console.log(Number(\u0026#39;px123\u0026#39;)); // NaN ","description":"string - MDN\n 1. 字符串     字符串 所有使用以下引号包括的内容就是\n单引号: ' 双引号: \u0026quot; 反引号: ` 例如\nconst a = `abc` const b = \u0026#34;abc123\u0026#34; const c = \u0026#39;123\u0026#39; 2. 模版字符串     只有在 反引号 中要在字符串才是 模版字符串说， 因此其中 变量 或 表达式 才会生效\n// 只有反引号(`)才能使用模板字符串 console.log(`a=${a}`); // a=abc console.log(\u0026#39;b=${b}\u0026#39;); // b=${b} console.log(\u0026#34;c=${c}\u0026#34;); // c=${c} 3. 字符串的拼接     字符串的拼接出了用 模版字符串 之外，\n还可以使用 连接符 +, 直接使用 变量名 即可。"},{"id":60,"href":"/books/react/javascript/variables/constant/","title":"2. 常量","parent":"2. 变量","content":"常量特点： 常量是不可改变的 变量\n 常量使用 const 关键字定义 常量不可被重复赋值。  但如果常量是引用类型(数组/对象), 则其字段可以被修改。   其他方便 与变量一致  1. 常量的定义     // 定义常量， 简单类型 const a = 100 console.log(a) // 100  // 重新复制 // a = 200 // Error: Assignment to constant variable.  // 定义常量， 引用类型（对象） const b = { name: \u0026#34;zhangsan\u0026#34; } // 可以 修改对象值 b.name = \u0026#34;lisi\u0026#34; console.log(b.name) // lisi  // 不可以 重新赋值一个新对象 // b = { name: \u0026#34;wangwu\u0026#34; } // Error: Assignment to constant variable.  // 定义常量， 引用类型（数组） const c = [1, 2, 3] // 修改 c.push(4) c[1] = 5 console.log(c) // [ 1, 5, 3, 4 ] ","description":"常量特点： 常量是不可改变的 变量\n 常量使用 const 关键字定义 常量不可被重复赋值。  但如果常量是引用类型(数组/对象), 则其字段可以被修改。   其他方便 与变量一致  1. 常量的定义     // 定义常量， 简单类型 const a = 100 console.log(a) // 100  // 重新复制 // a = 200 // Error: Assignment to constant variable.  // 定义常量， 引用类型（对象） const b = { name: \u0026#34;zhangsan\u0026#34; } // 可以 修改对象值 b.name = \u0026#34;lisi\u0026#34; console.log(b.name) // lisi  // 不可以 重新赋值一个新对象 // b = { name: \u0026#34;wangwu\u0026#34; } // Error: Assignment to constant variable."},{"id":61,"href":"/books/react/react/communication/props/parent-to-children/","title":"2. 父传子通信","parent":"1. props 通信","content":"/src/components/communication/Parent2Children.jsx\n实现步骤\n 传递数据: 父组件 在 子组件 上 绑定属性 接收数据: 子组件 使用 props 参数接收数据。   function Parent() { const name = \u0026#34;Zhangsan\u0026#34;; const age = 18; return ( \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;Parent Area: \u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;name=Zhangsan, age=18\u0026lt;/span\u0026gt; {/* 1. 通过属性给 Child 传递数据 */} \u0026lt;Child name={name} age={age} /\u0026gt; \u0026lt;/div\u0026gt; ); } // 2. 定义的时候， 使用 props 接收参数 function Child(props) { // 打印所有 props  console.log(props); return ( \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;Child Area: \u0026lt;/span\u0026gt; {/* 3. 使用的时候， 使用 props.name 接收。 name 则是传递过来的属性名 */} \u0026lt;span\u0026gt;name: {props.name}, age: {props.age}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ); } ","description":"/src/components/communication/Parent2Children.jsx\n实现步骤\n 传递数据: 父组件 在 子组件 上 绑定属性 接收数据: 子组件 使用 props 参数接收数据。   function Parent() { const name = \u0026#34;Zhangsan\u0026#34;; const age = 18; return ( \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;Parent Area: \u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;name=Zhangsan, age=18\u0026lt;/span\u0026gt; {/* 1. 通过属性给 Child 传递数据 */} \u0026lt;Child name={name} age={age} /\u0026gt; \u0026lt;/div\u0026gt; ); } // 2. 定义的时候， 使用 props 接收参数 function Child(props) { // 打印所有 props  console.log(props); return ( \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;Child Area: \u0026lt;/span\u0026gt; {/* 3. 使用的时候， 使用 props."},{"id":62,"href":"/books/react/javascript/func-class/arrow-func/","title":"2. 箭头函数","parent":"5. 函数和类","content":"Arrow functions\n箭头函数用法和 function 函数一样。\n就是定义方式多了那么一点点。 主要集中在 (), {} 是否省略的问题上\n() =\u0026gt; expression param =\u0026gt; expression (param) =\u0026gt; expression (param1, paramN) =\u0026gt; expression () =\u0026gt; { statements } param =\u0026gt; { statements } (param1, paramN) =\u0026gt; { statements } 箭头函数的 this     箭头函数的 this 是一个难点。 需要继续研读文档。\n","description":"Arrow functions\n箭头函数用法和 function 函数一样。\n就是定义方式多了那么一点点。 主要集中在 (), {} 是否省略的问题上\n() =\u0026gt; expression param =\u0026gt; expression (param) =\u0026gt; expression (param1, paramN) =\u0026gt; expression () =\u0026gt; { statements } param =\u0026gt; { statements } (param1, paramN) =\u0026gt; { statements } 箭头函数的 this     箭头函数的 this 是一个难点。 需要继续研读文档。"},{"id":63,"href":"/books/react/react/router/navigate/","title":"2. 路由导航","parent":"6. React-Router","content":"使用 路由导航 可以在不同组件之间切换。\n创建两个组件 Login 和 Article。 目录结构如下。\n 统一 import 到 RootRouter 下管理， 对应的 router 也需要做调整。\nimport { createBrowserRouter, RouterProvider } from \u0026#34;react-router-dom\u0026#34;; import Login from \u0026#34;./Login\u0026#34;; import Article from \u0026#34;./Article\u0026#34;; const router = createBrowserRouter([ { path: \u0026#34;/login\u0026#34;, element: \u0026lt;Login /\u0026gt; // 登录 Login  }, { path: \u0026#34;/article\u0026#34;, element: \u0026lt;Article /\u0026gt; // 文章 Article  } ]) export default function RootRouter() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;8. 路由页面 Root Page\u0026lt;/h2\u0026gt; \u0026lt;RouterProvider router={router} /\u0026gt; \u0026lt;/div\u0026gt; ); }  声明式导航     声明式导航: 是指通过在模版中使用 \u0026lt;Link /\u0026gt; 组件描述出要跳转到哪里去。 比如后台管理系统的左侧菜单通常使用这种方式进行。\n在文章页面 /src/components/router/Article/index.jsx 中使用 声明式导航\nimport { Link } from \u0026#34;react-router-dom\u0026#34;; export default function Article() { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;8.2 文章页面\u0026lt;/h3\u0026gt; {/* 声明路由 */} {/* to 是固定字段 */} {/* /login 是要跳转的页面 */} \u0026lt;Link to=\u0026#34;/login\u0026#34;\u0026gt;点击登录\u0026lt;/Link\u0026gt; \u0026lt;p\u0026gt;文章页面\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } 语法说明： 通过给组件 to 属性 指定要跳转的 路由 path， 组件会被渲染为浏览器支持的 a 链接。 如果需要传参数， 则可以通过 字符串拼接 的方式。\n编程式导航     编程式导航 是指通过 useNavigate 钩子得到 导航方法， 然后通过调用方法 以命令的形式 进行路由跳转。\n比如想在登录请求完毕之后跳转到某个页面， 就可以使用这种方法， 更加灵活。\n在登录页面 /src/components/router/Login/index.jsx 中使用 编程式导航。\nimport { useNavigate } from \u0026#34;react-router-dom\u0026#34;; export default function Login() { // 通过 useNavigate 获取导航函数  const navigate = useNavigate(); return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;8.1 登录页面\u0026lt;/h3\u0026gt; {/* 点击跳转到页面 */} \u0026lt;button onClick={() =\u0026gt; navigate(\u0026#39;/article\u0026#39;)}\u0026gt;跳转到文章页\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;登录页面\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } 语法说明： 通过调用 navigate 方法传入 path 实现跳转。\n","description":"使用 路由导航 可以在不同组件之间切换。\n创建两个组件 Login 和 Article。 目录结构如下。\n 统一 import 到 RootRouter 下管理， 对应的 router 也需要做调整。\nimport { createBrowserRouter, RouterProvider } from \u0026#34;react-router-dom\u0026#34;; import Login from \u0026#34;./Login\u0026#34;; import Article from \u0026#34;./Article\u0026#34;; const router = createBrowserRouter([ { path: \u0026#34;/login\u0026#34;, element: \u0026lt;Login /\u0026gt; // 登录 Login  }, { path: \u0026#34;/article\u0026#34;, element: \u0026lt;Article /\u0026gt; // 文章 Article  } ]) export default function RootRouter() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;8. 路由页面 Root Page\u0026lt;/h2\u0026gt; \u0026lt;RouterProvider router={router} /\u0026gt; \u0026lt;/div\u0026gt; ); }  声明式导航     声明式导航: 是指通过在模版中使用 \u0026lt;Link /\u0026gt; 组件描述出要跳转到哪里去。 比如后台管理系统的左侧菜单通常使用这种方式进行。"},{"id":64,"href":"/books/react/javascript/data-types/number/bigint/","title":"3. BigInt","parent":"1. 数字","content":"","description":""},{"id":65,"href":"/books/react/setup/chrome/","title":"3. Chrome","parent":"1. 环境配置","content":"Chrome 插件      React Developer Tools Redux DevTools  ","description":"Chrome 插件      React Developer Tools Redux DevTools  "},{"id":66,"href":"/books/react/react/communication/redux/","title":"3. redux","parent":"5. 组件通信","content":"Redux 是 React 中常用的 技术状态管理工具， 可以独立于 React 运行。\n ","description":"Redux 是 React 中常用的 技术状态管理工具， 可以独立于 React 运行。\n "},{"id":67,"href":"/books/react/react/communication/redux/redux-react-counter/","title":"3. Redux 与 React - 实现 Counter(同步)","parent":"3. redux","content":"先来看一张 Redux 与 React 调用全图。\n  全图左右两个部分， 中间使用 store 关联起来。 左边使用 @reduxjs@toolkit 创建 reducer 管理 store. 右边使用 react-redux 获取数据并修改。   1. 创建 Slice 并初始化 counterReducer     在 /src/store/modules/counterStore.js 创建 reducer 和 actions\n 从 @reduxjs/toolkit 中导入并使用 createSlice 创建 通过 counterSlice.reducer 获取 reducer 并导出。  在 index.js 中引用， 创建 合并reducer   通过 counterSlice.actions 获取 actions 并导出。  在外部代码引用， 使用 useDispatch 调用修改 state 的值。    import { createSlice } from \u0026#39;@reduxjs/toolkit\u0026#39;; const counterSlice = createSlice({ // 设置名称  name: \u0026#39;counter\u0026#39;, // 设置初始状态 state  initialState: { value: 0, }, // 设置修改方法 actions  reducers: { increment: (state) =\u0026gt; { state.value += 1; }, decrement: (state) =\u0026gt; { state.value -= 1; } } }); // 获取并导出 action 对象 const { increment, decrement } = counterSlice.actions; export { increment, decrement }; // 获取并导出 reducer 函数 const counterReducer = counterSlice.reducer; export default counterReducer; 2. 在 index.js 中创建 store     在 /src/store/index.js 中合并 reducers\n 从 @reduxjs/toolkit 中导入并使用 configureStore 创建 store， 合并 reduder。 创建时需要 提供 reducer 对象， 固定名字 不能修改。  使用 counter 作为 counterReducer 的别名。 （这里就有点绕了）   导出 store。  在外部导入， 并使用 Provider 为组件提供 store。    import { configureStore } from \u0026#39;@reduxjs/toolkit\u0026#39;; import counterReducer from \u0026#39;./modules/counterStore\u0026#39;; const store = configureStore({ reducer: { counter: counterReducer }, }); export default store; 3. 父组件使用 Provider 提供 store     在 /src/components/communication/redux/RootReduxReact.jsx 中， 导入 redux state 并为子组件提供\n 从 react-redux 中导入 Provider 使用 Provider 包裹需要使用 redux state 的 父组件  import ReduxCounter from \u0026#34;./ReduxCounter\u0026#34;; import { Provider } from \u0026#34;react-redux\u0026#34;; import store from \u0026#34;../../../store\u0026#34;; export default function RootReduxReact() { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt; 7.5 Redux 与 React\u0026lt;/h3\u0026gt; \u0026lt;Provider store={store}\u0026gt; \u0026lt;ReduxCounter /\u0026gt; \u0026lt;/Provider\u0026gt; \u0026lt;hr\u0026gt;\u0026lt;/hr\u0026gt; \u0026lt;/div\u0026gt; ); } 4. 子组件使用 useSelector 和 useDispatch 获取和操作 reducer state     在 /src/components/communication/redux/ReduxCounter.jsx 获取和操作 reducer state\n  从 react-redux 中导入 useSelector。\n 从 store 中获取对应的的 reducer state. 并通过 解构赋值 拿到 state 对应的 value。    从 react-redux 中导入 useDispatch\n 执行 useDispatch() 获取 dispatch 函数。    方法一： 推荐\n 从对应的 couterStore 中导入对应的 actions， 以备调用。 使用 dispatch 函数调用需要操作的 action 即可。  方法二 是 Github Copilot 自动补全的。 个人觉得并不如 方法一 有关联性\nimport { useSelector, useDispatch } from \u0026#39;react-redux\u0026#39;; // 引入需要被操作的 action import { decrement, increment } from \u0026#39;../../../store/modules/counterStore\u0026#39;; export default function ReduxCounter() { // 有点绕  // reducer 来自 store/index.js 里的 store  // counter 来自 store/index.js 里的 reducer  // value 来自 counter 对应的得 store/modules/counterStore.js 里的 state  const { value } = useSelector(reducer =\u0026gt; reducer.counter); // 执行 useDispatch 获取 dispath 函数  const dispatch = useDispatch(); return ( \u0026lt;div\u0026gt; \u0026lt;h4\u0026gt; 7.5.1 Redux Counter\u0026lt;/h4\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; {/* 写法一： 更推荐 */} {/* 使用 dispatch 调用 action */} \u0026lt;button onClick={() =\u0026gt; dispatch(decrement())}\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;value: {value}\u0026lt;/span\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch(increment())}\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 写法二 */} \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;counter/decrement\u0026#39; })}\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;value: {value}\u0026lt;/span\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;counter/increment\u0026#39; })}\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;hr\u0026gt;\u0026lt;/hr\u0026gt; \u0026lt;/div\u0026gt; ); } 5. 使用 dispatch 提交信息时 action payload 参数      书接上回， 在 /src/store/modules/counterStore.js 中， 添加新的 reducers 行为。\n addMore: 参数 payload 是一个简单值。 addMorePayload: payload 是一个对象。  注意:\n 对应的函数接受参数是 两个， state 和 action。 action.payload 是 固定字段， 不可更改。  如果 payload 是 数组 或者 对象， 则按照其对应类型处理。    const counterSlice = createSlice({ // 设置名称  name: \u0026#39;counter\u0026#39;, // 设置初始状态  initialState: { value: 0, }, // 设置修改方法  reducers: { increment: (state) =\u0026gt; { state.value += 1; }, decrement: (state) =\u0026gt; { state.value -= 1; }, // 支持多个参数  addMore: (state, action) =\u0026gt; { state.value += action.payload }, // action.payload 是固定字段  // 如果要传递多个值， payload 可以是对象或者数组  addMorePayload: (state, action) =\u0026gt; { state.value += action.payload.value } } }); // 导出 addMore const { addMore, addMorePayload } = counterSlice.actions; export { addMore, addMorePayload } 回到 /src/components/communication/redux/ReduxCounter.jsx 中。\n在调用 addMore 和 addMorePayload 的时候 有一个参数传递\nimport { useSelector, useDispatch } from \u0026#39;react-redux\u0026#39;; // 引入需要被操作的 action import { addMore, addMorePayload } from \u0026#39;../../../store/modules/counterStore\u0026#39;; export default function ReduxCounter() { const { value } = useSelector(reducer =\u0026gt; reducer.counter); // 执行 useDispatch 获取 dispath 函数  const dispatch = useDispatch(); // 为 addMorePayload 定义 payload 对象  const payload = { \u0026#34;value\u0026#34;: 10, } return ( \u0026lt;div\u0026gt; \u0026lt;h4\u0026gt; 7.5.1 Redux Counter\u0026lt;/h4\u0026gt; \u0026lt;div\u0026gt; {/* 使用 dispatch 调用 action */} \u0026lt;button onClick={() =\u0026gt; dispatch(decrement())}\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;value: {value}\u0026lt;/span\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch(increment())}\u0026gt;+\u0026lt;/button\u0026gt; {/* 注意: 这里 addMore 传递的 payload 是一个值 */} \u0026lt;button onClick={() =\u0026gt; dispatch(addMore(10))}\u0026gt; payload=+10 \u0026lt;/button\u0026gt; {/* 注意: 传递的 payload 是一个对象 */} \u0026lt;button onClick={() =\u0026gt; dispatch(addMorePayload(payload))}\u0026gt; payload.value=+10 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } ","description":"先来看一张 Redux 与 React 调用全图。\n  全图左右两个部分， 中间使用 store 关联起来。 左边使用 @reduxjs@toolkit 创建 reducer 管理 store. 右边使用 react-redux 获取数据并修改。   1. 创建 Slice 并初始化 counterReducer     在 /src/store/modules/counterStore.js 创建 reducer 和 actions\n 从 @reduxjs/toolkit 中导入并使用 createSlice 创建 通过 counterSlice.reducer 获取 reducer 并导出。  在 index.js 中引用， 创建 合并reducer   通过 counterSlice.actions 获取 actions 并导出。  在外部代码引用， 使用 useDispatch 调用修改 state 的值。    import { createSlice } from \u0026#39;@reduxjs/toolkit\u0026#39;; const counterSlice = createSlice({ // 设置名称  name: \u0026#39;counter\u0026#39;, // 设置初始状态 state  initialState: { value: 0, }, // 设置修改方法 actions  reducers: { increment: (state) =\u0026gt; { state."},{"id":68,"href":"/books/react/demos/account-book/","title":"3. Redux-Router 案例: 账本","parent":"99. 项目案例","content":"","description":""},{"id":69,"href":"/books/react/typescript/","title":"3. TypeScript","parent":"","content":"Books      Typescript Book: 实用技巧， 类型扩展。 TypeScript 速通笔记 - 尚硅谷 禹神梳理，2小时上手TS（TypeScript） - 尚硅谷  Videos      禹神：三小时快速上手 TypeScript 速通教程 - 尚硅谷   Typescript 上: 基本类型 Typescript 中: ?? Typescript 下: 类， 接口 Typescript 装饰器  ","description":"Books      Typescript Book: 实用技巧， 类型扩展。 TypeScript 速通笔记 - 尚硅谷 禹神梳理，2小时上手TS（TypeScript） - 尚硅谷  Videos      禹神：三小时快速上手 TypeScript 速通教程 - 尚硅谷   Typescript 上: 基本类型 Typescript 中: ?? Typescript 下: 类， 接口 Typescript 装饰器  "},{"id":70,"href":"/books/react/react/communication/zustand/zustand-ts/","title":"3. TypeScript 类型支持","parent":"4. zustand","content":"1. 定义      需要使用 interface 指定 state 需要实现的接口 在创建的时候使用 泛型 指定 `create((set)=\u0026gt;{})  import { create } from \u0026#39;zustand\u0026#39;; // 定义参数类型 interface CounterStore { count: number; increment: (payload: number) =\u0026gt; void; set: (payload: number) =\u0026gt; void; } // create\u0026lt;CounterStore\u0026gt; 使用泛型指定 store 的类型 const useCounterStore = create\u0026lt;CounterStore\u0026gt;((set) =\u0026gt; ({ count: 0, // 修改对象，+1  increment: (payload: number) =\u0026gt; set( (state) =\u0026gt; ({ count: state.count + payload }) ), // 直接替换对象  set(payload) { set(() =\u0026gt; ({ count: payload })); } })); export default useCounterStore; 2. 使用     由于这个是 useXXXX 典型的 Hook 命名方式。\n使用时与 useState 类型， 使用 解构赋值 的方式取出 值 和 方法。\nimport useCounterStore from \u0026#34;../../store/counter\u0026#34; export default () =\u0026gt; { const { count, increment } = useCounterStore() return ( \u0026lt;\u0026gt; \u0026lt;h3\u0026gt;Home\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;This is the home page.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Counter: {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; increment(1)}\u0026gt;counter +1\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } ","description":"1. 定义      需要使用 interface 指定 state 需要实现的接口 在创建的时候使用 泛型 指定 `create((set)=\u0026gt;{})  import { create } from \u0026#39;zustand\u0026#39;; // 定义参数类型 interface CounterStore { count: number; increment: (payload: number) =\u0026gt; void; set: (payload: number) =\u0026gt; void; } // create\u0026lt;CounterStore\u0026gt; 使用泛型指定 store 的类型 const useCounterStore = create\u0026lt;CounterStore\u0026gt;((set) =\u0026gt; ({ count: 0, // 修改对象，+1  increment: (payload: number) =\u0026gt; set( (state) =\u0026gt; ({ count: state.count + payload }) ), // 直接替换对象  set(payload) { set(() =\u0026gt; ({ count: payload })); } })); export default useCounterStore; 2."},{"id":71,"href":"/books/react/setup/initalize/vite-src-alias/","title":"3. vite 配置别名","parent":"0. 初始化项目","content":"1. 安装 types/node 支持     $ npm i @types/node 2. 配置 vite 支持别名     这一步是为了 vite 在编译的时候可以使用 @ 别名符号。\n所有 非注释 的内容都是 新增配置\n// vite.config.ts  // import { defineConfig } from \u0026#39;vite\u0026#39; // import react from \u0026#39;@vitejs/plugin-react\u0026#39; import path from \u0026#39;path\u0026#39; // https://vitejs.dev/config/ export default defineConfig({ // plugins: [react()],  resolve: { alias: { \u0026#39;@\u0026#39;: path.resolve(__dirname, \u0026#39;./src\u0026#39;), }, }, }) 3. 配置 VSCode 支持别名     这一步配置是在使用 路径别名 的时候， 为了让 VSCode 支持别名路径， 且显示不报错。\n 并不影响 vite 编译。\n // tsconfig.json { \u0026#34;compilerOptions\u0026#34;: { // 路径别名 \u0026#34;baseUrl\u0026#34;: \u0026#34;.\u0026#34;, \u0026#34;paths\u0026#34;: { \u0026#34;@/*\u0026#34;: [ \u0026#34;src/*\u0026#34; ] }, }, } ","description":"1. 安装 types/node 支持     $ npm i @types/node 2. 配置 vite 支持别名     这一步是为了 vite 在编译的时候可以使用 @ 别名符号。\n所有 非注释 的内容都是 新增配置\n// vite.config.ts  // import { defineConfig } from \u0026#39;vite\u0026#39; // import react from \u0026#39;@vitejs/plugin-react\u0026#39; import path from \u0026#39;path\u0026#39; // https://vitejs.dev/config/ export default defineConfig({ // plugins: [react()],  resolve: { alias: { \u0026#39;@\u0026#39;: path.resolve(__dirname, \u0026#39;./src\u0026#39;), }, }, }) 3. 配置 VSCode 支持别名     这一步配置是在使用 路径别名 的时候， 为了让 VSCode 支持别名路径， 且显示不报错。"},{"id":72,"href":"/books/react/javascript/control-flow/ternary/","title":"3. 三元表达式","parent":"6. 控制流/分支语句","content":"三元表达式(ternary)\n 但是 并不推荐使用 三元表达式。 推荐使用 if-else 代替。\n  可读性不高， 尤其是嵌套的情况下。 不支持 代码块。  condition ? exprIfTrue : exprIfFalse const expr = true expr ? console.log(\u0026#39;expr is true\u0026#39;) : console.log(\u0026#39;expr is false\u0026#39;) // expr is true; 当使用 代码块 的时候， 就出问题了。\n ","description":"三元表达式(ternary)\n 但是 并不推荐使用 三元表达式。 推荐使用 if-else 代替。\n  可读性不高， 尤其是嵌套的情况下。 不支持 代码块。  condition ? exprIfTrue : exprIfFalse const expr = true expr ? console.log(\u0026#39;expr is true\u0026#39;) : console.log(\u0026#39;expr is false\u0026#39;) // expr is true; 当使用 代码块 的时候， 就出问题了。\n "},{"id":73,"href":"/books/react/javascript/func-class/closure/","title":"3. 函数闭包","parent":"5. 函数和类","content":"Closures\n定义:\n 函数嵌套 内部函数 直接 使用外部函数的变量。 而非传参数使用。  Demo 代码,\nfunction makeFunc() { const name = \u0026#34;Mozilla\u0026#34;; function displayName() { console.log(name); } return displayName; } const myFunc = makeFunc(); myFunc(); 闭包在 Go 中的应用， 辅助理解     换个 Golang 的闭包的使用案例: 配置参数\ntype Person struct { name string age int } type Option = func(*Person) func (p *Person) WithOptios(opts ...Option) { for _, opt := range opts { opt(p) } } ","description":"Closures\n定义:\n 函数嵌套 内部函数 直接 使用外部函数的变量。 而非传参数使用。  Demo 代码,\nfunction makeFunc() { const name = \u0026#34;Mozilla\u0026#34;; function displayName() { console.log(name); } return displayName; } const myFunc = makeFunc(); myFunc(); 闭包在 Go 中的应用， 辅助理解     换个 Golang 的闭包的使用案例: 配置参数\ntype Person struct { name string age int } type Option = func(*Person) func (p *Person) WithOptios(opts ...Option) { for _, opt := range opts { opt(p) } } "},{"id":74,"href":"/books/react/react/jsx/list-render/","title":"3. 列表与字典渲染","parent":"1. jsx 基础用法","content":"代码在 /src/components/jsx/ListRender.js 中\n列表默认情况是这样的\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;liubei\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;guanyu\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;zhangfei\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 1. 标准版的渲染     const list = [\u0026#39;liubei\u0026#39;, \u0026#39;guanyu\u0026#39;, \u0026#39;zhangfei\u0026#39;] function ListRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;2.3. 循环渲染\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; list = [\u0026#39;liubei\u0026#39;, \u0026#39;guanyu\u0026#39;, \u0026#39;zhangfei\u0026#39;]\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;箭头函数， 完整版。 带 key \u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; // (1) 保留外城的 ul  { list.map((item, index) =\u0026gt; { // (2) 循环什么就返回什么。  // (3) key 是 React 渲染的唯一表示  return \u0026lt;li key={index}\u0026gt;{item}\u0026lt;/li\u0026gt; }) } \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } 当我们要进行 列表渲染 的时候，\n 使用 列表的 map 方法。 循环的是 \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; 标签， 就在循环中返回该标签。 标签属性 一定要使用 key。 且 key 的值 必须 是 唯一的 unique。  key 是 React 在进行渲染的时候做 diff 算法的标识。 如果不用， 在列表删除的时候就会出现数据偏差。    2. 不规范的省略写法     最常见的不规范写法， 就是省略了 唯一key\n(item) =\u0026gt; (\u0026lt;li\u0026gt;{item}\u0026lt;/li\u0026gt;) 打开控制台， 可以看到 警告 如下：\nWarning: Each child in a list should have a unique \u0026quot;key\u0026quot; prop.  function ListRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;箭头函数 省略版： 有括号\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; { list.map((item) =\u0026gt; (\u0026lt;li\u0026gt;{item}\u0026lt;/li\u0026gt;)) } \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } const list = [\u0026#39;liubei\u0026#39;, \u0026#39;guanyu\u0026#39;, \u0026#39;zhangfei\u0026#39;] 除此之外， 还有一种更省略的写法就是： 省略 圆括号， 这是 JS 的语法特性。\nlist.map(item =\u0026gt; \u0026lt;li\u0026gt;{item}\u0026lt;/li\u0026gt;) 这两种都不是什么好的写法， 不用过多关注， 但是要知道可以这么写。\n其他:      React 的列表渲染 - 黑马 JS Array Usage  ","description":"代码在 /src/components/jsx/ListRender.js 中\n列表默认情况是这样的\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;liubei\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;guanyu\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;zhangfei\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 1. 标准版的渲染     const list = [\u0026#39;liubei\u0026#39;, \u0026#39;guanyu\u0026#39;, \u0026#39;zhangfei\u0026#39;] function ListRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;2.3. 循环渲染\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; list = [\u0026#39;liubei\u0026#39;, \u0026#39;guanyu\u0026#39;, \u0026#39;zhangfei\u0026#39;]\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;箭头函数， 完整版。 带 key \u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; // (1) 保留外城的 ul  { list.map((item, index) =\u0026gt; { // (2) 循环什么就返回什么。  // (3) key 是 React 渲染的唯一表示  return \u0026lt;li key={index}\u0026gt;{item}\u0026lt;/li\u0026gt; }) } \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } 当我们要进行 列表渲染 的时候，"},{"id":75,"href":"/books/react/javascript/data-types/boolean/","title":"3. 布尔值","parent":"3. 数据类型","content":"1. 布尔值     布尔值 只有两个: true 和 false\n2. 其他类型的布尔值     内建类型强制布尔值\n许多内建类型， 在被作为 布尔值 对待时， 具有一个 强制性 的值。\nBooleans are returned as-is.\n undefined 返回 false. null 返回 false. 0, -0, and NaN 返回 false; 其他非零数字 返回 true. 0n 返回 false; 其他非零大数字 返回 true. 空字符串 返回 false; 非空字符串 返回 true. Symbol 返回 true. 所有对象 和 数组 返回 true.  // built-in types boolean coercion console.log(Boolean(\u0026#39;\u0026#39;)); // false // 空字符串 console.log(Boolean(\u0026#39; \u0026#39;)); // true // 空格字符串 console.log(Boolean(\u0026#39;0\u0026#39;)); // true console.log(Boolean(\u0026#39;abc\u0026#39;)); // true  // // 空格字符串转换成数字为 0 console.log(Boolean(Number(\u0026#39; \u0026#39;))); // false  console.log(Boolean(0)); // false console.log(Boolean(1)); // true console.log(Boolean(-1)); // true console.log(Boolean(0n)); // true console.log(Boolean(1n)); // true  console.log(Boolean({})); // true console.log(Boolean([])); // true  console.log(Boolean(Infinity)); // true console.log(Boolean(NaN)); // false console.log(Boolean(null)); // false console.log(Boolean(undefined)); // false ","description":"1. 布尔值     布尔值 只有两个: true 和 false\n2. 其他类型的布尔值     内建类型强制布尔值\n许多内建类型， 在被作为 布尔值 对待时， 具有一个 强制性 的值。\nBooleans are returned as-is.\n undefined 返回 false. null 返回 false. 0, -0, and NaN 返回 false; 其他非零数字 返回 true. 0n 返回 false; 其他非零大数字 返回 true. 空字符串 返回 false; 非空字符串 返回 true. Symbol 返回 true. 所有对象 和 数组 返回 true.  // built-in types boolean coercion console."},{"id":76,"href":"/books/react/javascript/data-types/","title":"3. 数据类型","parent":"2. JavaScript","content":"","description":""},{"id":77,"href":"/books/react/javascript/variables/format/","title":"3. 模版字符串","parent":"2. 变量","content":"模版字符串可以很方便的 在字符串中插入 变量或常量\n使用模版字符串\n 必须使用 反引号 ` 包裹字符串 需要使用 ${ expression } 格式。 其中 expression 是 表达式 或 变量  const name = \u0026#34;zhangsan\u0026#34; let age = 20 // 使用变量 console.log(`name: ${name}, age: ${age}`); // name: zhangsan, age: 2  // 模版字符串中还可以使用表达式 console.log(`1 + 2 = ${1 + 2}`); // 1 + 2 = 3 console.log(`\u0026#39;a\u0026#39;+\u0026#39;b\u0026#39;= ${\u0026#39;a\u0026#39; + \u0026#39;b\u0026#39;}`); // \u0026#39;a\u0026#39;+\u0026#39;b\u0026#39;= ab ","description":"模版字符串可以很方便的 在字符串中插入 变量或常量\n使用模版字符串\n 必须使用 反引号 ` 包裹字符串 需要使用 ${ expression } 格式。 其中 expression 是 表达式 或 变量  const name = \u0026#34;zhangsan\u0026#34; let age = 20 // 使用变量 console.log(`name: ${name}, age: ${age}`); // name: zhangsan, age: 2  // 模版字符串中还可以使用表达式 console.log(`1 + 2 = ${1 + 2}`); // 1 + 2 = 3 console.log(`\u0026#39;a\u0026#39;+\u0026#39;b\u0026#39;= ${\u0026#39;a\u0026#39; + \u0026#39;b\u0026#39;}`); // \u0026#39;a\u0026#39;+\u0026#39;b\u0026#39;= ab "},{"id":78,"href":"/books/react/javascript/introduce/comment/","title":"3. 注释与结束符","parent":"1. 入门简介","content":"1. 注释      单行注释 : // statment 多行注释 : /* statment */  // comment  /* line 1 line 2 */ 2. 结束符     结束符为 分号 ;， 但是大部分时候 不写\n","description":"1. 注释      单行注释 : // statment 多行注释 : /* statment */  // comment  /* line 1 line 2 */ 2. 结束符     结束符为 分号 ;， 但是大部分时候 不写"},{"id":79,"href":"/books/react/react/hooks/use-effect/clear-side-effect/","title":"3. 清理副作用","parent":"useEffect 生命周期管理","content":"3. 清除函数副作用     useEffect 的第一个参数时一个函数。 当该函数有 return 返回值 statement 的时候， 会在 组件被卸载/取消挂载 的时候执行。\n如下代码， return 返回的 箭头函数 会在其所在的组件的组件被卸载的时候 停止计时器 。\n useEffect( () =\u0026gt; { const id = setInterval(() =\u0026gt; { console.log(\u0026#39;Child: setInterval called\u0026#39;); }, 1000); // 当省略清理函数时，  // 组件卸载时，定时器不会被清除  // 当重新加载组件时，会创建新的定时器， 多个定时器会同时运行  return () =\u0026gt; { clearInterval(id); } }, [] // 依赖项为空数组，只有在加载时执行一次， 只有在组件卸载时才会执行清理函数  ) 如果没有这段 return 清空计时器的代码， 那么当所在组件 反复 被挂载时， 每次加载都会启动一个新的定时器， 结果就是 启动无数个 计时器。\n 完整代码     完整代码在 /src/components/hooks/UseEffectClearSideEffect.jsx\n import { useEffect, useState } from \u0026#34;react\u0026#34; export default function UseEffectClearSideEffect() { const [showChild, setShowChild] = useState(true); return ( \u0026lt;div\u0026gt; \u0026lt;h4\u0026gt;4.2 UseEffict 清理副作用\u0026lt;/h4\u0026gt; \u0026lt;p\u0026gt;当组件卸载时，清理副作用\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;打开控制台查看信息： Child: setInterval called\u0026lt;/p\u0026gt; {showChild \u0026amp;\u0026amp; \u0026lt;Child /\u0026gt;} \u0026lt;button onClick={() =\u0026gt; { setShowChild(!showChild) }}\u0026gt;点我清除 Child 组件\u0026lt;/button\u0026gt; \u0026lt;/div \u0026gt; ) } function Child() { useEffect( () =\u0026gt; { const id = setInterval(() =\u0026gt; { console.log(\u0026#39;Child: setInterval called\u0026#39;); }, 1000); // 当省略清理函数时，  // 组件卸载时，定时器不会被清除  // 当重新加载组件时，会创建新的定时器， 多个定时器会同时运行  return () =\u0026gt; { clearInterval(id); } }, [] // 依赖项为空数组，只有在加载时执行一次， 只有在组件卸载时才会执行清理函数  ) return ( \u0026lt;div\u0026gt; \u0026lt;/div\u0026gt; ) } ","description":"3. 清除函数副作用     useEffect 的第一个参数时一个函数。 当该函数有 return 返回值 statement 的时候， 会在 组件被卸载/取消挂载 的时候执行。\n如下代码， return 返回的 箭头函数 会在其所在的组件的组件被卸载的时候 停止计时器 。\n useEffect( () =\u0026gt; { const id = setInterval(() =\u0026gt; { console.log(\u0026#39;Child: setInterval called\u0026#39;); }, 1000); // 当省略清理函数时，  // 组件卸载时，定时器不会被清除  // 当重新加载组件时，会创建新的定时器， 多个定时器会同时运行  return () =\u0026gt; { clearInterval(id); } }, [] // 依赖项为空数组，只有在加载时执行一次， 只有在组件卸载时才会执行清理函数  ) 如果没有这段 return 清空计时器的代码， 那么当所在组件 反复 被挂载时， 每次加载都会启动一个新的定时器， 结果就是 启动无数个 计时器。"},{"id":80,"href":"/books/react/react/communication/props/slot-children/","title":"3. 特殊的 children 插槽","parent":"1. props 通信","content":"/src/components/communication/RootCommunication.jsx\nexport default function RootCommunication() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt; 7. 组件通信\u0026lt;/h2\u0026gt; {/* 1. 自闭和标签 */} \u0026lt;Parent2Children /\u0026gt; {/* 2. 成对标签， 默认插槽 */} \u0026lt;PropChild\u0026gt; \u0026lt;span\u0026gt;span1\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;span2\u0026lt;/span\u0026gt; \u0026lt;/PropChild\u0026gt; \u0026lt;/div\u0026gt; ); } 可以看到在使用 PropChild\n 使用的是 成对标签。 标签中放入了两个 span 标签。  function PropChild(props) { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;7.1. 特殊的 props.children\u0026lt;/h3\u0026gt; {/* 拿到默认的 children 属性 */} \u0026lt;span\u0026gt;prop child: {props.children}\u0026lt;/span\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;/div\u0026gt; ) } 在 PropChild 内部， 使用 props.children 拿到了传过来的标签值\n 使用 React Developer Tool 可以更清晰的看到其属性\n ","description":"/src/components/communication/RootCommunication.jsx\nexport default function RootCommunication() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt; 7. 组件通信\u0026lt;/h2\u0026gt; {/* 1. 自闭和标签 */} \u0026lt;Parent2Children /\u0026gt; {/* 2. 成对标签， 默认插槽 */} \u0026lt;PropChild\u0026gt; \u0026lt;span\u0026gt;span1\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;span2\u0026lt;/span\u0026gt; \u0026lt;/PropChild\u0026gt; \u0026lt;/div\u0026gt; ); } 可以看到在使用 PropChild\n 使用的是 成对标签。 标签中放入了两个 span 标签。  function PropChild(props) { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;7.1. 特殊的 props.children\u0026lt;/h3\u0026gt; {/* 拿到默认的 children 属性 */} \u0026lt;span\u0026gt;prop child: {props.children}\u0026lt;/span\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;/div\u0026gt; ) } 在 PropChild 内部， 使用 props.children 拿到了传过来的标签值\n 使用 React Developer Tool 可以更清晰的看到其属性"},{"id":81,"href":"/books/react/javascript/func-class/class/","title":"3. 类","parent":"5. 函数和类","content":"","description":""},{"id":82,"href":"/books/react/react/components/","title":"3. 组件","parent":"10. React","content":"","description":""},{"id":83,"href":"/books/react/demos/redux-meituan/menu/","title":"3. 菜单交互","parent":"2. Redux 案例 - 美团","content":" 1. 菜单选中     在 /src/demos/redux-meituan/store/modules/takeaway.js 中\n 增加新的 state 字段 activeIndex 表示选中的菜单。 其值为对应的 foodsList 数组的 index 位置。 增加新的 reducer action setActiveIndex , 这是一个 同步 方法。 导出 setActiveIndex 以供外部使用  部分代码\nconst takeaway = createSlice({ // 名称  name: \u0026#39;takeaway\u0026#39;, // 初始数据  initialState: { // 当前选中的菜单分类  activeIndex: 0, }, // actions  reducers: { setActiveIndex: (state, action) =\u0026gt; { state.activeIndex = action.payload } } }) // 省略 ...  // 3. 导出 activeIndex 的 action export const { setActiveIndex } = takeaway.actions 在 /src/demos/redux-meituan/components/Menu/index.js 中，\n 使用 useSelector 从 state 中获取 activeIndex 。 使用 useDispatch 在菜单栏选中的时候调用 setActiveIndex 修改值。 使用 className 库， 通过 逻辑判断 返回 active 标签。  import classNames from \u0026#39;classnames\u0026#39; import \u0026#39;./index.scss\u0026#39; import { useSelector } from \u0026#39;react-redux\u0026#39; import { useDispatch } from \u0026#39;react-redux\u0026#39; import { setActiveIndex } from \u0026#39;../../store/modules/takeaway\u0026#39; const Menu = () =\u0026gt; { // 获取 activeIndex  const { activeIndex } = useSelector(state =\u0026gt; state.takeaway) const dispatch = useDispatch() const menus = foodsList.map(item =\u0026gt; ({ tag: item.tag, name: item.name })) return ( \u0026lt;nav className=\u0026#34;list-menu\u0026#34;\u0026gt; {/* 添加active类名会变成激活状态 */} {menus.map((item, index) =\u0026gt; { return ( \u0026lt;div key={item.tag} className={classNames( \u0026#39;list-menu-item\u0026#39;, // 如果当前的index等于activeIndex则添加active类名  activeIndex === index \u0026amp;\u0026amp; \u0026#39;active\u0026#39; )} // 点击时, 使用 dispatch 触发 setActiveIndex onClick={() =\u0026gt; dispatch(setActiveIndex(index))} \u0026gt; {item.name} \u0026lt;/div\u0026gt; ) })} \u0026lt;/nav\u0026gt; ) } // 省略 ... 2. 商品分类切换     在 /src/demos/redux-meituan/components/FoodsCategory/index.js 中可以看到\n所展示的 foods 信息是从上层传递过来的。\n// 上层传递的 foods const FoodsCategory = ({ name, foods }) =\u0026gt; { return ( \u0026lt;div className=\u0026#34;category\u0026#34;\u0026gt; {/* 省略 ... */} \u0026lt;/div\u0026gt; ) } 找到上层调用文件 /src/demos/redux-meituan/ReduxMeituan.jsx\n可以看到， 这里将所有的 foodsList 通过 map 方法直接展示了。\nconst ReduxMeituan = () =\u0026gt; { // 使用 useSelector 获取 store 数据  const { foodsList } = useSelector(state =\u0026gt; state.takeaway) return ( // 省略 ...  \u0026lt;div className=\u0026#34;goods-list\u0026#34;\u0026gt; {/* 外卖商品列表 */} {foodsList.map((item) =\u0026gt; { // 根据条件判断是否显示  return ( \u0026lt;FoodsCategory key={item.tag} // 列表标题 name={item.name} // 列表商品 foods={item.foods} /\u0026gt; ) })} \u0026lt;/div\u0026gt; // 省略 ...  ) } 如果要根据前面实现的 所选分类 进行展示， 就需要对 foodsList 过滤。\n2.1. 使用 map 方法对渲染对象进行过滤      在使用 map 方法的时候传入的函数具有两个参数： item 和 index。 通过 index 和 activeIndex 进行对比， 判断对象是否需要渲染并返回。  // {/* 方法1: 内部过滤 */}  {foodsList.map((item, index) =\u0026gt; { // 根据条件判断是否显示 if (index === activeIndex) { return ( \u0026lt;FoodsCategory key={item.tag} // 列表标题 name={item.name} // 列表商品 foods={item.foods} /\u0026gt; ) } })} 2.2. 使用 filter 方法对 foodsList 过滤      这种方法在渲染的时候 行为 保持不变。 但是对于被渲染的 foodsList 使用 filter 方法进行 提前 过滤。  const ReduxMeituan = () =\u0026gt; { // 使用 useSelector 获取 store 数据  // 使用 let 定义 foodsList, 可以修改  let { foodsList } = useSelector(state =\u0026gt; state.takeaway) // 使用 filter 方法过滤。 并用同名变量接收  foodsList = foodsList.filter( (_, index) =\u0026gt; { return index === activeIndex } ) return ( // 省略 ...  \u0026lt;div className=\u0026#34;home\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;goods-list\u0026#34;\u0026gt; {/* 外卖商品列表 */} {/* 方法2: 外部过滤 */} { foodsList.map( (item) =\u0026gt; { return ( \u0026lt;FoodsCategory key={item.tag} // 列表标题 name={item.name} // 列表商品 foods={item.foods} /\u0026gt; ) } ) } \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; // 省略 ...  ) } 实现的方法不一样，效果一样。 法无定法。\n","description":"1. 菜单选中     在 /src/demos/redux-meituan/store/modules/takeaway.js 中\n 增加新的 state 字段 activeIndex 表示选中的菜单。 其值为对应的 foodsList 数组的 index 位置。 增加新的 reducer action setActiveIndex , 这是一个 同步 方法。 导出 setActiveIndex 以供外部使用  部分代码\nconst takeaway = createSlice({ // 名称  name: \u0026#39;takeaway\u0026#39;, // 初始数据  initialState: { // 当前选中的菜单分类  activeIndex: 0, }, // actions  reducers: { setActiveIndex: (state, action) =\u0026gt; { state.activeIndex = action.payload } } }) // 省略 ."},{"id":84,"href":"/books/react/react/router/navigate-params/","title":"3. 路由传参","parent":"6. React-Router","content":"有 两种 方式可以通过 路由地址 进行参数传递。\n 路径传参: /path/1234/zhangsan query请求传参: /article?id=1101\u0026amp;name=wangwu  1. 路径传参     顾名思义， 就是 将参数放在 path 中。\n 在使用之前需要 定义参数名称和位置。 使用 useParams 接受参数  在 /src/components/router/RootRouter.jsx 中\nconst router = createBrowserRouter([ { // 定义参数位置和名称  path: \u0026#34;/article/:id/:name\u0026#34;, element: \u0026lt;Article /\u0026gt; } ]) 在 /src/components/router/Article/index.jsx 中使用 useParams 使用 解构赋值 接受参数\nimport { Link } from \u0026#34;react-router-dom\u0026#34;; import { useParams } from \u0026#34;react-router-dom\u0026#34;; export default function Article() { // 使用 解构赋值 获取路由参数  const { id, name } = useParams(); return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;8.2 文章页面\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;文章页面\u0026lt;/p\u0026gt; {/* 使用路由参数 */} \u0026lt;span\u0026gt;id: {id}, name: {name}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ); } 2. query请求传参      在 path 后面添加请求参数。 使用 useSearchParams 接受参数。  使用 .get 方法获取 参数名对应的值。 setParams 可以更新请求参数列表。    在 /src/components/router/Login/index.jsx 中， 使用 useSearchParams 接收参数\nimport { useNavigate } from \u0026#34;react-router-dom\u0026#34;; import { useSearchParams } from \u0026#34;react-router-dom\u0026#34;; export default function Login() { // 接收参数  const [params, setParams] = useSearchParams(); // 通过 get 方法获取参数  let id = params.get(\u0026#39;id\u0026#39;); let name = params.get(\u0026#39;name\u0026#39;); return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;8.1 登录页面\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;登录页面\u0026lt;/p\u0026gt; \u0026lt;span\u0026gt;id: {id}, name: {name}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ); } ","description":"有 两种 方式可以通过 路由地址 进行参数传递。\n 路径传参: /path/1234/zhangsan query请求传参: /article?id=1101\u0026amp;name=wangwu  1. 路径传参     顾名思义， 就是 将参数放在 path 中。\n 在使用之前需要 定义参数名称和位置。 使用 useParams 接受参数  在 /src/components/router/RootRouter.jsx 中\nconst router = createBrowserRouter([ { // 定义参数位置和名称  path: \u0026#34;/article/:id/:name\u0026#34;, element: \u0026lt;Article /\u0026gt; } ]) 在 /src/components/router/Article/index.jsx 中使用 useParams 使用 解构赋值 接受参数\nimport { Link } from \u0026#34;react-router-dom\u0026#34;; import { useParams } from \u0026#34;react-router-dom\u0026#34;; export default function Article() { // 使用 解构赋值 获取路由参数  const { id, name } = useParams(); return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;8."},{"id":85,"href":"/books/react/react/hooks/","title":"4. Hooks","parent":"10. React","content":"Hook 是用来实现 逻辑的封装和复用 的函数。\n在官网中， 有对 Hook 函数的专门介绍\n1. Hook 使用使用规则     Hook 函数有 两条核心 使用规则\n 只能在 React Function（组件） 内部调用。 即 不能 在  普通 JS 函数 中调用。 不能在 React Fucntion 外部调用    // 错误示范: 外部调用 const [count, setCount] = useState(0) function MyComponenet() { return ( \u0026lt;div\u0026gt; \u0026lt;/div\u0026gt; ) } 只能在 顶层 使用 Hook。 即 不能 在以下位置使用  loop: 循环 condition: 条件语句 netsted function: 嵌套函数    export default function MyComponenet() { function Add() { if (Math.random() \u0026gt; 0.5) { // 错误示范， 在条件语句中使用 Hook  const [count, setCount] = useState(0) setCount(count + 1) } } return ( \u0026lt;div\u0026gt; \u0026lt;/div\u0026gt; ) } 2. Hook 列表     在官网中，提供了 Hooks API Reference 列表和用法\n  Basic Hooks:\n useState useEffect useContext    Additional Hooks:\n useReducer useCallback useRef ...    Library Hooks:\n useSyncExternalStore useInsertionEffect    ","description":"Hook 是用来实现 逻辑的封装和复用 的函数。\n在官网中， 有对 Hook 函数的专门介绍\n1. Hook 使用使用规则     Hook 函数有 两条核心 使用规则\n 只能在 React Function（组件） 内部调用。 即 不能 在  普通 JS 函数 中调用。 不能在 React Fucntion 外部调用    // 错误示范: 外部调用 const [count, setCount] = useState(0) function MyComponenet() { return ( \u0026lt;div\u0026gt; \u0026lt;/div\u0026gt; ) } 只能在 顶层 使用 Hook。 即 不能 在以下位置使用  loop: 循环 condition: 条件语句 netsted function: 嵌套函数    export default function MyComponenet() { function Add() { if (Math."},{"id":86,"href":"/books/react/react/communication/redux/redux-react-channel/","title":"4. Redux 与 React - 实现 Channel (异步)","parent":"3. redux","content":"异步 的实现方法和同步差不多。\n1. 使用 createSlice 创建     在 /src/store/modules/channelStore.js 中创建 Channel Store。 这一步同步是一样的。\nconst channelSlice = createSlice({ // 名称  name: \u0026#39;channel\u0026#39;, // 初始化数据  initialState: { channels: [ { id: 1, name: \u0026#39;网络不通， 检查网络\u0026#39; }, ], }, // actions 方法  reducers: { setChannels(state, action) { state.channels = action.payload; } }, }) 2. 导出 reducer 到 store/index.js     这一部分也一样\n在 /src/store/modules/channelStore.js 中导出 reduder，\n// 导出 reducer 到 store/index.js 中 const channelReducer = channelSlice.reducer; export default channelReducer; 并组合到 /src/store/index.js 中。\nimport { configureStore } from \u0026#39;@reduxjs/toolkit\u0026#39;; // 引入 import channelReducer from \u0026#39;./modules/channelStore\u0026#39;; const store = configureStore({ reducer: { // 组合，命名  channel: channelReducer, }, }); 3. 使用 thunk 封装异步函数并导出     注意: 这一步就 很不一样 了。 由于需要 异步 操作，\n 就需要 封装并返回 thunk 函数， 并 返回一个异步函数， 使用 dispatch 执行调用。  在 /src/store/modules/channelStore.js 中， 针对 setChannels 行为封装了一个名为 fetchChannels 的函数\n// 异步请求不在直接提供 action，而是提供了一个 thunk 函数 const { setChannels } = channelSlice.actions; // export { setChannels };  // 定义一个 thunk 函数返回一个异步函数 const fetchChannels = () =\u0026gt; { // 返回一个异步函数  // 传入 dispatch 参数。 这个参数来自于外部调用这个函数的地方。  // const dispath = useDispatch();  return async (dispatch) =\u0026gt; { const res = await axios.get(`http://geek.itheima.net/v1_0/channels`) .catch( err =\u0026gt; console.log(err) ) if (res?.status === 200) { // 这个函数会在 dispatch 的时候执行  dispatch(setChannels(res.data.data.channels)); } } } // 导出 thunk 函数 export { fetchChannels }; 4. 外部使用 useSelector 获取数据     这一步没什么不同。\n在 /src/components/communication/redux/ReduxChannel.jsx 中\nimport { useSelector, useDispatch } from \u0026#39;react-redux\u0026#39;; export default function ReduxChannel() { // useSelector 用于获取 store/index.js 中的 channel 对象  // channels: 使用解构赋值获取。 来自于 channel reducer 中的 state 对象  const { channels } = useSelector(reducer =\u0026gt; reducer.channel); return ( \u0026lt;div\u0026gt; \u0026lt;h4\u0026gt; 7.5.2 Redux Channel（异步）\u0026lt;/h4\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {channels.map(channel =\u0026gt; ( \u0026lt;li key={channel.id}\u0026gt;{channel.name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } 5. 外部使用 useDispatch 调用修改数据     在使用方便， 异步和同步 差别不大， 都使用 useDispatch 调用。\n在 /src/components/communication/redux/ReduxChannel.jsx 中\n 获取 thunk 函数 fetchChannels 使用 dispatch(fn) 调用。 这里使用了 useEffect 生命周期函数辅助调用。  明明这里是 dispatch 在调用 fn， 但是在在 fn 的实现中时将 dispatch 作为参数传递到内部了的。 至于这里怎么把 dispatch 传递给 fn 的我就搞不清楚了。\nimport { useSelector, useDispatch } from \u0026#39;react-redux\u0026#39;; // 导入 fetchChannels import { fetchChannels } from \u0026#39;../../../store/modules/channelStore\u0026#39;; import { useEffect } from \u0026#39;react\u0026#39;; export default function ReduxChannel() { // useSelector 用于获取 store/index.js 中的 channel 对象  // channels: 使用解构赋值获取。 来自于 channel reducer 中的 state 对象  const { channels } = useSelector(reducer =\u0026gt; reducer.channel); // 获取 dispatch  const dispatch = useDispatch(); useEffect(() =\u0026gt; { // 使用 dispatch 调用  dispatch(fetchChannels()); }, [dispatch]); return ( \u0026lt;div\u0026gt; \u0026lt;h4\u0026gt; 7.5.2 Redux Channel（异步）\u0026lt;/h4\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {channels.map(channel =\u0026gt; ( \u0026lt;li key={channel.id}\u0026gt;{channel.name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } 不清楚视频中使用 useEffect 时为什么依赖 dispatch。\n","description":"异步 的实现方法和同步差不多。\n1. 使用 createSlice 创建     在 /src/store/modules/channelStore.js 中创建 Channel Store。 这一步同步是一样的。\nconst channelSlice = createSlice({ // 名称  name: \u0026#39;channel\u0026#39;, // 初始化数据  initialState: { channels: [ { id: 1, name: \u0026#39;网络不通， 检查网络\u0026#39; }, ], }, // actions 方法  reducers: { setChannels(state, action) { state.channels = action.payload; } }, }) 2. 导出 reducer 到 store/index.js     这一部分也一样\n在 /src/store/modules/channelStore.js 中导出 reduder，"},{"id":87,"href":"/books/react/javascript/data-types/undefined-null/","title":"4. undefined and null","parent":"3. 数据类型","content":" undefined - mdn\n 1. undefined     undefined 类型的的值就是 undefined。 undefined 具有一下特征\n 不可写 不可枚举 不可配置  以下代码 合法但有病\n Note: While you can use undefined as an identifier (variable name) in any scope other than the global scope (because undefined is not a reserved wor 保留字符), doing so is a very bad idea that will make your code difficult to maintain and debug.\n // DON\u0026#39;T DO THIS  (() =\u0026gt; { const undefined = \u0026#34;foo\u0026#34;; console.log(undefined, typeof undefined); // foo string })(); ((undefined) =\u0026gt; { console.log(undefined, typeof undefined); // foo string })(\u0026#34;foo\u0026#34;); 1.1. 什么时候会出现 undefined     当一个 变量 被定义， 但是没被复制的时候， 这个变量就是 undefined\nlet x console.log(x); // undefined  // console.log(y); // ReferenceError: y is not defined 1.2. undefined 的判断     当一个 被定义但是没有被复制的时候， 可以使用 === 进行 undefined 判断\nlet x; if (typeof x === \u0026#34;undefined\u0026#34;) { // these statements execute } 但是 如果一个 没有被定义，\n 需要使用 typeof x 判断 不会 抛出异常。 否则使用 === 会抛出异常。  // x has not been declared before // evaluates to true without errors if (typeof x === \u0026#34;undefined\u0026#34;) { // these statements execute } // Throws a ReferenceError if (x === undefined) { } 所以 不要想太多， 直接使用 typeof 进行判断即可。\n1.3. undefined 和 'undefined'     注意: undefined 是一个 对象 还是 字符串\nlet x // undefined 是一个全局对象的属性 if (x === undefined) { console.log(\u0026#39;x is undefined\u0026#39;); // x is undefined } // \u0026#39;undefined\u0026#39; 是一个字符串 if (x === \u0026#39;undefined\u0026#39;) { console.log(\u0026#39;x is undefined\u0026#39;); // 不会被执行 } // 使用 typeof 的时候， 就是一个字符串值了 if (typeof x === \u0026#39;undefined\u0026#39;) { console.log(\u0026#39;x is undefined\u0026#39;); // x is undefined } 2. null      null - mdn\n null 代表的是一个 无、空 或者 值未知 的特殊值。\n2.1. null 的定义     // null 是一个特殊的对象，表示一个空对象指针 let obj = null console.log(obj) // null  // 因为一个历史原因，typeof null 返回 \u0026#34;object\u0026#34;。这是 JavaScript 的错误之一。 console.log(typeof null) // object; console.log(typeof obj) // object 2.2. null 的使用场景     把 null 作为尚未创建的 对象。\n换句话说： 创建一个 变量 并需要赋值 object, 但值还没准备好， 就先用 null 占位\nlet obj = null console.log(obj) // null  const value = { name: 10, age: 20 } obj = value console.log(obj) // { name: 10, age: 20 } 2.3. 定义 null 的变量赋值其他类型     null 变量 被可以赋值 非 object 类型的值。\n因此， 前面说的 null 是 object 的占位符， 实在 使用习惯的约束， 而非语法约束\nlet obj = null // 因为一切都是对象 obj = 10 console.log(obj) // 10 3. undefined 和 null 的区别      undefined 是 定义了但没复制 null 是 赋值了， 但值为空  typeof null; // \u0026#34;object\u0026#34; (not \u0026#34;null\u0026#34; for legacy reasons) typeof undefined; // \u0026#34;undefined\u0026#34;  null === undefined; // false null == undefined; // true  null === null; // true null == null; // true  Boolean(null) // false !null; // true Boolean(undefined) // false !undefined; // true  Number.isNaN(1 + null); // false Number.isNaN(1 + undefined); // true ","description":"undefined - mdn\n 1. undefined     undefined 类型的的值就是 undefined。 undefined 具有一下特征\n 不可写 不可枚举 不可配置  以下代码 合法但有病\n Note: While you can use undefined as an identifier (variable name) in any scope other than the global scope (because undefined is not a reserved wor 保留字符), doing so is a very bad idea that will make your code difficult to maintain and debug.\n // DON\u0026#39;T DO THIS  (() =\u0026gt; { const undefined = \u0026#34;foo\u0026#34;; console."},{"id":88,"href":"/books/react/react/communication/zustand/","title":"4. zustand","parent":"5. 组件通信","content":"","description":""},{"id":89,"href":"/books/react/javascript/variables/scope/","title":"4. 作用域","parent":"2. 变量","content":" https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#variables\n 作用域是指 变量和常量 的生效范围。 即 在哪里定义， 就在哪里生效\n 全局范围: 所有代码的默认作用域 模块范围: 模块代码 函数范围: 函数内  let x = 100 if (true) { let x = 5; // block-scoped to the containing if statement  console.log(x); // 5 } console.log(x); // 100  let z = 100 if (true) { z = 5; // modify, not re-declare } console.log(z); // z is 5 2. 函数作用域     // 函数作用域 function bigger(a, b) { if (a \u0026gt; b) { let res = \u0026#34;a \u0026gt; b\u0026#34;; } else { let res = \u0026#34;a \u0026lt; b\u0026#34; } } console.log(res); // ReferenceError: res is not defined 4. 代码块作用域     只要是 { statement } 就是一个代码块。\nif, for, while, do-while, switch, try-catch 都具有 代码块\nif (Math.random() \u0026gt; 0.5) { // 内部  // y is block-scoped to the containing if statement  const y = 5; // \u0026#39;y\u0026#39; is declared but it vlaue is nerv used. } // 外部 console.log(y); // ReferenceError: y is not defined  // 代码块中的变量。 // 只要是 { statement } 就是一个代码块。 // 不一定需要 if, for, while, do-while, switch, try-catch  { let a = 1 } console.log(a); // ReferenceError: a is not defined ","description":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#variables\n 作用域是指 变量和常量 的生效范围。 即 在哪里定义， 就在哪里生效\n 全局范围: 所有代码的默认作用域 模块范围: 模块代码 函数范围: 函数内  let x = 100 if (true) { let x = 5; // block-scoped to the containing if statement  console.log(x); // 5 } console.log(x); // 100  let z = 100 if (true) { z = 5; // modify, not re-declare } console.log(z); // z is 5 2. 函数作用域     // 函数作用域 function bigger(a, b) { if (a \u0026gt; b) { let res = \u0026#34;a \u0026gt; b\u0026#34;; } else { let res = \u0026#34;a \u0026lt; b\u0026#34; } } console."},{"id":90,"href":"/books/react/javascript/func-class/currying/","title":"4. 函数柯里化","parent":"5. 函数和类","content":"","description":""},{"id":91,"href":"/books/react/react/communication/props/children-to-parent/","title":"4. 子传父通信","parent":"1. props 通信","content":"/src/components/communication/Children2Parent.jsx\n核心思路: 父组件可以给子组件传递一个函数， 子组件通过调用函数向父组件传递数据\n  父组件通过 props 向子组件传递数据， 但 在子组件中 props 是只读的。 因此 数据只能在父组件中被修改  function Parent() { const original = \u0026#34;Father.React\u0026#34; // 在父组件定义一个状态数据  const [name, setName] = useState(original) // 重置名字  function resetName() { setName(original) } // 1. 通过函数修改父组件的状态数据  function changeName(name) { setName(name) } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;父组件名字: {name}\u0026lt;/p\u0026gt; \u0026lt;b\u0026gt;父组件区域: \u0026lt;/b\u0026gt; \u0026lt;button onClick={resetName}\u0026gt;重置名称\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;重置父组件名字\u0026lt;/span\u0026gt; {/* 1. 通过 props 将函数传递给子组件 2. props 属性名字加上 on 表示调用执行 */} \u0026lt;hr\u0026gt;\u0026lt;/hr\u0026gt; \u0026lt;Child onChangeName={changeName} /\u0026gt; \u0026lt;/div\u0026gt; ) } 在 父组件中\n 使用 useState 创建一个状态数据 name， 用于管理变量的变化。 创建 changeName 函数， 修改 name 值的状态。 在 Child 组件中， 使用 onChangeName 作为 props 属性名称， 表示 事件触发。  // 在子组件中通过 props 调用父组件的函数 // 使用解构赋值的方式获取父组件传递的函数 function Child({ onChangeName }) { return ( \u0026lt;div\u0026gt; \u0026lt;b\u0026gt;子组件区域: \u0026lt;/b\u0026gt; \u0026lt;button onClick={() =\u0026gt; onChangeName(\u0026#34;Child.Vue\u0026#34;)}\u0026gt;点我修改\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;将父组件名字修改为 Child.Vue\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ) } 在 子组件中\n 接受 props 参数。 案例中使用了 ES 的解构语法({ onChangeName })获取了 onChangeName 在 button 中使用 onClick 事件， 调用 onChangeName 函数， 向父组件传递新名字。  注意: 如果没有使用解构语法， 则使用 props.onChangeName 调用即可。\n ","description":"/src/components/communication/Children2Parent.jsx\n核心思路: 父组件可以给子组件传递一个函数， 子组件通过调用函数向父组件传递数据\n  父组件通过 props 向子组件传递数据， 但 在子组件中 props 是只读的。 因此 数据只能在父组件中被修改  function Parent() { const original = \u0026#34;Father.React\u0026#34; // 在父组件定义一个状态数据  const [name, setName] = useState(original) // 重置名字  function resetName() { setName(original) } // 1. 通过函数修改父组件的状态数据  function changeName(name) { setName(name) } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;父组件名字: {name}\u0026lt;/p\u0026gt; \u0026lt;b\u0026gt;父组件区域: \u0026lt;/b\u0026gt; \u0026lt;button onClick={resetName}\u0026gt;重置名称\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;重置父组件名字\u0026lt;/span\u0026gt; {/* 1. 通过 props 将函数传递给子组件 2. props 属性名字加上 on 表示调用执行 */} \u0026lt;hr\u0026gt;\u0026lt;/hr\u0026gt; \u0026lt;Child onChangeName={changeName} /\u0026gt; \u0026lt;/div\u0026gt; ) } 在 父组件中"},{"id":92,"href":"/books/react/react/router/nested-routers/","title":"4. 嵌套路由","parent":"6. React-Router","content":"嵌套路由: 在一级路由中 内嵌 了其他路由， 这种路由关系就叫做 嵌套路由。\n嵌套到一级路由内的路由又被称为 二级路由。 以此类推， 三级、四级路由。\n 最常见应用场景， 就是 系统管理界面， 如图。\n 1. 使用 children 属性配置路由嵌套关系     在 /src/components/router/RootRouter.jsx 中， 添加路由表。\nconst router = createBrowserRouter([ { path: \u0026#34;/\u0026#34;, element: \u0026lt;Layout /\u0026gt;, // 指定子路由  children: [ // 子路由与父路由定义方式一样  { path: \u0026#34;/board\u0026#34;, element: \u0026lt;Board /\u0026gt; }, { path: \u0026#34;/about\u0026#34;, element: \u0026lt;About /\u0026gt; } ], } ]) 2. 使用 \u0026lt;Outlet /\u0026gt; 指定二级路由渲染位置     在 /src/components/router/Layout/index.jsx 中， 使用 \u0026lt;Outlet /\u0026gt; 指定二级页面渲染位置。\nimport { Link, Outlet } from \u0026#34;react-router-dom\u0026#34;; export default function Layout() { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;8.3 Layout\u0026lt;/h3\u0026gt; \u0026lt;Link to=\u0026#34;/\u0026#34;\u0026gt;首页｜\u0026lt;/Link\u0026gt; \u0026lt;Link to=\u0026#34;/board\u0026#34;\u0026gt;面板｜\u0026lt;/Link\u0026gt; \u0026lt;Link to=\u0026#34;/about\u0026#34;\u0026gt;关于\u0026lt;/Link\u0026gt; {/* 子页面渲染占位 */} \u0026lt;Outlet /\u0026gt; \u0026lt;/div\u0026gt; ); } 3. 默认二级路由     当访问一级路由时， 默认的 二级路由和组件 可以被渲染。\n 在二级路由位置 去掉 path 增加 index: true 属性。  由于去掉了 path, 则对应的二级路由路径则不存在了。\nconst router = createBrowserRouter([ { path: \u0026#34;/\u0026#34;, element: \u0026lt;Layout /\u0026gt;, children: [ { // 删除 path 属性，增加 index: 表示默认路由  // path: \u0026#34;/board\u0026#34;,  index: true, element: \u0026lt;Board /\u0026gt; }, { path: \u0026#34;/about\u0026#34;, element: \u0026lt;About /\u0026gt; } ], } ]) ","description":"嵌套路由: 在一级路由中 内嵌 了其他路由， 这种路由关系就叫做 嵌套路由。\n嵌套到一级路由内的路由又被称为 二级路由。 以此类推， 三级、四级路由。\n 最常见应用场景， 就是 系统管理界面， 如图。\n 1. 使用 children 属性配置路由嵌套关系     在 /src/components/router/RootRouter.jsx 中， 添加路由表。\nconst router = createBrowserRouter([ { path: \u0026#34;/\u0026#34;, element: \u0026lt;Layout /\u0026gt;, // 指定子路由  children: [ // 子路由与父路由定义方式一样  { path: \u0026#34;/board\u0026#34;, element: \u0026lt;Board /\u0026gt; }, { path: \u0026#34;/about\u0026#34;, element: \u0026lt;About /\u0026gt; } ], } ]) 2. 使用 \u0026lt;Outlet /\u0026gt; 指定二级路由渲染位置     在 /src/components/router/Layout/index."},{"id":93,"href":"/books/react/react/jsx/conditional-render/","title":"4. 条件渲染","parent":"1. jsx 基础用法","content":"React 根据条件运算返回的不同结果进行结果渲染， 主要分为以下几种\n 逻辑判断： \u0026amp;\u0026amp;, ||, ! 三目运算符: condition? yes : no 分支语句： if-else, switch  1. 逻辑运算符     逻辑运算符：\n \u0026amp;\u0026amp; 且 || 或 ! 非  function ConditionalRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;04. 条件渲染: isLogin={String(isLogin)}\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;1. 逻辑语句\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;isLogin \u0026amp;\u0026amp; Login \u0026lt;/p\u0026gt; {isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt;} \u0026lt;p\u0026gt;isLogin || Logout\u0026lt;/p\u0026gt; {isLogin || \u0026lt;Logout /\u0026gt;} \u0026lt;p\u0026gt;isLogin \u0026amp;\u0026amp; Login || Logout\u0026lt;/p\u0026gt; {isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; || \u0026lt;Logout /\u0026gt;} {(isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt;) || \u0026lt;Logout /\u0026gt;} \u0026lt;/div \u0026gt; ) } const isLogin = false;  条件语句 必须要在最前面。 \u0026amp;\u0026amp; 和 || 可以单独使用； 也可以一起使用， 一起使用时效果类似 三目运算符。  但是 React 并不推荐这么做， 如果这样做了会给予提示： 混合使用 \u0026amp;\u0026amp; 和 ||。 请用 圆括号 指定执行顺序\nLine 10:16: Unexpected mix of '\u0026amp;\u0026amp;' and '||'. Use parentheses to clarify the intended order of operations 因此我们可以通过 圆括号 进行归类， 注意括号未知。\n{(isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt;) || \u0026lt;Logout /\u0026gt;} {isLogin \u0026amp;\u0026amp; (\u0026lt;Login /\u0026gt; || \u0026lt;Logout /\u0026gt;)} 2. 三目运算符     三目运算符 具有固定格式： condition? yes : no ， 注意分隔符。\nfunction ConditionalRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;2. 三目运算符 \u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;isLogin ? Login : Logout\u0026lt;/p\u0026gt; {isLogin ? \u0026lt;Login /\u0026gt; : \u0026lt;Logout /\u0026gt;} \u0026lt;/div \u0026gt; ) } const isLogin = false; 3. 分支条件语句     分支条件语句\n 在 statement 中可以实现更复杂的操作 可以返回更多的 条件结果。  function ConditionalRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;04. 条件渲染: isLogin={String(isLogin)}\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;3. 分支函数\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;if (isLogin); return Login; else return Logout; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{Condition()}\u0026lt;/p\u0026gt; \u0026lt;/div \u0026gt; ) } const isLogin = false; function Condition() { if (isLogin) { {/* 其他操作 */} console.log(isLogin) return \u0026lt;Login /\u0026gt; } else { return \u0026lt;Logout /\u0026gt; } } 注意 Condition 由于 只有两个条件 结果， 非此即彼。因此函数还可以写成 以下形式 不用 else。\nfunction Condition() { if (isLogin) { return \u0026lt;Login /\u0026gt; } return \u0026lt;Logout /\u0026gt; } 其他:      如何渲染布尔值: String(bool1) jsx 简单条件渲染 jsx 复杂条件渲染  ","description":"React 根据条件运算返回的不同结果进行结果渲染， 主要分为以下几种\n 逻辑判断： \u0026amp;\u0026amp;, ||, ! 三目运算符: condition? yes : no 分支语句： if-else, switch  1. 逻辑运算符     逻辑运算符：\n \u0026amp;\u0026amp; 且 || 或 ! 非  function ConditionalRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;04. 条件渲染: isLogin={String(isLogin)}\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;1. 逻辑语句\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;isLogin \u0026amp;\u0026amp; Login \u0026lt;/p\u0026gt; {isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt;} \u0026lt;p\u0026gt;isLogin || Logout\u0026lt;/p\u0026gt; {isLogin || \u0026lt;Logout /\u0026gt;} \u0026lt;p\u0026gt;isLogin \u0026amp;\u0026amp; Login || Logout\u0026lt;/p\u0026gt; {isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; || \u0026lt;Logout /\u0026gt;} {(isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt;) || \u0026lt;Logout /\u0026gt;} \u0026lt;/div \u0026gt; ) } const isLogin = false;  条件语句 必须要在最前面。 \u0026amp;\u0026amp; 和 || 可以单独使用； 也可以一起使用， 一起使用时效果类似 三目运算符。  但是 React 并不推荐这么做， 如果这样做了会给予提示： 混合使用 \u0026amp;\u0026amp; 和 ||。 请用 圆括号 指定执行顺序"},{"id":94,"href":"/books/react/demos/redux-meituan/cart-list/","title":"4. 购物车管理","parent":"2. Redux 案例 - 美团","content":"1. 添加购物车     在 /src/demos/redux-meituan/components/Cart/index.js 中可以看到 购物车 的相关配置。\n可以看到 购物车 的数据定义是 cart=[] 空数组。\nconst Cart = () =\u0026gt; { const cart = [] // 省略 ... } 在 /src/demos/redux-meituan/components/FoodsCategory/FoodItem/index.js 中\n可以看到 具体商品 配置。 从传入的 props 中解构出来了所有商品字段。\nconst Foods = ({ id, picture, name, unit, description, food_tag_list, month_saled, like_ratio_desc, price, tag, count }) =\u0026gt; { // 省略 ... } 1.1. 优化 store     因此在 /src/demos/redux-meituan/store/modules/takeaway.js 中\n 定义 state.cartList 增加 action 添加商品到购物车  判断商品是否 已经存在 如果存在， 则商品 count+1 如果不存在， 则将商品 push 到购物车 并 count=1    const takeaway = createSlice({ // 名称  name: \u0026#39;takeaway\u0026#39;, // 初始数据  initialState: { // 购物车列表数据  cartList: [], }, // actions  reducers: { // 增加物品到购物车  addCartList: (state, action) =\u0026gt; { // 1. 判断购物车中是否已经有该物品  // 如果没有找到，则返回 -1  const index = state.cartList.findIndex(item =\u0026gt; item.id === action.payload.id) // 2. 如果有，则数量 +1  if (index \u0026gt; -1) { state.cartList[index].count += 1 return } // 3. 如果没有，则添加到购物车, 并且数量为 1  // 使用 解构语法  state.cartList.push({ ...action.payload, count: 1 }) }, } }) 1.2. 添加商品交互     在 /src/demos/redux-meituan/components/FoodsCategory/FoodItem/index.js 中，\n找到 添加按钮(plus)， 绑定 onClick 事件。\n 定义 onPlus 方法， 使用 dispatch 添加数据。 在调用 onPlus 方法的时候， 需要传入 整个 商品对象。 代码看起来有点臃肿。  import { useDispatch } from \u0026#39;react-redux\u0026#39; import { addCartList } from \u0026#39;../../../store/modules/takeaway\u0026#39; const Foods = ({...}) =\u0026gt; { const dispatch = useDispatch() const onPlus = (item) =\u0026gt; { dispatch(addCartList(item)) } return ( \u0026lt;div className=\u0026#34;cate-goods\u0026#34;\u0026gt; {/* 添加购物车 */} \u0026lt;div className=\u0026#34;goods-count\u0026#34;\u0026gt; \u0026lt;span className=\u0026#34;plus\u0026#34; onClick={() =\u0026gt; onPlus( { id, picture, name, unit, description, food_tag_list, month_saled, like_ratio_desc, price, tag, count } )}\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } 随后就可以通过 Redux DevTools 插件 进行数据测试了\n 2. 显示购物车     回到 购物车 /src/demos/redux-meituan/components/Cart/index.js 中，\n 使用 useSelector 从 state 中获取数据。  由于在 state 中定义的字段是 cartList， 因此在解构赋值的时候， 使用了别名。 其他渲染代码不变   修改 购物车 panel 的标签属性。 增加 visable 显示购物车。  import classNames from \u0026#39;classnames\u0026#39; import { useSelector } from \u0026#39;react-redux\u0026#39; const Cart = () =\u0026gt; { // const cart = []  // 解构赋值， 并使用别名  const { cartList: cart } = useSelector(state =\u0026gt; state.takeaway) return ( \u0026lt;div className=\u0026#34;cartContainer\u0026#34;\u0026gt; {/* 添加visible类名 div会显示出来 */} {/* 显示购物车 */} \u0026lt;div className={classNames( \u0026#39;cartPanel\u0026#39;, \u0026#39;visible\u0026#39; )}\u0026gt; \u0026lt;div className=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;span className=\u0026#34;text\u0026#34;\u0026gt;购物车\u0026lt;/span\u0026gt; \u0026lt;span className=\u0026#34;clearCart\u0026#34;\u0026gt; 清空购物车 \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) }  3. 购物车统计功能     在 /src/demos/redux-meituan/components/Cart/index.js 中\n 使用 reduce 统计已选商品数量 使用 reduce 计算已选商品价格 判断已选商品价格是否达到最低配送标准  import classNames from \u0026#39;classnames\u0026#39; import Count from \u0026#39;../Count\u0026#39; import \u0026#39;./index.scss\u0026#39; import { useSelector } from \u0026#39;react-redux\u0026#39; const Cart = () =\u0026gt; { // const cart = []  const { cartList: cart } = useSelector(state =\u0026gt; state.takeaway) // #78.1 统计选中数量  // 同一个商品选择多个的时候，需要参与数量统计  const selectedNumber = cart.reduce( (prev, current) =\u0026gt; { return prev + current.count }, 0) // #78.2 统计价格  const totalPrice = cart.reduce( // 计算价格: prev 代表上一次的结果  (prev, current) =\u0026gt; { return prev + current.price * current.count }, // 默认总价  0 ) // #78.3 判断是否可以结算  // 购物车总价是否大于等于 20  const lowestPrice = 50 const canCheckout = totalPrice \u0026gt;= lowestPrice return ( \u0026lt;div className=\u0026#34;cartContainer\u0026#34;\u0026gt; {/* 遮罩层 添加visible类名可以显示出来 */} \u0026lt;div className={classNames(\u0026#39;cartOverlay\u0026#39;)} /\u0026gt; \u0026lt;div className=\u0026#34;cart\u0026#34;\u0026gt; {/* fill 添加fill类名可以切换购物车状态*/} {/* 购物车数量 */} \u0026lt;div className={classNames( \u0026#39;icon\u0026#39;, canCheckout \u0026amp;\u0026amp; \u0026#39;fill\u0026#39;, )}\u0026gt; {true \u0026amp;\u0026amp; \u0026lt;div className=\u0026#34;cartCornerMark\u0026#34;\u0026gt;{selectedNumber}\u0026lt;/div\u0026gt;} \u0026lt;/div\u0026gt; {/* 购物车价格 */} \u0026lt;div className=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;price\u0026#34;\u0026gt; \u0026lt;span className=\u0026#34;payableAmount\u0026#34;\u0026gt; \u0026lt;span className=\u0026#34;payableAmountUnit\u0026#34;\u0026gt;¥\u0026lt;/span\u0026gt; {totalPrice.toFixed(2)} \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;span className=\u0026#34;text\u0026#34;\u0026gt;预估另需配送费 ¥5\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; {/* 结算 or 起送 */} {canCheckout ? ( \u0026lt;div className=\u0026#34;goToPreview\u0026#34;\u0026gt;去结算\u0026lt;/div\u0026gt; ) : ( \u0026lt;div className=\u0026#34;minFee\u0026#34;\u0026gt;¥{lowestPrice}起送\u0026lt;/div\u0026gt; )} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) }  针对总金额， 需要使用 .toFixed(2) 方法设置小数点后面只有 2位。 否则由于浮点数精度问题， 可能出现以下情况。\n 4. 购物车功能操作     在 /src/demos/redux-meituan/components/Count/index.js 中，\n可以看到， 购物车内项目的 数量及加减操作 都是在 上层 Cart 中传递过来的。\n4.1. 增加 state action     到 /src/demos/redux-meituan/store/modules/takeaway.js 中， 定义\n 数量增加 action  寻找商品是否存在， 存在则增加。   数量减少 action  寻找商品是否存在， 存在且 数量\u0026gt;0 时则减少。 当 数量=0 时则 将商品从购物车中删除。   清空购物车 action 导出所有 action  const takeaway = createSlice({ // 名称  name: \u0026#39;takeaway\u0026#39;, // 初始数据  initialState: { }, // actions  reducers: { // #79.2 减少物品到购物车  minusCartList: (state, action) =\u0026gt; { // 判断购物车中是否已经有该物品  const item = state.cartList.find(item =\u0026gt; item.id === action.payload.id) // 如果有物品  if (item) { // 2. 如果数量大于 1，则数量 -1  if (item.count \u0026gt; 0) { item.count -= 1 } // 如果数量等于 0，则从购物车中删除该物品  if (item.count === 0) { state.cartList = state.cartList.filter(item =\u0026gt; item.id !== action.payload.id) } } }, // #79.2 增加物品到购物车  plusCartList: (state, action) =\u0026gt; { // 判断购物车中是否已经有该物品  const item = state.cartList.find(item =\u0026gt; item.id === action.payload.id) // 如果有物品  if (item) { // 2. 如果数量大于 1，则数量 -1  item.count += 1 } }, // #79.3 清空购物车  clearCartList: (state) =\u0026gt; { state.cartList = [] } } }) // 5. 购物车操作 export const { minusCartList, plusCartList, clearCartList } = takeaway.actions 这里使用的是 Array.find() 方法。 和之前的 Array.findIndex() 差不多。\n4.2. 增加购物车功能     回到 /src/demos/redux-meituan/components/Cart/index.js 中，\nimport classNames from \u0026#39;classnames\u0026#39; import Count from \u0026#39;../Count\u0026#39; import \u0026#39;./index.scss\u0026#39; import { useSelector, useDispatch } from \u0026#39;react-redux\u0026#39; import { clearCartList, plusCartList, minusCartList } from \u0026#39;../../store/modules/takeaway\u0026#39; const Cart = () =\u0026gt; { const dispatch = useDispatch() // #79.1 显示/隐藏 购物车明细  const isShowCartDetail = selectedNumber \u0026gt; 0 // #79.2 购物车内调整商品数量  // 增加  function onCountPlus(item) { dispatch(plusCartList(item)) } // 减少  function onCoundMinus(item) { dispatch(minusCartList(item)) } // #79.3 清空购物车  function clearCart() { dispatch(clearCartList()) } return ( \u0026lt;div className=\u0026#34;cartContainer\u0026#34;\u0026gt; {/* 显示购物车 */} \u0026lt;div className={classNames( \u0026#39;cartPanel\u0026#39;, isShowCartDetail \u0026amp;\u0026amp; \u0026#39;visible\u0026#39; )}\u0026gt; {/* 购物车列表 */} \u0026lt;div className=\u0026#34;scrollArea\u0026#34;\u0026gt; {cart.map(item =\u0026gt; { return ( \u0026lt;div className=\u0026#34;cartItem\u0026#34; key={item.id}\u0026gt; \u0026lt;img className=\u0026#34;shopPic\u0026#34; src={item.picture} alt=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;div className=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;skuInfo\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;name\u0026#34;\u0026gt;{item.name}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;payableAmount\u0026#34;\u0026gt; \u0026lt;span className=\u0026#34;yuan\u0026#34;\u0026gt;¥\u0026lt;/span\u0026gt; \u0026lt;span className=\u0026#34;price\u0026#34;\u0026gt;{item.price}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;skuBtnWrapper btnGroup\u0026#34;\u0026gt; {/* 增加 onPlus 和 onMinus 方法传递 */} \u0026lt;Count count={item.count} onPlus={() =\u0026gt; onCountPlus(item)} onMinus={() =\u0026gt; onCoundMinus(item)} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) })} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) }  5. 购物车显示/隐藏管理      点击购物车时， 切换购物车状态。 只有购物车中 有商品时， 点击购物车 才会 展示显示详情。 购物车 处于展示状态 时， 同时 打开蒙层。 反之亦然。 当 点击蒙层 时， 关闭购物车和蒙层。  在 /src/demos/redux-meituan/components/Cart/index.js 中\n由于购物车状态是 私有状态， 即 不会被其他组件使用。 因此使用 useState 就行了， 不需要使用 Redux\nimport { useState } from \u0026#39;react\u0026#39; const Cart = () =\u0026gt; { // #79.1 显示/隐藏 购物车明细  const isShowCartDetail = selectedNumber \u0026gt; 0 // #79.3 清空购物车  function clearCart() { dispatch(clearCartList()) // #80. 同时关闭购物车  disableCart() } // #80. 购物车显示状态  // 购物车显示的时候， 同时出现蒙层遮盖。 反之  const [isCartVisable, setIsCartVisable] = useState(false) // #80.1 点击购物车，切换购物车状态  function toggleCart() { // 只有当购物车明细显示的时候，才可以显示购物车  isShowCartDetail \u0026amp;\u0026amp; setIsCartVisable(!isCartVisable) } // #80.2 点击蒙层，关闭购物车  function disableCart() { setIsCartVisable(false) } return ( \u0026lt;div className=\u0026#34;cartContainer\u0026#34;\u0026gt; {/* 遮罩层 添加visible类名可以显示出来 */} {/* 显示购物车的时候， 显示蒙层 */} \u0026lt;div className={classNames( \u0026#39;cartOverlay\u0026#39;, isCartVisable \u0026amp;\u0026amp; \u0026#39;visible\u0026#39; )} // #80.2 点击蒙层，关闭购物车 onClick={disableCart} /\u0026gt; \u0026lt;div className=\u0026#34;cart\u0026#34; // #80.1 切换购物车状态 onClick={toggleCart} \u0026gt; \u0026lt;/div\u0026gt; {/* 添加visible类名 div会显示出来 */} {/* 显示购物车 */} \u0026lt;div className={classNames( \u0026#39;cartPanel\u0026#39;, // #80.1 切换购物车状态  isCartVisable \u0026amp;\u0026amp; \u0026#39;visible\u0026#39; )}\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) }  ","description":"1. 添加购物车     在 /src/demos/redux-meituan/components/Cart/index.js 中可以看到 购物车 的相关配置。\n可以看到 购物车 的数据定义是 cart=[] 空数组。\nconst Cart = () =\u0026gt; { const cart = [] // 省略 ... } 在 /src/demos/redux-meituan/components/FoodsCategory/FoodItem/index.js 中\n可以看到 具体商品 配置。 从传入的 props 中解构出来了所有商品字段。\nconst Foods = ({ id, picture, name, unit, description, food_tag_list, month_saled, like_ratio_desc, price, tag, count }) =\u0026gt; { // 省略 ... } 1.1. 优化 store     因此在 /src/demos/redux-meituan/store/modules/takeaway.js 中"},{"id":95,"href":"/books/react/javascript/introduce/input-output/","title":"4. 输入输出","parent":"1. 入门简介","content":"1. 输入      prompt  // 输入 const name = prompt(\u0026#39;请输入你的名字\u0026#39;); 2. 输出      document.write console.log alert  // 输出 console.log(\u0026#39;可以输出信息到控制台: \u0026#39; + name); document.write(\u0026#39;可以输出信息到页面: \u0026#39; + name); alert(\u0026#39;可以弹出一个警告框: \u0026#39; + name); demo     input-output.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;1.5 输入输出\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 输入  const name = prompt(\u0026#39;请输入你的名字\u0026#39;); // 输出  console.log(\u0026#39;可以输出信息到控制台: \u0026#39; + name); document.write(\u0026#39;可以输出信息到页面: \u0026#39; + name); alert(\u0026#39;可以弹出一个警告框: \u0026#39; + name); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","description":"1. 输入      prompt  // 输入 const name = prompt(\u0026#39;请输入你的名字\u0026#39;); 2. 输出      document.write console.log alert  // 输出 console.log(\u0026#39;可以输出信息到控制台: \u0026#39; + name); document.write(\u0026#39;可以输出信息到页面: \u0026#39; + name); alert(\u0026#39;可以弹出一个警告框: \u0026#39; + name); demo     input-output.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;1.5 输入输出\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 输入  const name = prompt(\u0026#39;请输入你的名字\u0026#39;); // 输出  console."},{"id":96,"href":"/books/react/javascript/operator/","title":"4. 运算符","parent":"2. JavaScript","content":"1. 赋值运算符     赋值运算符就是 等于号 =\n扩展： 运算并赋值\n *=, /=, %= +=, -=  const a = \u0026#34;abc\u0026#34; let b = 123 const c = a + b 2. 自增运算符     ++ 是自增运算符。 比较烧脑子， 建议少用。\nlet d = 1 // 先使用后运算 d++ console.log(d) // 2 // 先运算后使用 ++d console.log(d) // 3 以上案例看不出差异。\nlet i = 1 console.log(i++ + ++i + i) // 7; // 1 + (2+1) + 3 // i++ : i 先使用值为 1。 再执行， i=2 // ++i : i 先执行， i=3。 再使用 3 // i : 此次 i=3 常用在循环中，\n// z++ for (let z = 1; z \u0026lt;= 5; z++) { console.log(z) // 1 2 3 4 5 } // 替换: z+=1 for (let z = 1; z \u0026lt;= 5; z += 1) { console.log(z) // 1 2 3 4 5 } 3. 比较运算符     返回值只有两个: true 和 false\n \u0026gt;, \u0026gt;=, \u0026lt;, \u0026lt;= ==, !==: 不比较类型， 只比较值。 ===, !==: 同时比较 类型 和 值  let x = 1 let y = 2 console.log(x \u0026gt; y) // false console.log(x \u0026lt;= y) // true  // 注意隐式转换 console.log(1 == \u0026#39;1\u0026#39;); // true console.log(1 === \u0026#39;1\u0026#39;); // false  console.log(null == undefined); // true console.log(null === undefined); //false 4. 逻辑运算符     逻辑运算符包含 与\u0026amp;\u0026amp;, 或||, 非!\nlet m = 1 let n = 2 let p = 3 console.log(); (!m) // false  console.log(m \u0026lt; n \u0026amp;\u0026amp; n \u0026lt; p) // true console.log(m \u0026lt; n || n \u0026gt; p) // false console.log(!(m \u0026lt; n)); console.log(!true); // false 这个是什么用法？\nconsole.log(m || n) // 1 console.log(m \u0026amp;\u0026amp; n) // 2 5. 运算符的优先级     运算符优先最高的是 ()。 可以改变默认的执行顺序。\nconsole.log(1 + 2 * 3); // 7 console.log((1 + 2) * 3); // 9 6. 算数运算符     运算优先级从上到下\n ** 求 N 次方 *, /, % +, -  let h = 2, j = 3 console.log(h + j); // 5  console.log(h * j); // 6 console.log(h % j); // 2  console.log(h ** j); // 8  console.log(3 * 2 ** 3); // 24 = 3 * (2 ** 3) 7. 位运算符      https://www.w3school.com.cn/js/js_bitwise.asp\n  8. 三元运算符     一个条件， 两个分支。\ncondition ? { true statement } : { false statment} 例如\n// 三元运算符 1 \u0026gt; 2 ? console.log(\u0026#34;true\u0026#34;) : console.log(\u0026#34;false\u0026#34;); // false 3 \u0026gt; 2 ? console.log(\u0026#34;true\u0026#34;) : console.log(\u0026#34;false\u0026#34;); // true  ","description":"1. 赋值运算符     赋值运算符就是 等于号 =\n扩展： 运算并赋值\n *=, /=, %= +=, -=  const a = \u0026#34;abc\u0026#34; let b = 123 const c = a + b 2. 自增运算符     ++ 是自增运算符。 比较烧脑子， 建议少用。\nlet d = 1 // 先使用后运算 d++ console.log(d) // 2 // 先运算后使用 ++d console.log(d) // 3 以上案例看不出差异。\nlet i = 1 console.log(i++ + ++i + i) // 7; // 1 + (2+1) + 3 // i++ : i 先使用值为 1。 再执行， i=2 // ++i : i 先执行， i=3。 再使用 3 // i : 此次 i=3 常用在循环中，"},{"id":97,"href":"/books/react/css/","title":"5. CSS","parent":"","content":" h1 : 选择器 {...}: 状态 color, font-size: 属性 red, 30px: 属性值  h1 { font-size: 30px; color: red; } ","description":" h1 : 选择器 {...}: 状态 color, font-size: 属性 red, 30px: 属性值  h1 { font-size: 30px; color: red; } "},{"id":98,"href":"/books/react/react/communication/props/brothers/","title":"5. 兄弟通信","parent":"1. props 通信","content":"/src/components/communication/Brothers.jsx\n兄弟组件没有关联关系， 因此需要 通过共同的父组件 进行数据的传递。 这并不是一个新东西， 而是将 父传子、子传父 组合案例。\n function Parent() { // 1. 在父节点定义状态数据  const [name, setName] = useState(\u0026#34;\u0026#34;) // 2. 在父节点定义修改状态数据的方法  function changeName(name) { setName(name) } return ( \u0026lt;div\u0026gt; {/* 3. 给 Child A 传递修改数据方法 */} \u0026lt;ChildA onChangeName={changeName} /\u0026gt; {/* 3. 给 Child B 传递数据 */} \u0026lt;ChildB name={name} /\u0026gt; \u0026lt;/div\u0026gt; ); } 在 父节点\n 使用 useState 定义状态数据 name 定义 修改函数 changeName 将修改传输传递给 ChildA, 将状态数据传递给 ChildB  function ChildA({ onChangeName }) { return ( \u0026lt;div\u0026gt; \u0026lt;b\u0026gt;Child A: \u0026lt;/b\u0026gt; {/* 4. Chila A 修改父节点数据 */} \u0026lt;button onClick={() =\u0026gt; onChangeName(\u0026#34;ChildA\u0026#34;)}\u0026gt;点我传递\u0026lt;/button\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;/div\u0026gt; ); } function ChildB(props) { return ( \u0026lt;div\u0026gt; \u0026lt;b\u0026gt;Child B: \u0026lt;/b\u0026gt; {/* 4. Child B 展示父节点数据 */} \u0026lt;span\u0026gt;接收名字: {props.name}\u0026lt;/span\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;/div\u0026gt; ); } 在 子节点\n ChildA 点击事件调用修改函数， 修改父组件的 name 值， setName 触发重新渲染。 ChildB 使用并展示 name 值。   ","description":"/src/components/communication/Brothers.jsx\n兄弟组件没有关联关系， 因此需要 通过共同的父组件 进行数据的传递。 这并不是一个新东西， 而是将 父传子、子传父 组合案例。\n function Parent() { // 1. 在父节点定义状态数据  const [name, setName] = useState(\u0026#34;\u0026#34;) // 2. 在父节点定义修改状态数据的方法  function changeName(name) { setName(name) } return ( \u0026lt;div\u0026gt; {/* 3. 给 Child A 传递修改数据方法 */} \u0026lt;ChildA onChangeName={changeName} /\u0026gt; {/* 3. 给 Child B 传递数据 */} \u0026lt;ChildB name={name} /\u0026gt; \u0026lt;/div\u0026gt; ); } 在 父节点\n 使用 useState 定义状态数据 name 定义 修改函数 changeName 将修改传输传递给 ChildA, 将状态数据传递给 ChildB  function ChildA({ onChangeName }) { return ( \u0026lt;div\u0026gt; \u0026lt;b\u0026gt;Child A: \u0026lt;/b\u0026gt; {/* 4."},{"id":99,"href":"/books/react/javascript/func-class/","title":"5. 函数和类","parent":"2. JavaScript","content":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements#functions_and_classes\n","description":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements#functions_and_classes"},{"id":100,"href":"/books/react/javascript/introduce/literal/","title":"5. 字面量","parent":"1. 入门简介","content":"一个概念， 不用深究。\n在计算机科学中， 字面量(literal) 就是 在计算机中描述的事或物\n 工资是 1000 中 1000 就是 数字字面量 名字是 zhangsan 中的 zhangsan 就是 字符串字面量 [] 表示 数组字面量 {} 表示 对象字面量 以及其他  ","description":"一个概念， 不用深究。\n在计算机科学中， 字面量(literal) 就是 在计算机中描述的事或物\n 工资是 1000 中 1000 就是 数字字面量 名字是 zhangsan 中的 zhangsan 就是 字符串字面量 [] 表示 数组字面量 {} 表示 对象字面量 以及其他  "},{"id":101,"href":"/books/react/javascript/data-types/array/","title":"5. 数组","parent":"3. 数据类型","content":"","description":""},{"id":102,"href":"/books/react/react/jsx/style/","title":"5. 样式的使用","parent":"1. jsx 基础用法","content":"源代码在 /src/components/styles/RootStyle.jsx\n1. 行内样式     在标签内使用使用 style={{key:v1, k2:v2}} 实现样式管理。\n\u0026lt;p style={{ color: \u0026#34;red\u0026#34;, fontSize: \u0026#34;18px\u0026#34; }}\u0026gt;1.1. 行内样式\u0026lt;/p\u0026gt;  外层 {}: 开始 React 语法。 {k1:v1, k2:v2}: 是一个 Object 对象。 key 使用 驼峰 规则: font-size =\u0026gt; fontSize  向上面直接写在行内的方式， 管理起来并不清晰。 因此可以将 样式 赋值给一个 变量 保存。\nexport default function RootStyle() { return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p style={style}\u0026gt;1.2. 行内样式2\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } const style = { color: \u0026#34;blue\u0026#34;, fontSize: \u0026#34;18px\u0026#34; } 2. css 文件     样式当然可以保存到 css 文件中\n/* demo.css */ .demo { color: green; font-size: 18px; font-style: italic; } 在 JSX 文件中使用 import 导入\nimport \u0026#34;./demo.css\u0026#34; export default function RootStyle() { return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p className=\u0026#34;demo\u0026#34;\u0026gt;2. Import CSS\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } 注意： 这里是 React 规则 的 className， 驼峰 命令\n","description":"源代码在 /src/components/styles/RootStyle.jsx\n1. 行内样式     在标签内使用使用 style={{key:v1, k2:v2}} 实现样式管理。\n\u0026lt;p style={{ color: \u0026#34;red\u0026#34;, fontSize: \u0026#34;18px\u0026#34; }}\u0026gt;1.1. 行内样式\u0026lt;/p\u0026gt;  外层 {}: 开始 React 语法。 {k1:v1, k2:v2}: 是一个 Object 对象。 key 使用 驼峰 规则: font-size =\u0026gt; fontSize  向上面直接写在行内的方式， 管理起来并不清晰。 因此可以将 样式 赋值给一个 变量 保存。\nexport default function RootStyle() { return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p style={style}\u0026gt;1.2. 行内样式2\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } const style = { color: \u0026#34;blue\u0026#34;, fontSize: \u0026#34;18px\u0026#34; } 2."},{"id":103,"href":"/books/react/react/communication/","title":"5. 组件通信","parent":"10. React","content":"组件通信 就是 组件之间的数据传递。 根据组件嵌套的关系不同， 有不同的通信方法。\n ","description":"组件通信 就是 组件之间的数据传递。 根据组件嵌套的关系不同， 有不同的通信方法。\n "},{"id":104,"href":"/books/react/react/router/default-router/","title":"5. 默认路由","parent":"6. React-Router","content":"在 router 配置的时候， path 的值使用 * 即可配置默认路径。 当用户访问路径无法匹配时返回。\n通常， 默认路径可以用于 优化 404 页面， 提高用户体验。\n 在 /src/components/router/RootRouter.jsx 中,\nconst router = createBrowserRouter([ { // 使用 * 匹配所有路由  path: \u0026#34;*\u0026#34;, element: \u0026lt;NotFound /\u0026gt; } ]) ","description":"在 router 配置的时候， path 的值使用 * 即可配置默认路径。 当用户访问路径无法匹配时返回。\n通常， 默认路径可以用于 优化 404 页面， 提高用户体验。\n 在 /src/components/router/RootRouter.jsx 中,\nconst router = createBrowserRouter([ { // 使用 * 匹配所有路由  path: \u0026#34;*\u0026#34;, element: \u0026lt;NotFound /\u0026gt; } ]) "},{"id":105,"href":"/books/react/react/router/","title":"6. React-Router","parent":"10. React","content":"","description":""},{"id":106,"href":"/books/react/javascript/data-types/object/","title":"6. 对象","parent":"3. 数据类型","content":"","description":""},{"id":107,"href":"/books/react/javascript/control-flow/","title":"6. 控制流/分支语句","parent":"2. JavaScript","content":" https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements#control_flow\n 3. try \u0026hellip; catch     4. throw     5. return / break / continue     ","description":" https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements#control_flow\n 3. try \u0026hellip; catch     4. throw     5. return / break / continue     "},{"id":108,"href":"/books/react/react/router/router-modes/","title":"6. 路由模式","parent":"6. React-Router","content":"   路由模式 URL表现 底层原理 是否需要后端支持     history url/login history对象+pushState事件 需要   hash url/#/login 监听 hashChange 事件 不需要   memory url ?? ??    1. Hash 模式     使用 createHashRouter 创建 Hash 模式。 path 上有 # 。 单页面模式\nimport { createHashRouter } from \u0026#34;react-router-dom\u0026#34;; const router = createHashRouter([ { path: \u0026#34;/login\u0026#34;, element: \u0026lt;Login /\u0026gt; } ]) 2. Memory 模式     使用 createMemoryRouter 模式。 path 路径 不会 在 URL 上体现出来。 单页面模式\nimport { createMemoryRouter } from \u0026#34;react-router-dom\u0026#34;; const router = createMemoryRouter([ { path: \u0026#34;/login\u0026#34;, element: \u0026lt;Login /\u0026gt; } ]) ","description":"路由模式 URL表现 底层原理 是否需要后端支持     history url/login history对象+pushState事件 需要   hash url/#/login 监听 hashChange 事件 不需要   memory url ?? ??    1. Hash 模式     使用 createHashRouter 创建 Hash 模式。 path 上有 # 。 单页面模式\nimport { createHashRouter } from \u0026#34;react-router-dom\u0026#34;; const router = createHashRouter([ { path: \u0026#34;/login\u0026#34;, element: \u0026lt;Login /\u0026gt; } ]) 2. Memory 模式     使用 createMemoryRouter 模式。 path 路径 不会 在 URL 上体现出来。 单页面模式"},{"id":109,"href":"/books/react/javascript/data-types/array/iter/","title":"6. 迭代器","parent":"5. 数组","content":"前端面试：解构的原理是什么？如何修改这段代码使其正确执行？\nlet [x, y] = {x: 1, y:2} console.log(x,y) ","description":"前端面试：解构的原理是什么？如何修改这段代码使其正确执行？\nlet [x, y] = {x: 1, y:2} console.log(x,y) "},{"id":110,"href":"/books/react/javascript/loop/","title":"7. 循环/迭代","parent":"2. JavaScript","content":" https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements#iterations\n 1. for     1.1. for \u0026hellip; in     1.2. for \u0026hellip; of     1.3. for await\u0026hellip;of     2. while     3. do \u0026hellip; while     catch     ","description":" https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements#iterations\n 1. for     1.1. for \u0026hellip; in     1.2. for \u0026hellip; of     1.3. for await\u0026hellip;of     2. while     3. do \u0026hellip; while     catch     "},{"id":111,"href":"/books/react/javascript/data-types/convert/","title":"7. 类型转换","parent":"3. 数据类型","content":"","description":""},{"id":112,"href":"/books/react/react/react-ts/","title":"9. React TS 支持","parent":"10. React","content":"","description":""},{"id":113,"href":"/books/react/library/","title":"98. 三方库","parent":"","content":"","description":""},{"id":114,"href":"/books/react/demos/","title":"99. 项目案例","parent":"","content":"","description":""},{"id":115,"href":"/books/react/library/chassnames/","title":"classnames","parent":"98. 三方库","content":"    项目地址: https://github.com/JedWatson/classnames\n安装方式     npm install classnames Demo     import classNames from \u0026#39;classnames\u0026#39;; classNames(\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;); // =\u0026gt; \u0026#39;foo bar\u0026#39; classNames(\u0026#39;foo\u0026#39;, { bar: true }); // =\u0026gt; \u0026#39;foo bar\u0026#39; classNames({ \u0026#39;foo-bar\u0026#39;: true }); // =\u0026gt; \u0026#39;foo-bar\u0026#39; classNames({ \u0026#39;foo-bar\u0026#39;: false }); // =\u0026gt; \u0026#39;\u0026#39; classNames({ foo: true }, { bar: true }); // =\u0026gt; \u0026#39;foo bar\u0026#39; classNames({ foo: true, bar: true }); // =\u0026gt; \u0026#39;foo bar\u0026#39;  // lots of arguments of various types classNames(\u0026#39;foo\u0026#39;, { bar: true, duck: false }, \u0026#39;baz\u0026#39;, { quux: true }); // =\u0026gt; \u0026#39;foo bar baz quux\u0026#39;  // other falsy values are just ignored classNames(null, false, \u0026#39;bar\u0026#39;, undefined, 0, { baz: null }, \u0026#39;\u0026#39;); // =\u0026gt; \u0026#39;bar\u0026#39; ","description":"    项目地址: https://github.com/JedWatson/classnames\n安装方式     npm install classnames Demo     import classNames from \u0026#39;classnames\u0026#39;; classNames(\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;); // =\u0026gt; \u0026#39;foo bar\u0026#39; classNames(\u0026#39;foo\u0026#39;, { bar: true }); // =\u0026gt; \u0026#39;foo bar\u0026#39; classNames({ \u0026#39;foo-bar\u0026#39;: true }); // =\u0026gt; \u0026#39;foo-bar\u0026#39; classNames({ \u0026#39;foo-bar\u0026#39;: false }); // =\u0026gt; \u0026#39;\u0026#39; classNames({ foo: true }, { bar: true }); // =\u0026gt; \u0026#39;foo bar\u0026#39; classNames({ foo: true, bar: true }); // =\u0026gt; \u0026#39;foo bar\u0026#39;  // lots of arguments of various types classNames(\u0026#39;foo\u0026#39;, { bar: true, duck: false }, \u0026#39;baz\u0026#39;, { quux: true }); // =\u0026gt; \u0026#39;foo bar baz quux\u0026#39;  // other falsy values are just ignored classNames(null, false, \u0026#39;bar\u0026#39;, undefined, 0, { baz: null }, \u0026#39;\u0026#39;); // =\u0026gt; \u0026#39;bar\u0026#39; "},{"id":116,"href":"/books/react/library/dayjs/","title":"dayjs 时间处理","parent":"98. 三方库","content":"dayjs 是一款 nodejs 的 时间 处理库。 与 js 原生时间库 Date 相比， 更好用。\n 官网: https://day.js.org/docs/en/installation/typescript 中文网: https://dayjs.fenxianglu.cn/category/#node-js  1. install\nnpm install dayjs 2. Usage\nimport dayjs from \u0026#39;dayjs\u0026#39; // https://day.js.org/docs/en/parse/string-format dayjs().format(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;) // 2023-03-18 19:33:24 更多直接查看官网。\n","description":"dayjs 是一款 nodejs 的 时间 处理库。 与 js 原生时间库 Date 相比， 更好用。\n 官网: https://day.js.org/docs/en/installation/typescript 中文网: https://dayjs.fenxianglu.cn/category/#node-js  1. install\nnpm install dayjs 2. Usage\nimport dayjs from \u0026#39;dayjs\u0026#39; // https://day.js.org/docs/en/parse/string-format dayjs().format(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;) // 2023-03-18 19:33:24 更多直接查看官网。"},{"id":117,"href":"/books/react/library/lodash/","title":"lodash 工具库","parent":"98. 三方库","content":"","description":""},{"id":118,"href":"/books/react/react/react-ts/props-ts/","title":"props - ts","parent":"9. React TS 支持","content":"1. 使用 type 或者 interface 注解     props 注解的本质， 就是 限定函数参数类型。\n 可是使用 type 或者 interface 进行注解 在使用 props 的时候  传递整个对象: const TypeProps = (props: Props) =\u0026gt; {} 解耦部分字段，注意不能省略注解类型: const IterfaceProps = ({ name }: IProps) =\u0026gt; {}    type Props = { name: string age: number } // 使用 Type 注解 // 获取整个 props const TypeProps = (props: Props) =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;Props Basic\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{props.name} - {props.age}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ) } interface IProps { name: string age: number } // 使用 interface 注解 // 解构获取 name const IterfaceProps = ({ name }: IProps) =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;Props Basic\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{name}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ) } 2. 特殊传参数: children     children 是一个是特殊的 prop 对象。\n 字段名固定， 只能是 children。 传递位置在 标签对内部 使用 内置 的 React.ReactNode 作为类型， 支持多种类型的数据传入。 支持  React.ReactEelment React.ReactFragment React.ReactPortal string, number, boolean null, undefined     type Props = { children: React.ReactNode } const PropsChildren = ({ children }: Props) =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;span\u0026gt; {children} \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ) } const PropsChildrenRoot = () =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Props Children\u0026lt;/h2\u0026gt; {/* 普通字段 */} \u0026lt;PropsChildren\u0026gt;1123\u0026lt;/PropsChildren\u0026gt; {/* 标签字段 */} \u0026lt;PropsChildren\u0026gt; \u0026lt;b\u0026gt;Children\u0026lt;/b\u0026gt; \u0026lt;/PropsChildren\u0026gt; \u0026lt;/div\u0026gt; ) } export default PropsChildrenRoot 3. 事件: 添加函数参数     组件实现 数据子传父 时， 需要 先实现事件函数的父传子。\n这类 props 重点在于函数参数的注解为 函数。\n 定义方式没有特殊之处。 父传子时定义函数  行内函数： 参数类型自动推断。 外部函数： 需要手动指定函数类型。    import { useState } from \u0026#39;react\u0026#39; // 函数传递 父传子 // 数据传递 子传父 interface IProps { onClickHandler: (msg: string) =\u0026gt; void name: string } const PropsFunction = ({ onClickHandler, name }: IProps) =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;button\u0026gt; \u0026lt;span onClick={() =\u0026gt; onClickHandler(name)}\u0026gt;{name}\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } const PropsFunctionRoot = () =\u0026gt; { const [msg, setMsg] = useState(\u0026#39;\u0026#39;) // 外部定义函数， msg 类型手动注解  const onClickHandler = (msg: string) =\u0026gt; { setMsg(msg) } return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Props Function\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;msg={msg}\u0026lt;/p\u0026gt; {/* 行内函数， msg 类型自动推断 */} \u0026lt;PropsFunction // (parameter) msg: string onClickHandler={(msg) =\u0026gt; { setMsg(msg) }} name={\u0026#39;inline\u0026#39;} /\u0026gt; \u0026lt;PropsFunction onClickHandler={onClickHandler} name={\u0026#39;outside\u0026#39;} /\u0026gt; \u0026lt;/div\u0026gt; ) } export default PropsFunctionRoot ","description":"1. 使用 type 或者 interface 注解     props 注解的本质， 就是 限定函数参数类型。\n 可是使用 type 或者 interface 进行注解 在使用 props 的时候  传递整个对象: const TypeProps = (props: Props) =\u0026gt; {} 解耦部分字段，注意不能省略注解类型: const IterfaceProps = ({ name }: IProps) =\u0026gt; {}    type Props = { name: string age: number } // 使用 Type 注解 // 获取整个 props const TypeProps = (props: Props) =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;Props Basic\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{props."},{"id":119,"href":"/books/react/react/communication/redux/redux-ts/","title":"redux - ts","parent":"3. redux","content":"3. redux     3.1. 导出 store 的 IRootState     参考: https://stackoverflow.com/a/60223837\n// 在 store/index.ts 中  // https://stackoverflow.com/a/60223837 export type IRootState = ReturnType\u0026lt;typeof store.getState\u0026gt; 3.2. 使用 useSelector 指定 state 类型     在使用 useSelector 指定 state 类型\n// 导入 import { IRootState } from \u0026#34;../../../store\u0026#34; // 使用 let { todos } = useSelector((state: IRootState) =\u0026gt; state.todolist) ","description":"3. redux     3.1. 导出 store 的 IRootState     参考: https://stackoverflow.com/a/60223837\n// 在 store/index.ts 中  // https://stackoverflow.com/a/60223837 export type IRootState = ReturnType\u0026lt;typeof store.getState\u0026gt; 3.2. 使用 useSelector 指定 state 类型     在使用 useSelector 指定 state 类型\n// 导入 import { IRootState } from \u0026#34;../../../store\u0026#34; // 使用 let { todos } = useSelector((state: IRootState) =\u0026gt; state.todolist) "},{"id":120,"href":"/books/react/tags/","title":"Tags","parent":"","content":"","description":""},{"id":121,"href":"/books/react/react/hooks/use-context/","title":"useContext 数据传递","parent":"4. Hooks","content":"","description":""},{"id":122,"href":"/books/react/react/hooks/use-effect/","title":"useEffect 生命周期管理","parent":"4. Hooks","content":" Lifecycle of Reactive Effects 深入详解React生命周期  useEffect 是一个 React Hook 函数， 用于在 React 组件中创建 不是由事件引起 而是 由渲染本身引起的操作， 比如 ajax 请求， 更改 DOM 等等\n 说明： 上面的组件中没有发生任何的 用户事件， 组件渲染完毕之后 就向服务器请求数据， 整个过程数据 只由渲染引起的操作。\n触发时机包括：\n 加载 重新渲染 卸载   ","description":" Lifecycle of Reactive Effects 深入详解React生命周期  useEffect 是一个 React Hook 函数， 用于在 React 组件中创建 不是由事件引起 而是 由渲染本身引起的操作， 比如 ajax 请求， 更改 DOM 等等\n 说明： 上面的组件中没有发生任何的 用户事件， 组件渲染完毕之后 就向服务器请求数据， 整个过程数据 只由渲染引起的操作。\n触发时机包括：\n 加载 重新渲染 卸载   "},{"id":123,"href":"/books/react/react/hooks/use-immer/","title":"useImmer 状态数据","parent":"4. Hooks","content":"useImmer 是 useState 的 加强版。\n https://github.com/immerjs/use-immer  npm install immer use-immer ","description":"useImmer 是 useState 的 加强版。\n https://github.com/immerjs/use-immer  npm install immer use-immer "},{"id":124,"href":"/books/react/react/react-ts/use-ref-ts/","title":"useRef - ts","parent":"9. React TS 支持","content":"https://github.com/panda-frontend/react-ts-todolist\n/src/componenets/TodoList/Input/index.tsx\n1. 指定 HTML Element     使用 useRef 的时候， 要指定 HTML Element。 全部元素在 https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement\n// https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement const inputRef = useRef\u0026lt;HTMLInputElement\u0026gt;(null); 1.1. 判断 xxxRef.current 是否存在     由于 xxxRef.current 可能不存在， 因此使用的时候需要判断存在才能取值 xxxRef.current.value\n方式一, 使用 问号\nxxxRef.current?value 方式二， 使用 逻辑语句\nconst addItem = () =\u0026gt; { // 如果值为空，不添加  if (!inputRef.current?.value) { return } const item: ToDo = { id: Date.now(), title: inputRef.current?.value, completed: false } // dispath 调用 action 添加新条目  dispatch(addTodo(item)) // 添加完成后清空 input 框  inputRef.current!.value = \u0026#34;\u0026#34; } 2. 引用稳定的存储器     重点在与 引用稳定\nimport { useEffect, useRef } from \u0026#34;react\u0026#34; const RefContainer = () =\u0026gt; { // 使用 useRef 定义一个变量，用来存储定时器的id  const timerRef = useRef\u0026lt;number | undefined\u0026gt;(undefined) useEffect( () =\u0026gt; { // 保存定时器的id  timerRef.current = window.setInterval(() =\u0026gt; { console.log(\u0026#39;timer\u0026#39;) }, 1000) // 组件卸载时清除定时器  return () =\u0026gt; clearInterval(timerRef.current) }, [] ) return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;RefContainer\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; ) } ","description":"https://github.com/panda-frontend/react-ts-todolist\n/src/componenets/TodoList/Input/index.tsx\n1. 指定 HTML Element     使用 useRef 的时候， 要指定 HTML Element。 全部元素在 https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement\n// https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement const inputRef = useRef\u0026lt;HTMLInputElement\u0026gt;(null); 1.1. 判断 xxxRef.current 是否存在     由于 xxxRef.current 可能不存在， 因此使用的时候需要判断存在才能取值 xxxRef.current.value\n方式一, 使用 问号\nxxxRef.current?value 方式二， 使用 逻辑语句\nconst addItem = () =\u0026gt; { // 如果值为空，不添加  if (!inputRef.current?.value) { return } const item: ToDo = { id: Date.now(), title: inputRef.current?.value, completed: false } // dispath 调用 action 添加新条目  dispatch(addTodo(item)) // 添加完成后清空 input 框  inputRef."},{"id":125,"href":"/books/react/react/hooks/use-ref/","title":"useRef 获取 DOM","parent":"4. Hooks","content":"在 React 中 获取/操作 DOM， 需要使用 useRef 钩子函数\nimport { useRef } from \u0026#39;react\u0026#39;; export default function UseRef() { // 1. 使用 useRef 生成 ref 对象  const inputRef = useRef(null); function showDOM() { // 使用 console.log 查看 ref 对象  console.log(inputRef.current); // 使用 console.dir 展开 ref 对象  console.dir(inputRef.current); // 焦点锁定  inputRef.current.focus() } return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;3. useRef 获取 DOM\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;点击 Button 在控制台查看输出\u0026lt;/p\u0026gt; {/* 将 ref 绑定到标签属性上 */} \u0026lt;input type=\u0026#34;text\u0026#34; ref={inputRef} /\u0026gt; {/* 3. 在渲染完毕时， DOM可用 使用箭头函数调用渲染完毕的 DOM 元素。 */} \u0026lt;button onClick={showDOM}\u0026gt;获取DOM值\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } 1. 绑定对象      使用 useRef() 定义一个 ref  useRef(null) 中的 null 表示， 在绑定之前的对象是 null。\nconst xxxRef = useRef(null) 将 xxxRef 放到 被操作对象 的属性中  \u0026lt;input type=\u0026#34;text\u0026#34; ref={xxxRef} /\u0026gt; 2. 获取 DOM     在 DOM 可用时， 使用 xxxRef.current 可以拿到 DOM 对象。 随后在根据需求操作 DOM 即可\nconsole.log(xxxRef.current) DOM 可用: 页面渲染完毕后， 使用 onClick 事件触发 函数 延迟获取。\n例如， 焦点锁定\ninputRef.current.focus()  ","description":"在 React 中 获取/操作 DOM， 需要使用 useRef 钩子函数\nimport { useRef } from \u0026#39;react\u0026#39;; export default function UseRef() { // 1. 使用 useRef 生成 ref 对象  const inputRef = useRef(null); function showDOM() { // 使用 console.log 查看 ref 对象  console.log(inputRef.current); // 使用 console.dir 展开 ref 对象  console.dir(inputRef.current); // 焦点锁定  inputRef.current.focus() } return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;3. useRef 获取 DOM\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;点击 Button 在控制台查看输出\u0026lt;/p\u0026gt; {/* 将 ref 绑定到标签属性上 */} \u0026lt;input type=\u0026#34;text\u0026#34; ref={inputRef} /\u0026gt; {/* 3."},{"id":126,"href":"/books/react/react/react-ts/use-state-ts/","title":"useState - ts","parent":"9. React TS 支持","content":"1. 类型推导     类型推导的根本\n 不在于 是否简单类型还是复杂类型。 而是 在于初始化的时候，是否传入了明确的值。 如果有明确的值， 就可以推导。  // 简单类型推导 const [count, setCount] = useState(0); // const count: number  // 复杂类型推导 const [names, setNames] = useState([\u0026#39;zhangsan\u0026#39;, \u0026#39;lisi\u0026#39;]); // const names: string[]  // 自定义类型的类型推导 const p: Person = { name: \u0026#39;zhangsan\u0026#39;, age: 18 } const [person, setPerson] = useState(p); // const person: Person 2. 泛型参数      没有明确初始化值的时候， 可以指定 泛型参数 明确类型约束 当指定了泛型参数后，  如果没有指定参数， 则变量为联合类型（ 指定类型 + undefined ） 如果指定了明确参数， 则为指定的类型    // 简单类型 // 只指定 泛型类型， 不指定默认参数。 变量类型为联合类型， 多一个 undefined const [name, setName] = useState\u0026lt;string\u0026gt;() // const name: string | undefined  // 复杂类型 const [ages, setAges] = useState\u0026lt;Array\u0026lt;number\u0026gt;\u0026gt;() // const arr: number[] | undefined const [numbers, setNumbers] = useState\u0026lt;number[]\u0026gt;() // const arr: number[] | undefined  // 自定类型 const [person, setPerson] = useState\u0026lt;IPerson\u0026gt;() // const person: IPerson | undefined  // 同时指定 泛型类型 和 指定参数。 变量类型固定。 const zhangsan: IPerson = { name: \u0026#39;zhangsan\u0026#39;, age: 18 } const [user, setUser] = useState\u0026lt;IPerson\u0026gt;(zhangsan) // const user: IPerson 3. 初始值为 null     在 没有明确默认值 进行初始化的时候使用 null 作为占位符。 规避了 undefined 的默认行为。\n value 的类型是 联合类型， 只能接受 string, null 同样的， setValue 也只能接受 string, null 作为参数  // const value: string | null // const setValue: React.Dispatch\u0026lt;React.SetStateAction\u0026lt;string | null\u0026gt;\u0026gt;  const [value, setValue] = useState\u0026lt;string | null\u0026gt;(null); ","description":"1. 类型推导     类型推导的根本\n 不在于 是否简单类型还是复杂类型。 而是 在于初始化的时候，是否传入了明确的值。 如果有明确的值， 就可以推导。  // 简单类型推导 const [count, setCount] = useState(0); // const count: number  // 复杂类型推导 const [names, setNames] = useState([\u0026#39;zhangsan\u0026#39;, \u0026#39;lisi\u0026#39;]); // const names: string[]  // 自定义类型的类型推导 const p: Person = { name: \u0026#39;zhangsan\u0026#39;, age: 18 } const [person, setPerson] = useState(p); // const person: Person 2. 泛型参数      没有明确初始化值的时候， 可以指定 泛型参数 明确类型约束 当指定了泛型参数后，  如果没有指定参数， 则变量为联合类型（ 指定类型 + undefined ） 如果指定了明确参数， 则为指定的类型    // 简单类型 // 只指定 泛型类型， 不指定默认参数。 变量类型为联合类型， 多一个 undefined const [name, setName] = useState\u0026lt;string\u0026gt;() // const name: string | undefined  // 复杂类型 const [ages, setAges] = useState\u0026lt;Array\u0026lt;number\u0026gt;\u0026gt;() // const arr: number[] | undefined const [numbers, setNumbers] = useState\u0026lt;number[]\u0026gt;() // const arr: number[] | undefined  // 自定类型 const [person, setPerson] = useState\u0026lt;IPerson\u0026gt;() // const person: IPerson | undefined  // 同时指定 泛型类型 和 指定参数。 变量类型固定。 const zhangsan: IPerson = { name: \u0026#39;zhangsan\u0026#39;, age: 18 } const [user, setUser] = useState\u0026lt;IPerson\u0026gt;(zhangsan) // const user: IPerson 3."},{"id":127,"href":"/books/react/react/hooks/use-state/","title":"useState 状态数据","parent":"4. Hooks","content":"React 讲究的是 数据驱动页面。 意思是 当状态数据被修改了，页面内容也会被重新渲染更新。\n如果要上述这个效果， 就需要用到 useState 这个 钩子(Hook)\n 使用 useState 时， 需要先导入。  import { useState } from \u0026#34;react\u0026#34; 使用 const/let 进行结构赋值。 count 和 setCount 是一对 3. useState 创建 状态， 并定义变量的默认值。  count 被称为状态变量，不应该被直接修改， 推荐使用 const 初始化 setCount 是一个函数, 修改 count 的函数。 通过 setCount 修改 count 的值，会触发相关组件的重新渲染。    // const: count 不能被修改 const [count, setCount] = useState(0) // let: count 可以被修改 let [count, setCount] = useState(0) 注意: 使用 let 定义时， count 非只读， 可以直接修改。 但不会触发组件的重新渲染。\n1. 修改简单类型     Demo 在 /src/components/hooks/UseStateSimpleType.jsx\nimport { useState } from \u0026#34;react\u0026#34; export default function UseStateSimpleType() { const [count, setCount] = useState(0) const handler = () =\u0026gt; { const n = count + 1 setCount(n) // 使用 setCount, 修改 count 的值，会触发组件的重新渲染。  } return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;简单类型， number, string\u0026lt;/h3\u0026gt; \u0026lt;button onClick={handler}\u0026gt;Handler1 重新渲染: {count - 1}+1 ={count}\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } 2. 修改对象类型     Demo 在 /src/components/hooks/UseStateObject.jsx\nimport { useState } from \u0026#34;react\u0026#34; export default function UseStateObject() { const [user, setUser] = useState({ \u0026#34;name\u0026#34;: \u0026#34;zhangfei\u0026#34;, \u0026#34;age\u0026#34;: 18, \u0026#34;address\u0026#34;: \u0026#34;beijing\u0026#34; }) // 使用 setCount, 修改 count 的值，会触发组件的重新渲染。  const handler = () =\u0026gt; { setUser( // 注意：setUser 传递时第一个对象， 因此需要使用 {} 包裹。  { ...user, // 解构语法，展开 user 所有属性  age: user.age + 1 // 修改 age 属性  } ) } return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;修改对象某个属性\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;name: {user.name}, age: {user.age}, address: {user.address}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handler}\u0026gt;Handler1 解构语法: \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } 注意： user 是通过 const 定义的\n 其 本身不能直接被修改， 即 user={name:x, age:x, address:x}。 但是其 字段可以被修改， 即 user.age=100  import { useState } from \u0026#34;react\u0026#34; export default function UseStateObject() { const [user, setUser] = useState({ \u0026#34;name\u0026#34;: \u0026#34;zhangfei\u0026#34;, \u0026#34;age\u0026#34;: 18, \u0026#34;address\u0026#34;: \u0026#34;beijing\u0026#34; }) const handler2 = () =\u0026gt; { user.age = user.age + 1 // setUser(user) // 不会触发重新渲染  setUser({ ...user }) } } 另外， 在使用 setUser 的时候， 可以 直接 传入一个 全新 对象\nconst guanyu = { \u0026#34;name\u0026#34;: \u0026#34;guanyu\u0026#34;, \u0026#34;age\u0026#34;: 22, \u0026#34;address\u0026#34;: \u0026#34;tianjing\u0026#34; } const handlerGuanyu = () =\u0026gt; { setUser(guanyu) } 但是 user 本身不能直接传入， 而需要通过 解构 创建一个 全新 对象\n// setUser 传入 user 不会渲染， 数据会被修改， 但页面不会被渲染。 const handler2 = () =\u0026gt; { user.age = user.age + 1 console.log(user); // age 已经修改  setUser(user) // 不会触发重新渲染 } // setUser 通过解构创建一个新对象, 页面会被渲染。 const handler2 = () =\u0026gt; { user.age = user.age + 1 console.log(user); setUser({ // 通过解构创建一个新对象  ...user }) } 使用 setUser(user) 时， 由于传入的是 user ， 虽然其字段发生变化， 但其本身的 指针地址 没有变化， 因此 React 认为没有变化， 不会渲染页面。\n3. 嵌套对象 与 数组     嵌套对象、 数组 与 对象 一样， 都是引用类型。\n因此，在更新渲染时， 都需要传入 新值。 换句话说， 也需要使用 解构语法。\n参考: https://zh-hans.react.dev/reference/react/useState#updating-objects-and-arrays-in-state\n其他      useState - React zhcn  ","description":"React 讲究的是 数据驱动页面。 意思是 当状态数据被修改了，页面内容也会被重新渲染更新。\n如果要上述这个效果， 就需要用到 useState 这个 钩子(Hook)\n 使用 useState 时， 需要先导入。  import { useState } from \u0026#34;react\u0026#34; 使用 const/let 进行结构赋值。 count 和 setCount 是一对 3. useState 创建 状态， 并定义变量的默认值。  count 被称为状态变量，不应该被直接修改， 推荐使用 const 初始化 setCount 是一个函数, 修改 count 的函数。 通过 setCount 修改 count 的值，会触发相关组件的重新渲染。    // const: count 不能被修改 const [count, setCount] = useState(0) // let: count 可以被修改 let [count, setCount] = useState(0) 注意: 使用 let 定义时， count 非只读， 可以直接修改。 但不会触发组件的重新渲染。"},{"id":128,"href":"/books/react/library/uuid/","title":"uuid","parent":"98. 三方库","content":"uuid 生成 UUID 随机数。\n https://github.com/uuidjs/uuid https://www.npmjs.com/package/uuid 1. Install  npm install uuid 2. Create a UUID (ES6 module syntax)\nimport { v4 as uuidv4 } from \u0026#39;uuid\u0026#39;; uuidv4(); // ⇨ \u0026#39;9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d\u0026#39; \u0026hellip; or using CommonJS syntax:\nconst { v4: uuidv4 } = require(\u0026#39;uuid\u0026#39;); uuidv4(); // ⇨ \u0026#39;1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed\u0026#39; const { v4: uuidv4 } = require(\u0026#39;uuid\u0026#39;); uuidv4(); // ⇨ \u0026#39;1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed\u0026#39; ","description":"uuid 生成 UUID 随机数。\n https://github.com/uuidjs/uuid https://www.npmjs.com/package/uuid 1. Install  npm install uuid 2. Create a UUID (ES6 module syntax)\nimport { v4 as uuidv4 } from \u0026#39;uuid\u0026#39;; uuidv4(); // ⇨ \u0026#39;9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d\u0026#39; \u0026hellip; or using CommonJS syntax:\nconst { v4: uuidv4 } = require(\u0026#39;uuid\u0026#39;); uuidv4(); // ⇨ \u0026#39;1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed\u0026#39; const { v4: uuidv4 } = require(\u0026#39;uuid\u0026#39;); uuidv4(); // ⇨ \u0026#39;1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed\u0026#39; "},{"id":129,"href":"/books/react/react/hooks/customize-hook/","title":"自定义 Hook","parent":"4. Hooks","content":"简单的说 自定义 Hook 就是创建一个以 use开头的函数。 往复杂了说还需要考虑各种数据状态、冲突。\n自定义 Hook 通用思路      以 use 开头的函数 函数内部可以调用其他 Hook 通常返回一个数组或对象（包含状态数据和控制方法）， 以便在组件中使用 其他组件则可以直接调用该函数，而不需要关心内部实现  代码在 /src/components/hooks/CustomizeHook.jsx\n 1. 原始对象， 直接管理     export default function CustomizeHook() { // 使用 useState 直接管理  const [isShow, setIsShow] = useState(true) const toggle = () =\u0026gt; { setIsShow(!isShow) } return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;5. CustomizeHook\u0026lt;/h3\u0026gt; \u0026lt;button onClick={toggle}\u0026gt;Toggle: 隐藏或显示\u0026lt;/button\u0026gt; {isShow \u0026amp;\u0026amp; \u0026lt;p\u0026gt;this is a span\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ) } 2. 自定义 useToggle Hook 封装     function useToggle() { // 定义状态  const [isShow, setIsShow] = useState(true) // 定义状态的修改方法  const toggle = () =\u0026gt; { setIsShow(!isShow) } // 通过对象返回  return { isShow, // 状态  toggle // 修改方法  } } export default function CustomizeHook() { // 通过解构方法获取状态数据与修改方法  const { isShow, toggle } = useToggle() return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;5. CustomizeHook\u0026lt;/h3\u0026gt; \u0026lt;button onClick={toggle}\u0026gt;Toggle: 隐藏或显示\u0026lt;/button\u0026gt; {isShow \u0026amp;\u0026amp; \u0026lt;p\u0026gt;this is a span\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ) } 也可以使用 数组 返回状态数据和修改方法\nfunction useToggle() { // ...  // 通过数组返回  return [ isShow, // 状态  toggle // 修改方法  ] } export default function CustomizeHook() { // 通过数组接收状态数据与修改方法  const [ isShow, toggle ] = useToggle() // ... } 3. 自定义 hook 接收 修改方法参数       特别注意:\n  自定义 hook 本身 无法接收参数。 即使定义了形参数，也永远是 undefined。  问题在于调用的时候没有传入 默认参数。 参考 #4. Hook 接受默认参数   需要在 返回的函数上定义形参, 例如下例的 onConfirmDate(date)。  // \u0026#39;data\u0026#39; is declared but its value is never read. const useSelectedDate = (date) =\u0026gt; { // console.log(\u0026#34;typeof date =\u0026gt;\u0026#34;, typeof date); // undefined  // 这里才是真正接受参数的地方  const onConfirmDate = (date) =\u0026gt; { // console.log(\u0026#34;typeof date =\u0026gt;\u0026#34;, typeof date); // object  setSelectedDate(formatedDate(date)) } // 返回 onConfirmDate 接受参数并处理  return [selectedDate, onConfirmDate] } 节选代码参考如下。 完整代码在 /src/demos/AccountBook/src/components/Layout/Month/index.jsx 中。\nimport { useState } from \u0026#39;react\u0026#39; import dayjs from \u0026#39;dayjs\u0026#39; // 方法2. 创建函数统一管理时间格式 const formatedDate = (date) =\u0026gt; { if (!date) { date = new Date() } return dayjs(date).format(\u0026#39;YYYY-MM\u0026#39;) } // 方法3. 自定义 hook 函数管理时间格式和选择 // \u0026#39;data\u0026#39; is declared but its value is never read. const useSelectedDate = (date) =\u0026gt; { // 这 3行 的 date 没什么用, 一致是 undefined, 可以不用传  // console.log(\u0026#34;date input\u0026#34;, date);  // console.log(\u0026#34;typeof date =\u0026gt;\u0026#34;, typeof date);  // const [currentDate, setCurrentDate] = useState(formatedDate(date))  // step1. 定义初始值  const [selectedDate, setSelectedDate] = useState(formatedDate()) // step2. 调用 useState 的方法， 修改状态值  // 注意: 这里是返回出去的函数， 才是 **真正被调用时可传入参数** 的函数。  const onConfirmDate = (date) =\u0026gt; { // console.log(\u0026#34;date onConfirmDatePicker\u0026#34;, date);  // console.log(\u0026#34;typeof onConfirmDatePicker date =\u0026gt;\u0026#34;, typeof date);  setSelectedDate(formatedDate(date)) } // step3. 这里是返回出去的数组， 用于解构赋值  return [selectedDate, onConfirmDate] } const Month = () =\u0026gt; { // 默认关闭时间选择其  const [dateVisable, setDateVisable] = useState(false) // 方法3. 自定义 hook 函数管理时间格式和选择  const [currentDate, onConfirmDate] = useSelectedDate() // 确定提交时间  const onConfirmDatePicker = (date) =\u0026gt; { setDateVisable(false) // 方法3. 自定义 hook 函数  onConfirmDate(date) } return ( \u0026lt;div className=\u0026#34;monthlyBill\u0026#34;\u0026gt; \u0026lt;span className=\u0026#34;text\u0026#34;\u0026gt; {currentDate} \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ) } 4. 自定 Hook 接受 默认参数     在 /src/demos/AccountBook/src/components/Layout/Month/Daily/hooks.js 中\n注意:\n 自定义Hook 就是一个具有 调用特殊性 的 普通函数， 其本身 是可以接受参数的。 返回值 中的 函数也可以接受参数， 并修改 Hook 中的变量值。 （函数闭包）  import classNames from \u0026#39;classnames\u0026#39; import \u0026#39;./index.scss\u0026#39; import lodash from \u0026#39;lodash\u0026#39; import dayjs from \u0026#39;dayjs\u0026#39; const formatDailyDate = (date) =\u0026gt; { if (!date) { date = new Date() } return dayjs(date).format(\u0026#39;YYYY-MM-DD\u0026#39;) } const useDailyResults = (DailyBillList) =\u0026gt; { // console.log(\u0026#34;DailyBillList\u0026#34;, DailyBillList);  // (1) lodash map: 格式化日期  const r1 = lodash.map(DailyBillList, (item) =\u0026gt; { return { ...item, date: formatDailyDate(item.date) } }) // console.log(\u0026#34;r1\u0026#34;, r1);  // (2) lodash groupBy: 按格式化日期分组  const r2 = lodash.groupBy(r1, (item) =\u0026gt; { return item.date }) // (3) 创建数组保存计算结果  const dailyResults = [] // (3.1) 使用 forEach 遍历数组  lodash.forEach(r2, (value, key) =\u0026gt; { // (3.2) 使用 Array.reduce 计算  const ret = value?.reduce( (pre, cur) =\u0026gt; { if (cur.type === \u0026#34;pay\u0026#34;) { pre.pay += cur.money } if (cur.type === \u0026#34;income\u0026#34;) { pre.income += cur.money } pre.balance = pre.pay + pre.income // 必须要 return pre 下一次才能拿到 pre， 否则就是 undefined  return pre }, { pay: 0, income: 0, balance: 0, date: key, } ) dailyResults.push(ret) }) // (4) lodash orderBy: 按统计后的日期排序  return lodash.orderBy(dailyResults, [\u0026#39;date\u0026#39;], [\u0026#39;desc\u0026#39;]) } export default useDailyResults ","description":"简单的说 自定义 Hook 就是创建一个以 use开头的函数。 往复杂了说还需要考虑各种数据状态、冲突。\n自定义 Hook 通用思路      以 use 开头的函数 函数内部可以调用其他 Hook 通常返回一个数组或对象（包含状态数据和控制方法）， 以便在组件中使用 其他组件则可以直接调用该函数，而不需要关心内部实现  代码在 /src/components/hooks/CustomizeHook.jsx\n 1. 原始对象， 直接管理     export default function CustomizeHook() { // 使用 useState 直接管理  const [isShow, setIsShow] = useState(true) const toggle = () =\u0026gt; { setIsShow(!isShow) } return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;5. CustomizeHook\u0026lt;/h3\u0026gt; \u0026lt;button onClick={toggle}\u0026gt;Toggle: 隐藏或显示\u0026lt;/button\u0026gt; {isShow \u0026amp;\u0026amp; \u0026lt;p\u0026gt;this is a span\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ) } 2."}]