[{"id":0,"href":"/books/react/","title":"","parent":"","content":"react 18 notebook     所有文档      项目笔记  资源      黑马程序员前端React18入门到实战视频教程  React18 - 配套资料    ","description":"react 18 notebook     所有文档      项目笔记  资源      黑马程序员前端React18入门到实战视频教程  React18 - 配套资料    "},{"id":1,"href":"/books/react/SUMMARY/","title":"Summary","parent":"","content":"React 18 学习笔记      初始化项目  ","description":"React 18 学习笔记      初始化项目  "},{"id":2,"href":"/books/react/demos/bili-comment/","title":"1. B站评论","parent":"99. 项目案例","content":"1. 安装 sass 支持     npm install sass 2. 评论     使用 useState 管理评论状态\nconst [BiliComments, setBiliComments] = useState(defaultList) 2.1 评论: 使用 Map() 方法渲染     { BiliComments.map( item =\u0026gt; \u0026lt;div className=\u0026#34;content-wrap\u0026#34; key={item.rpid}\u0026gt; // ...  \u0026lt;/div\u0026gt; ) } 2.2. 删除按钮： 条件渲染     {user.uid === item.user.uid \u0026amp;\u0026amp; \u0026lt;span\u0026gt;删除\u0026lt;/span\u0026gt;} 2.3. 删除事件: 点击效果     需要使用一个箭头函数， 实现 点击触发 的效果。\nfunction deleteComment(rpid) { setBiliComments(BiliComments.filter(item =\u0026gt; item.rpid !== rpid)) } \u0026lt;span className=\u0026#34;delete-btn\u0026#34; onClick={() =\u0026gt; deleteComment(item.rpid)} \u0026gt;删除\u0026lt;/span\u0026gt; 2.4. 更新评论: 使用 filter 实现数据删除     const newList = BiliComments.filter(item =\u0026gt; item.rpid !== rpid) setBiliComments(newList) 2.5 头像: 添加标签     使用 src 属性展示头像\n\u0026lt;div className=\u0026#34;bili-avatar\u0026#34;\u0026gt; \u0026lt;img className=\u0026#34;bili-avatar-img\u0026#34; alt=\u0026#34;\u0026#34; src={item.user.avatar} /\u0026gt; \u0026lt;/div\u0026gt; 3. 评论管理     3.1 使用 ClassName 标签高亮     首先， 使用 useState 管理所选择的排序标签。 hot 作为默认值。\n创建函数 activeClassName 管理标签状态， 与状态类型一致时， 返回 active 类。 所选择的 tab 整体作为参数传入（实际这里只需要类型即可）\nconst [activeType, setActiveType] = useState(\u0026#34;hot\u0026#34;) // 渲染 active 的 tag function activeClassName(tab) { // 三元表达式  // return item.type === activeType ? \u0026#39;nav-item active\u0026#39; : \u0026#39;nav-item\u0026#39;  // go 写法  if (tab.type === activeType) { return \u0026#39;nav-item active\u0026#39; } return \u0026#39;nav-item\u0026#39; } 注意: 上述 三元表达式 和 Go 写法 都是正确的。 都是分支流程控制， 使用 JS Switch 语法 - MDN Web Docs 也是可以的。\n其次， 使用 数组Array 的 map 方法生成所有标签。\n\u0026lt;li className=\u0026#34;nav-sort\u0026#34;\u0026gt; {/* 高亮类名： active */} {/* \u0026lt;span className=\u0026#39;nav-item\u0026#39;\u0026gt;最新\u0026lt;/span\u0026gt; */} {/* \u0026lt;span className=\u0026#39;nav-item active\u0026#39;\u0026gt;最火\u0026lt;/span\u0026gt; */} { tabs.map( (tab) =\u0026gt; \u0026lt;span key={tab.type} className={activeClassName(tab)} \u0026gt;{tab.text}\u0026lt;/span\u0026gt; ) } \u0026lt;/li\u0026gt; 注意: 在标签中\n 一定不要忘记 key 属性 className 属性是 React 语法， 小驼峰。 多个 className 值合并， 中间使用 空格 分割， 例如 nav-item active。  3.2 评论排序     这里使用了第三方库 lodash 进行数据处理。\n安装 lodash 库\nnpm install lodash 导入 lodash 库。 不太清楚 官方 和 黑马 视频为什么要使用 下划线_ 作为导入后的包名， 但我自己选择使用 lodash。\n// 官方 // var _ require(\u0026#39;lodash\u0026#39;);  // 黑马视频 // import _ from \u0026#39;lodash\u0026#39;;  // 我自己 import lodash from \u0026#39;lodash\u0026#39;; 首先， 定义函数 selectTag 作为选择 排序标签 的事件 回调函数。\n 这里使用了 switch 控制分支流程。 使用 switch 的时候， 一直要注意使用 break 退出， 否则会默认一直下坠，直到遇到 退出控制 或 结束。  这一点与 Go 不同， Go 是用户通过指定 fallthrough 手动下坠的。   由于 评论列表 是通过 useState 管理且 只读不可变， 因此不能直接使用 Array.sort() 进行排序， 使用的 lodash.orderBy 指定排序方法。  // 选择排序芳芳  function selectTab(tab) { setActiveType(tab.type) // tab.type === \u0026#34;hot\u0026#34; ?  // setBiliComments(lodash.orderBy(BiliComments, \u0026#39;like\u0026#39;, \u0026#39;desc\u0026#39;)) :  // setBiliComments(lodash.orderBy(BiliComments, \u0026#39;ctime\u0026#39;, \u0026#39;desc\u0026#39;))  switch (tab.type) { case \u0026#34;hot\u0026#34;: setBiliComments(lodash.orderBy(BiliComments, \u0026#39;like\u0026#39;, \u0026#39;desc\u0026#39;)); // 一定不能忘记这个 break。 否则  // 1. 不再判断 case condition 是否成立  // 2. 继续执行随后的所有 case statement， 直到退出。  break; default: setBiliComments(lodash.orderBy(BiliComments, [\u0026#39;ctime\u0026#39;], [\u0026#39;desc\u0026#39;])); } } 注意：\n lodash.orderBy() 是支持多条件排序的， 需要使用 两个数组 提供 优先级条件字段 以及 排序方式， 一一对应。 如果只有一个字段， 可以省略不使用数组。  最后， 使用 onClick 事件调用函数即可。\n注意 点击事件中 一定 要使用 箭头 函数封装， 以实现点击触发的效果， 否则就直接执行了。\n\u0026lt;span key={tab.type} className={activeClassName(tab)} // 1. 传入变量 // onClick={(item) =\u0026gt; selectTab(item)} onClick={() =\u0026gt; selectTab(tab)} \u0026gt;{tab.text}\u0026lt;/span\u0026gt; 3.2.1. classNames 类名控制     classnames 是一个第三方库， 用于方便的管理 className。\n如果说之前的两种方式是 手动拼接 类名是 手动挡 的话， 那么使用 classnames 就是自动挡。\n首先 使用 npm 安装\n$ npm install classnames 其次 使用 import 导入\nimport classNames from \u0026#39;classnames\u0026#39;; 最后 根据实际需求，返回 className\n// 渲染 active 的 tag  function activeClassName(tab) { // 1. 三元表达式  // return item.type === activeType ? \u0026#39;nav-item active\u0026#39; : \u0026#39;nav-item\u0026#39;  // 2. Go 写法  // if (tab.type === activeType) {  // return \u0026#39;nav-item active\u0026#39;  // }  // return \u0026#39;nav-item\u0026#39;  // 3. classnames 三方库。 前两种是手动拼接， 容易出错  return classNames(\u0026#34;nav-item\u0026#34;, { active: tab.type === activeType }) } 经过 classNames 对参数的处理后， 会将满足条件的所有参数 拼接 成 字符串。\n  (1) 为 静态 属性， 始终会返回。 (2,3) 为 动态 属性， 根据条件表达式结果返回。 (2) 是 属性名。 (3) 是 布尔表达式， 控制当前属性是否可用。 最终 classNames 返回的就是一个 空格 分割的字符串。  3.3. 添加评论     使用 useState 创建一个状态数据， 用于实现 input框 的数据双向绑定。\n// 添加评论 // 1. 获取评论内容 // 使用 useState 管理需要操作的数据 const [inputValue, setInputValue] = useState(\u0026#34;\u0026#34;) 使用 onChange 实现数据的双向绑定\n 使用 value={inputValue} 实现数据 从 State 到 UI 使用 onChange 实现数据 从 UI 到 State  {/* 评论框 */} \u0026lt;textarea className=\u0026#34;reply-box-textarea\u0026#34; placeholder=\u0026#34;发一条友善的评论\u0026#34; value={inputValue} onChange={(e) =\u0026gt; setInputValue(e.target.value)} /\u0026gt; 创建函数， 实现模拟数据的发布。  注意： 这里是函数内部， 使用 inputValue 就是内部变量。 就不再需要使用 {inputValue} 这种模版格式了。\nfunction postComment() { console.log(\u0026#39;postComment\u0026#39;); // 2. 构建评论对象  const newComment = { rpid: 1, user: { uid: \u0026#39;30009257\u0026#39;, avatar: \u0026#39;https://www.haoba.cc/logo\u0026#39;, uname: \u0026#39;黑马前端\u0026#39;, }, content: inputValue, ctime: \u0026#39;10-19 09:00\u0026#39;, like: 66, } // 3. 添加到评论列表  setCommentList([ ...commentList, newComment ]) } commentList 是 只读 的， 需要使用 ES 结构 语法。 ...commentList\n在发布按钮上绑定 onClick 事件， 调用 postComment 发布数据。  注意: 这里按钮对象实际上是两层（一层框， 一层文字）， 需要将 onClick 事件绑定到框上。\n{/* 发布按钮 */} \u0026lt;div className=\u0026#34;reply-box-send\u0026#34; onClick={postComment} \u0026gt; \u0026lt;div className=\u0026#34;send-text\u0026#34;\u0026gt;发布\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 4. 优化1: 使用 useEffect 从服务端获取数据     4.1. 模拟数据服务器      安装 json-server 模拟服务器。  $ npm install json-server 启动服务  数据在 /src/demos/bili-comments/json-server/db.json 中\n$ src/demos/bili-comments/json-server $ make # npx json-server db.json --port 9001 4.2. 使用 axios 请求服务器数据      安装 axios  $ npm install axios 清空 defaultList 或者留下一条 提示数据 依旧使用 useState 管理评论数据。 在使用 异步函数 和 axios 获取评论数据 依赖项 数据设置为空，只下载一次数据。 由于没有完成对应的评论提交功能。  const [commentList, setCommentList] = useState(defaultList) useEffect(() =\u0026gt; { // 定义异步获取函数  async function getComments() { await axios.get(\u0026#39;http://localhost:9001/comments\u0026#39;) .then(res =\u0026gt; { console.log(\u0026#39;res\u0026#39;, res); setCommentList(res.data) }).catch(err =\u0026gt; { console.log(\u0026#39;err\u0026#39;, err); }) } // 执行异步函数， 获取数据  getComments() }, // 由于没有完成 post 请求更新 json-server 发表评论逻辑。 因此设置  // 依赖项为空数组， 只会执行一次  // 无法真正更新数据。  [] ) 5. 优化2: 自定义 Hook 函数封装获取评论数据     这里的自定义 Hook 封装就比较简单了。\n 将 useState 和 useEffect 放在统一的自定义 Hook 中统一管理。 数据初始化好成功后， 已经将 commentList 和 setCommentList 返回给外部调用  // 自定义获取 Comments 的 Hook function useGetComments() { const [commentList, setCommentList] = useState(defaultList) useEffect(() =\u0026gt; { // 定义异步获取函数  async function getComments() { await axios.get(\u0026#39;http://localhost:9001/comments\u0026#39;) .then(res =\u0026gt; { console.log(\u0026#39;res\u0026#39;, res); setCommentList(res.data) }).catch(err =\u0026gt; { console.log(\u0026#39;err\u0026#39;, err); }) } // 获取数据  getComments() }, // 由于没有完成 post 请求更新 json-server 发表评论逻辑。 因此设置  // 依赖项为空数组， 只会执行一次  // 无法真正更新数据。  [] ) return [commentList, setCommentList] } 从外部使用来看， 从此不再关心数据是 defaultList 中的默认数据， 还是从 json-server 获取的远端数据。  const BiliComments = () =\u0026gt; { // 原本使用 useState 管理数据  // const [commentList, setCommentList] = useState(defaultList)  // ... 使用 useEffect 从远端获取评论数据  // 直接使用自定义 Hook 函数获取数据。 将 useState 和 useEffect 封装在再内  const [commentList, setCommentList] = useGetComments() // ... 其他使用方式不变。 } 6. 优化3: 封装评论项 Item 组件      抽象原则：\n 外部组件作为 智能组件 负责数据交互 Item 组件作为 UI 组件 负责数据渲染  6.1 定义 Item 组件     基本上， 就是直接结构全部复制过来。\nItem 和外部组件是一个典型的 父子解构。\n因此在定义 Item 的时候， 使用 解构赋值 获取 item 和 onDeleteComment 进行展示和操作数据。\n// 定义 Item 组件 // 使用 结构方法获取传递的 props 参数 function Item({ item, onDeleteComment }) { return ( \u0026lt;div className=\u0026#34;reply-item\u0026#34;\u0026gt; // ... 省略  {/* 判断渲染删除按钮 */} {user.uid === item.user.uid \u0026amp;\u0026amp; \u0026lt;span className=\u0026#34;delete-btn\u0026#34; onClick={() =\u0026gt; onDeleteComment(item.rpid)} \u0026gt;删除\u0026lt;/span\u0026gt;} // ... 省略  \u0026lt;/div\u0026gt; ) } 6.2 调用 Item 组件     在外部组件， 还是简单的使用 数组 的 map 方法便利内容。 将 item 数据传递给 Item 组件。\n注意: 这里提供 删除回调函数 的时候， 使用了 on前缀。 表示调用执行。\nconst BiliComments = () =\u0026gt; { const [commentList, setCommentList] = useGetComments() function deleteComment(rpid) { // ... 省略  } return ( \u0026lt;div className=\u0026#34;app\u0026#34; \u0026gt; {/* 评论列表 */} \u0026lt;div className=\u0026#34;reply-list\u0026#34;\u0026gt; {/* 评论项 */} {/* 使用 Item 组件 */} {commentList.map( item =\u0026gt; \u0026lt;Item key={item.rpid} // 定义唯一值 item={item} // 传递 item 数据 onDeleteComment={deleteComment} // 传递删除函数 /\u0026gt; )} \u0026lt;/div\u0026gt; \u0026lt;/div \u0026gt; ) } ","description":"1. 安装 sass 支持     npm install sass 2. 评论     使用 useState 管理评论状态\nconst [BiliComments, setBiliComments] = useState(defaultList) 2.1 评论: 使用 Map() 方法渲染     { BiliComments.map( item =\u0026gt; \u0026lt;div className=\u0026#34;content-wrap\u0026#34; key={item.rpid}\u0026gt; // ...  \u0026lt;/div\u0026gt; ) } 2.2. 删除按钮： 条件渲染     {user.uid === item.user.uid \u0026amp;\u0026amp; \u0026lt;span\u0026gt;删除\u0026lt;/span\u0026gt;} 2.3. 删除事件: 点击效果     需要使用一个箭头函数， 实现 点击触发 的效果。"},{"id":3,"href":"/books/react/react/jsx/","title":"1. jsx 基础用法","parent":"3. React","content":"","description":""},{"id":4,"href":"/books/react/react/jsx/introduce/","title":"1. jsx 的介绍","parent":"1. jsx 基础用法","content":"之前在 /src/App.js 中说到了 className 是 react 语法。 更准确的说是 JSX 语法。\n这是一个带有变量的例子\n// 定义 变量 const message = \u0026#34;this is a message\u0026#34; function App() { // return 中的内容是 jsx 语法  return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; // className 不是 HTML 语法  {message} // 使用变量  \u0026lt;/div\u0026gt; ); } 1. 什么是 jsx     jsx 是 js 的一种扩展语法， 继承了 js 和 xml 的优点。\n 可以使用 HTML 的声明式模版。 可以使用 js 的可编程能力。  由于 jsx 本身不是标准语法。 因此需要使用 Babel 进行编译后， 才能在 浏览器 上运行。 TypeScript同理， 也是需要编译成 js 后才能在浏览器上运行。\n 可以到 Babel 官网查看编译后的结果\n其他      Babel 官网: https://babeljs.io/repl  ","description":"之前在 /src/App.js 中说到了 className 是 react 语法。 更准确的说是 JSX 语法。\n这是一个带有变量的例子\n// 定义 变量 const message = \u0026#34;this is a message\u0026#34; function App() { // return 中的内容是 jsx 语法  return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; // className 不是 HTML 语法  {message} // 使用变量  \u0026lt;/div\u0026gt; ); } 1. 什么是 jsx     jsx 是 js 的一种扩展语法， 继承了 js 和 xml 的优点。\n 可以使用 HTML 的声明式模版。 可以使用 js 的可编程能力。  由于 jsx 本身不是标准语法。 因此需要使用 Babel 进行编译后， 才能在 浏览器 上运行。 TypeScript同理， 也是需要编译成 js 后才能在浏览器上运行。"},{"id":5,"href":"/books/react/react/events/on-click/","title":"1. onClick 点击事件","parent":"2. 事件绑定","content":" 事件名称统一为 onXXXX Hanlder 函数支持多种方式定义， 变量形式 与 函数形式  // 不接受参数 // 变量形式 const handler1 = () =\u0026gt; { console.log(count); count = count + 1 } // 接收事件 // 函数形式 function handler2(event) { console.log(event) // count = count + 2 } 这里是是 onClick 点击事件。\n1. 不接受参数     这种最简单， 只需要在 标签 中的 属性 中， 使用 onClick 事件时 指定 调用 handler 函数 即可。\n\u0026lt;button onClick={handler1}\u0026gt;button +1\u0026lt;/button\u0026gt; 如上， 是在 button 中接收了的 onClick 事件。 注意\n 需要使用 花括号{} 开启 jsx 执行函数(表达式)。 handler 函数 不需要被执行， 即没有跟 园括号。  function EventOnClick() { let count = 0 // 不接受参数  // 变量形式  const handler1 = () =\u0026gt; { console.log(count); count = count + 1 } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count={count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handler1}\u0026gt;button +1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default EventOnClick; 2. 接收事件参数     在事件触发是， React 是 默认 传递 事件参数 的，\n handler 函数只需要准备好 形参 接收即可。 在调用时 不需要 额外手工参数 实参。  这一点与 传递自定义参数 不同， 可以对比接下来的 第 3 点。\nfunction EventOnClick() { let count = 0 // 接收事件  // 函数形式  function handler2(event) { console.log(event) // count = count + 2  } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count={count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handler2}\u0026gt;button e\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default EventOnClick; 3. 接收自定义参数     其实就是在普通的 handler 函数的基础上， 在 调用 的时候使用 箭头 函数封装了一次。\n// 调用 onClick={() =\u0026gt; { handler3(count) }} 这里你可以看到有连个 花括号\n 外层： 是启用 jsx 的语法。 内层： 箭头函数的函数体边界。 其实这里也可以省略成以下形式  // 调用 onClick={() =\u0026gt; handler3(count) } 完整代码如下\nfunction EventOnClick() { let count = 0 // 接受参数  function handler3(n) { console.log(n); count = count + 3 } // 接受参数和事件  const handler4 = (n, event) =\u0026gt; { console.log(n, event); count = count + 4 } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count={count}\u0026lt;/p\u0026gt; {/* 注意这里是箭头函数 */} \u0026lt;button onClick={() =\u0026gt; { handler3(count) }}\u0026gt;button(+3)\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; handler3(count) }\u0026gt;button(+3)\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default EventOnClick; 4. 接收自定义参数与事件参数     同时接收 自定义参数 和 事件参数： 其实也很简单， 就是在上一个的技术上， 通过 箭头 函数获取了 事件参数， 再传给了 handler 函数。 可以说是 2,3 的结合体。\n注意： 在传递参数时， 需要注意参数的位置。\nfunction EventOnClick() { let count = 0 // 接受参数和事件  const handler4 = (n, event) =\u0026gt; { console.log(n, event); count = count + 4 } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count={count}\u0026lt;/p\u0026gt; {/* 1. 箭头函数， 2 参数位置 */} \u0026lt;button onClick={(event) =\u0026gt; { handler4(count, event) }}\u0026gt;button(+4,e)\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default EventOnClick; 其他      Event handlers - React Learn  ","description":"事件名称统一为 onXXXX Hanlder 函数支持多种方式定义， 变量形式 与 函数形式  // 不接受参数 // 变量形式 const handler1 = () =\u0026gt; { console.log(count); count = count + 1 } // 接收事件 // 函数形式 function handler2(event) { console.log(event) // count = count + 2 } 这里是是 onClick 点击事件。\n1. 不接受参数     这种最简单， 只需要在 标签 中的 属性 中， 使用 onClick 事件时 指定 调用 handler 函数 即可。\n\u0026lt;button onClick={handler1}\u0026gt;button +1\u0026lt;/button\u0026gt; 如上， 是在 button 中接收了的 onClick 事件。 注意"},{"id":6,"href":"/books/react/react/communication/props/","title":"1. props 通信","parent":"5. 组件通信","content":"","description":""},{"id":7,"href":"/books/react/library/redux/counter-demo/","title":"1. Redux计数器（纯网页版）","parent":"redux","content":"在不使用 React 框架的情况下。 仅使用 Redux 实现一个计数器功能。\n 使用步骤      定义一个 reducer 函数。 （根据当前想要做的修改返回一个心的状态） 使用 createStore 方法传入 reducer， 生成一个 store 实例对象 使用 store 实例的 subscribe 方法 订阅数据变化。 （数据一旦变化， 可以得到通知） 使用 store 实例的 dispatch 方法提交 action 对象 触发数据变化。 （告诉 reducer 所需要执行的操作） 使用 store 实例 getState 方法 获取最新的状态数据， 并更新到试图中。  注意： Redux 不会主动更新视图， 需要主动调用 document DOM 绑定数据。\n示例代码     本案例中使用 redux@4.2.1， 最新版本 5.0.x API 有新变化， 页面代码不兼容。 （2024-02-18）\n在 /src/components/communication/redux/redux.html 中。\n注意: 在导入外部 redux.js 是时候 注意下载地址。 不要使用成了富文本网页。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 展示界面 --\u0026gt; \u0026lt;button id=\u0026#34;decrement\u0026#34;\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;span id=\u0026#34;counter\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;button id=\u0026#34;increment\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;!-- 导入外部 redux --\u0026gt; \u0026lt;!-- 网页地址, 非 RAW : https://unpkg.com/browse/redux@5.0.1/dist/redux.d.ts --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;https://unpkg.com/redux@4.2.1/dist/redux.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 手写 redux 控制 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; // 1. 创建 reducer  // 作用： 根据不同的 action 修改 state 状态  // state: 管理当前数据的初始化状态  // action: 对象。 通过 type 属性来判断执行的操作  function reducer(state = { count: 0 }, action) { if (action.type === \u0026#39;INCREMENT\u0026#39;) { return { count: state.count + 1 } } if (action.type === \u0026#39;DECREMENT\u0026#39;) { return { count: state.count - 1 } } } // 2. 使用 reducer 创建 store  // 使用 redux 提供的 createStore 方法创建 store  // 这里必须使用 `Redux.createStore`， 直接使用 createStore 报错。  const store = Redux.createStore(reducer) // 3. 使用 dispatch 修改 state 状态  const inBtn = document.getElementById(\u0026#39;increment\u0026#39;) inBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 增加  store.dispatch({ type: \u0026#39;INCREMENT\u0026#39; }) }) const deBtn = document.getElementById(\u0026#39;decrement\u0026#39;) deBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 减少  store.dispatch({ type: \u0026#39;DECREMENT\u0026#39; }) }) // 4. 使用 subscribe 订阅 store  store.subscribe(() =\u0026gt; { console.log(\u0026#39;state 更新了\u0026#39;); // 5. 使用 getState 获取最新的 state 状态更新到视图  // 获取最新的 state  const state = store.getState() // 更新界面  document.getElementById(\u0026#39;counter\u0026#39;).innerText = state.count }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","description":"在不使用 React 框架的情况下。 仅使用 Redux 实现一个计数器功能。\n 使用步骤      定义一个 reducer 函数。 （根据当前想要做的修改返回一个心的状态） 使用 createStore 方法传入 reducer， 生成一个 store 实例对象 使用 store 实例的 subscribe 方法 订阅数据变化。 （数据一旦变化， 可以得到通知） 使用 store 实例的 dispatch 方法提交 action 对象 触发数据变化。 （告诉 reducer 所需要执行的操作） 使用 store 实例 getState 方法 获取最新的状态数据， 并更新到试图中。  注意： Redux 不会主动更新视图， 需要主动调用 document DOM 绑定数据。\n示例代码     本案例中使用 redux@4.2.1， 最新版本 5.0.x API 有新变化， 页面代码不兼容。 （2024-02-18）"},{"id":8,"href":"/books/react/javascript/introduce/","title":"1. 入门简介","parent":"JavaScript","content":"视频课程     黑马程序员 JavaScript 入门到精通: https://www.bilibili.com/video/BV1Y84y1L7Nn\n","description":"视频课程     黑马程序员 JavaScript 入门到精通: https://www.bilibili.com/video/BV1Y84y1L7Nn"},{"id":9,"href":"/books/react/react/hooks/use-effect/basic/","title":"1. 基础语法","parent":"useEffect 生命周期管理","content":"1. 语法规则     import { useEffect } from \u0026#39;react\u0026#39; useEffect(()=\u0026gt;{}, []) useEffect 支持两个参数\n 参数一是 函数 ()=\u0026gt;{}。 可以称其为 副作用函数， 在函数内部可以放置要执行的操作。  如果函数由返回值， 则表示在 组件卸载时执行， 这个后面讨论。   参数二是 数组 []（可选）， 在数组里放置 依赖项。  不同依赖项数据量导致渲染行为不一致， 这个后面讨论。    在 /src/components/hooks/UseEffectBasic.jsx 中。\nimport { useEffect, useState } from \u0026#34;react\u0026#34; const URL = \u0026#39;http://geek.itheima.net/v1_0/channels\u0026#39; export default function UseEffectBasic() { const [channels, setChannels] = useState([]) // 定义副作用函数， 只执行一次  useEffect(() =\u0026gt; { console.log(\u0026#39;useEffect\u0026#39;) // 定义异步函数  // https://juejin.cn/post/6844903858422956040  // https://blog.51cto.com/u_15283585/5220471  async function fetchData() { const res = await fetch(URL) .catch(console.error) // 捕获错误  // 如果请求成功  if (res?.status === 200) { const resJson = await res.json() setChannels(resJson.data.channels) } } // 调用异步函数  fetchData() }, []) return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;UseEffect 基本信息\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;asss \u0026lt;/li\u0026gt; { channels.map((item, index) =\u0026gt; { return \u0026lt;li key={index}\u0026gt;{item.name}\u0026lt;/li\u0026gt; }) } \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } 在 fetch 请求处理网络错误 #55 处理了 异步请求 的访问错误问题。\n 使用 catch 捕获错误。 这点和 axios 差不多。 返回的 res 时 void 或者 Response。 所以在判断 res?.status 的时候， 需要使用 ?  ","description":"1. 语法规则     import { useEffect } from \u0026#39;react\u0026#39; useEffect(()=\u0026gt;{}, []) useEffect 支持两个参数\n 参数一是 函数 ()=\u0026gt;{}。 可以称其为 副作用函数， 在函数内部可以放置要执行的操作。  如果函数由返回值， 则表示在 组件卸载时执行， 这个后面讨论。   参数二是 数组 []（可选）， 在数组里放置 依赖项。  不同依赖项数据量导致渲染行为不一致， 这个后面讨论。    在 /src/components/hooks/UseEffectBasic.jsx 中。\nimport { useEffect, useState } from \u0026#34;react\u0026#34; const URL = \u0026#39;http://geek.itheima.net/v1_0/channels\u0026#39; export default function UseEffectBasic() { const [channels, setChannels] = useState([]) // 定义副作用函数， 只执行一次  useEffect(() =\u0026gt; { console."},{"id":10,"href":"/books/react/react/router/setup/","title":"1. 安装","parent":"6. React-Router","content":"ReactRouter 为 React 提供路由管理的组件。\n安装     $ npm install react-router-dom 在 package.json 中， 可以看到版本为 6.22.1\n\u0026#34;dependencies\u0026#34;: { \u0026#34;react-router-dom\u0026#34;: \u0026#34;^6.22.1\u0026#34;, }, 使用     在 /src/components/router/RootRouter.jsx 中\n 使用 createBrowserRouter 创建 路由列表 router。 在组件中， 使用 RouterProvider 使用路由页面。  注意： 当前路由中使用的是 element 字段， 而非 componenet。\n之后就可以访问 http://localhost:3000/page1 或者 http://localhost:3000/page2 切换页面了。\n import { createBrowserRouter, RouterProvider } from \u0026#34;react-router-dom\u0026#34;; // 创建路由 const router = createBrowserRouter([ { path: \u0026#34;/page1\u0026#34;, element: \u0026lt;div\u0026gt;Page1\u0026lt;/div\u0026gt;, }, { path: \u0026#34;/page2\u0026#34;, element: \u0026lt;div\u0026gt;Page2\u0026lt;/div\u0026gt; } ]) export default function RootRouter() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;8. 路由页面 Root Page\u0026lt;/h2\u0026gt; {/* 使用路由 */} \u0026lt;RouterProvider router={router} /\u0026gt; \u0026lt;/div\u0026gt; ); } 什么是前端路由     一个 路径（path） 对应一个 组件（componenet）。 当我们在浏览器中访问 path 的时候， path 对应的组件会在页面中渲染。\n ","description":"ReactRouter 为 React 提供路由管理的组件。\n安装     $ npm install react-router-dom 在 package.json 中， 可以看到版本为 6.22.1\n\u0026#34;dependencies\u0026#34;: { \u0026#34;react-router-dom\u0026#34;: \u0026#34;^6.22.1\u0026#34;, }, 使用     在 /src/components/router/RootRouter.jsx 中\n 使用 createBrowserRouter 创建 路由列表 router。 在组件中， 使用 RouterProvider 使用路由页面。  注意： 当前路由中使用的是 element 字段， 而非 componenet。\n之后就可以访问 http://localhost:3000/page1 或者 http://localhost:3000/page2 切换页面了。\n import { createBrowserRouter, RouterProvider } from \u0026#34;react-router-dom\u0026#34;; // 创建路由 const router = createBrowserRouter([ { path: \u0026#34;/page1\u0026#34;, element: \u0026lt;div\u0026gt;Page1\u0026lt;/div\u0026gt;, }, { path: \u0026#34;/page2\u0026#34;, element: \u0026lt;div\u0026gt;Page2\u0026lt;/div\u0026gt; } ]) export default function RootRouter() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;8."},{"id":11,"href":"/books/react/react/communication/props/props/","title":"1. 支持的数据类型","parent":"1. props 通信","content":"/src/components/communication/Parent2Children.jsx\n props 可以传递任意数据  数字, 字符串, 布尔值 数组, 对象 函数, JSX    function Parent() { return ( \u0026lt;div\u0026gt; \u0026lt;Child name={\u0026#34;Wangwu\u0026#34;} age={20} isTrue={true} list={[1, 2, 3]} obj={{ name: \u0026#34;Zhaoliu\u0026#34; }} func={() =\u0026gt; { console.log(\u0026#34;Hello\u0026#34;) }} child={\u0026lt;span\u0026gt;this is a span\u0026lt;/span\u0026gt;} /\u0026gt; \u0026lt;/div\u0026gt; ); }  props 是 只读对象:  子组件 只能读取 props 中的数据， 不能直接修改。 如果要修改， 只能在父组件中 由父组件修改。 参考 子传父通信    3. 兄弟通信     状态提升\n","description":"/src/components/communication/Parent2Children.jsx\n props 可以传递任意数据  数字, 字符串, 布尔值 数组, 对象 函数, JSX    function Parent() { return ( \u0026lt;div\u0026gt; \u0026lt;Child name={\u0026#34;Wangwu\u0026#34;} age={20} isTrue={true} list={[1, 2, 3]} obj={{ name: \u0026#34;Zhaoliu\u0026#34; }} func={() =\u0026gt; { console.log(\u0026#34;Hello\u0026#34;) }} child={\u0026lt;span\u0026gt;this is a span\u0026lt;/span\u0026gt;} /\u0026gt; \u0026lt;/div\u0026gt; ); }  props 是 只读对象:  子组件 只能读取 props 中的数据， 不能直接修改。 如果要修改， 只能在父组件中 由父组件修改。 参考 子传父通信    3. 兄弟通信     状态提升"},{"id":12,"href":"/books/react/demos/redux-meituan/setup/","title":"1. 环境准备","parent":"2. redux-meituan","content":"1. 解压项目     解压 /src/demos/redux-meituan.tgz\n2. mock 数据     创建 /src/demos/redux-meituan/mock 目录， 创建mock 数据。\n$ npm install json-server 启动服务\n$ json-server --watch data.json --port 3101 3. 对外提供数据     对外提供数据\nconst takeawayURL = \u0026#39;http://localhost:3101/takeaway\u0026#39; export { takeawayURL } ","description":"1. 解压项目     解压 /src/demos/redux-meituan.tgz\n2. mock 数据     创建 /src/demos/redux-meituan/mock 目录， 创建mock 数据。\n$ npm install json-server 启动服务\n$ json-server --watch data.json --port 3101 3. 对外提供数据     对外提供数据\nconst takeawayURL = \u0026#39;http://localhost:3101/takeaway\u0026#39; export { takeawayURL } "},{"id":13,"href":"/books/react/setup/","title":"1. 环境配置","parent":"","content":"","description":""},{"id":14,"href":"/books/react/react/components/what-is-component/","title":"1. 组件式开发","parent":"3. 组件","content":"1. 组件是什么     组件是用户界面的一部分， 他可以有自己的的逻辑和外观。\n 组件之间 可以互相嵌套 组件 可以多次重复使用   组件化开发， 可以让开发者像搭积木一样构建一个庞大而完整的新系统。\n2. 如何定义组件     ","description":"1. 组件是什么     组件是用户界面的一部分， 他可以有自己的的逻辑和外观。\n 组件之间 可以互相嵌套 组件 可以多次重复使用   组件化开发， 可以让开发者像搭积木一样构建一个庞大而完整的新系统。\n2. 如何定义组件     "},{"id":15,"href":"/books/react/setup/install/","title":"1. 配置开发环境","parent":"1. 环境配置","content":"安装 NodeJS      安装 NodeJS  wget -c https://nodejs.org/dist/v20.11.0/node-v20.11.0-darwin-arm64.tar.gz tar xf node-v20.11.0-darwin-arm64.tar.gz mv node-v20.11.0-darwin-arm64 /usr/local/nodejs 配置环境变量  export NODE_ROOT=/usr/local/nodejs export PATH=$NODE_ROOT/bin:$PATH alias cnpm=\u0026#39;npm --registry=https://registry.npmmirror.com \u0026#39; 配置国内源  yarn config set registry https://registry.npmmirror.com npm config set registry https://registry.npmmirror.com Chrome 插件      React Developer Tools  ","description":"安装 NodeJS      安装 NodeJS  wget -c https://nodejs.org/dist/v20.11.0/node-v20.11.0-darwin-arm64.tar.gz tar xf node-v20.11.0-darwin-arm64.tar.gz mv node-v20.11.0-darwin-arm64 /usr/local/nodejs 配置环境变量  export NODE_ROOT=/usr/local/nodejs export PATH=$NODE_ROOT/bin:$PATH alias cnpm=\u0026#39;npm --registry=https://registry.npmmirror.com \u0026#39; 配置国内源  yarn config set registry https://registry.npmmirror.com npm config set registry https://registry.npmmirror.com Chrome 插件      React Developer Tools  "},{"id":16,"href":"/books/react/react/communication/context/","title":"2. context 跨层级通信","parent":"5. 组件通信","content":"和 Golang 的 context 差不多。 在 context.Provider 下的所有节点都可以通过关键字 useContext 获取数据。\n解决了 props 中不相关的组件之间需要传递数据时 状态提升 的复杂操作。\n  使用 createContext 方法创建一个 上下文对象 Ctx 在顶层组件 (如图, App) 中使用 Ctx.Provider 组件提供数据。 在下层组件 (如图, B) 中使用 useContext 钩子获取消费数据。   在 /src/components/communication/UseContext.jsx 中， 定义三个组件形成嵌套关系\n UseContext, 对应上图中的 App A 对应 A B 对应 B  1. 定义 MsgContext     在文件级别， 使用 createContext 创建 Context 对象\n注意: 经测试， 创建时提供的 default value 并不起作用。 实际 可用数据 还是需要在 \u0026lt;MsgContext.Provider\u0026gt; value={xxx} 中提供。\nimport { createContext, useContext } from \u0026#39;react\u0026#39; // 创建 context 对象 const MsgContext = createContext(\u0026#39;default value\u0026#39;) 2. 传递 MsgContext     在 UseContext 中， 定义 data 并传递数据\n 使用 useState 定义状态数据 data 使用 button 点击事件， 调用 changeData 函数修改 data 的值 使用 MsgContext.Provider 包裹 组件A， 并使用 value={data} 传入数据  export default function UseContext() { // 定义状态数据  const original = { \u0026#34;name\u0026#34;: \u0026#34;zhangsan\u0026#34;, \u0026#34;age\u0026#34;: 10 } const [data, setdata] = useState(original) // 定义函数修改 data 的值  function changeData() { setdata({ \u0026#34;name\u0026#34;: \u0026#34;wangwu\u0026#34;, \u0026#34;age\u0026#34;: 20 }) } return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;7.4 Context 跨层级传递\u0026lt;/h3\u0026gt; {/* 传入 data */} \u0026lt;MsgContext.Provider value={data}\u0026gt; \u0026lt;A /\u0026gt; \u0026lt;/MsgContext.Provider\u0026gt; \u0026lt;button onClick={changeData}\u0026gt;点我修改 data\u0026lt;/button\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;/div\u0026gt; ) } 3. 使用 MsgContext     由于 MsgContext 已经包裹在了最外层， 因此 包括 A 在内的所有子孙组件 都可以使用 Context。\n 创建 A 包裹 B 在 B 中使用 useContext(ContextName) 获取数据， 并使用。  // A 单纯的用于组件嵌套 function A() { return ( \u0026lt;div\u0026gt; \u0026lt;b\u0026gt;this a A area\u0026lt;/b\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;B /\u0026gt; \u0026lt;/div\u0026gt; ) } // 使用 useContext 获取 MsgContext 的值， 并使用 function B() { const msg = useContext(MsgContext) return ( \u0026lt;div\u0026gt; \u0026lt;b\u0026gt;this is B area: \u0026lt;/b\u0026gt; \u0026lt;span\u0026gt;{msg.name}\u0026lt;/span\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;/div\u0026gt; ) } ","description":"和 Golang 的 context 差不多。 在 context.Provider 下的所有节点都可以通过关键字 useContext 获取数据。\n解决了 props 中不相关的组件之间需要传递数据时 状态提升 的复杂操作。\n  使用 createContext 方法创建一个 上下文对象 Ctx 在顶层组件 (如图, App) 中使用 Ctx.Provider 组件提供数据。 在下层组件 (如图, B) 中使用 useContext 钩子获取消费数据。   在 /src/components/communication/UseContext.jsx 中， 定义三个组件形成嵌套关系\n UseContext, 对应上图中的 App A 对应 A B 对应 B  1. 定义 MsgContext     在文件级别， 使用 createContext 创建 Context 对象\n注意: 经测试， 创建时提供的 default value 并不起作用。 实际 可用数据 还是需要在 \u0026lt;MsgContext."},{"id":17,"href":"/books/react/react/jsx/basic-syntax/","title":"2. jsx 的常用用法","parent":"1. jsx 基础用法","content":"在 jsx 中， 可以通过 大括号语法{} 识别 JavaScript 中的表达式。\n常见的包括\n 常量调用 变量调用 函数调用 方法调用 使用 js 对象 等等  1. 常量调用     在 BasicSyntax 内部使用 {'this is const string'}\n// BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;1. 常量调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{\u0026#39;this is const string\u0026#39;}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } 2. 变量调用      在 BasicSyntax 组建外部定义 变量 val。 在内部使用 {val} 调用  // BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;2. 变量调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{val}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } // 定义变量 let val = \u0026#39;this is const variable\u0026#39; 3. 函数调用      在 BasicSyntax 组建外部定义 函数 hello 在内部使用 {hello()} 调用。  注意： 调用函数时，必须要使用 圆括号() 函数才会被执行。\n// BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;3. 函数调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{hello()}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } // 定义函数 function hello() { return \u0026#34;Hello React18, from function\u0026#34; } 4. 方法调用     方法 本质上就是 具有一定限制函数。 因此方法调用与函数调用类似。\n// BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;4. 方法调用\u0026lt;/h3\u0026gt; {/* 字符串方法 */} \u0026lt;p\u0026gt;{hello().toUpperCase()}\u0026lt;/p\u0026gt; {/* 创建对象，并调用时间方法 */} \u0026lt;p\u0026gt;{new Date().getDate()}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } // 定义变量 let val = \u0026#39;this is const variable\u0026#39; 5. JS 对象调用     需要注意的是， 这里并不是使用的 双花括号 {{content}}， 而是两个不同意义的花括号。\n 外层 是 jsx 语法的花括号， 表示内部为 js 语法。 内层 是 js 语法的中 style 的定义 style={color:'red'}  // BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;5. js 对象调用\u0026lt;/h3\u0026gt; {/* 注意这里不是不是 双括号 */} {/* 外层括号是 {} 是 jsx 表达式 */} {/* 内层括号是 js 调用, 相当于 style={color:\u0026#39;red\u0026#39;} */} \u0026lt;div style={{ color: \u0026#39;red\u0026#39; }}\u0026gt; this is in div \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } 6. 数学计算     数学计算\n// BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;6. 数学计算\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{1 + 2}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } 7. 注释      注释也是使用 花括号{} 开启 JS 语法 然后使用 JS 中的多行注释语法。  // BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;7. 注释\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;这里看不到内容\u0026lt;/p\u0026gt; {/* 这里可以看到 */} \u0026lt;/div\u0026gt; ); } 其他     完整代码可以在 /src/components/jsx/BasicSyntax.js 中看到\nfunction BasicSyntax() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;2.2. jsx 基础语法\u0026lt;/h1\u0026gt; \u0026lt;h3\u0026gt;1. 常量调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{\u0026#39;this is const string\u0026#39;}\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;2. 变量调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{val}\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;3. 函数调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{hello()}\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;4. 方法调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{hello().toUpperCase()}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{new Date().getDate()}\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;5. js 对象调用\u0026lt;/h3\u0026gt; {/* 注意这里不是不是 双括号 */} {/* 外层括号是 {} 是 jsx 表达式 */} {/* 内层括号是 js 调用, 相当于 style={color:\u0026#39;red\u0026#39;} */} \u0026lt;div style={{ color: \u0026#39;red\u0026#39; }}\u0026gt; this is in div \u0026lt;/div\u0026gt; \u0026lt;h3\u0026gt;6. 数学计算\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{1 + 2}\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;7. 注释\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;这里看不到内容\u0026lt;/p\u0026gt; {/* 这里可以看到 */} \u0026lt;/div\u0026gt; ); } export default BasicSyntax; // 定义变量 let val = \u0026#39;this is const variable\u0026#39; // 定义函数 function hello() { return \u0026#34;Hello React18, from function\u0026#34; } ","description":"在 jsx 中， 可以通过 大括号语法{} 识别 JavaScript 中的表达式。\n常见的包括\n 常量调用 变量调用 函数调用 方法调用 使用 js 对象 等等  1. 常量调用     在 BasicSyntax 内部使用 {'this is const string'}\n// BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;1. 常量调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{\u0026#39;this is const string\u0026#39;}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } 2. 变量调用      在 BasicSyntax 组建外部定义 变量 val。 在内部使用 {val} 调用  // BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;2."},{"id":18,"href":"/books/react/react/events/on-change/","title":"2. onChange 数据双向绑定","parent":"2. 事件绑定","content":" 在 /src/components/event/EventOnChange.js 中实现了 数据的双向绑定。 即\n 使用 useState 管理变量 username 的状态 使用 {username} 实现数据 从 state 到 UI 的单向绑定。 使用 onChange 捕捉控件的变化事件。 随后通过 箭头函数 获取 当前事件目标的值(e.target.value) 并通过 setUsername 保存数据， 从而数据 从 UI 到 state 的单向绑定。 当数据更新到 state 后， React 又刷新了页面。  // Path: src/components/event/EventOnClick.js  import { useState } from \u0026#34;react\u0026#34; export default function EventOnChange() { const [username, setUsername] = useState(\u0026#34;zhangsan\u0026#34;) return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;OnChange 事件实现数据双向绑定\u0026lt;/h2\u0026gt; {/* 1. {username} 实现数据从 state 到 UI 的单向绑定 2. onChange(e) 实现数据从 UI 到 state 的单向绑定 */} \u0026lt;input value={username} onChange={(e) =\u0026gt; setUsername(e.target.value)} /\u0026gt; \u0026lt;span\u0026gt;{username}\u0026lt;/span\u0026gt; \u0026lt;/div \u0026gt; ) } ","description":"在 /src/components/event/EventOnChange.js 中实现了 数据的双向绑定。 即\n 使用 useState 管理变量 username 的状态 使用 {username} 实现数据 从 state 到 UI 的单向绑定。 使用 onChange 捕捉控件的变化事件。 随后通过 箭头函数 获取 当前事件目标的值(e.target.value) 并通过 setUsername 保存数据， 从而数据 从 UI 到 state 的单向绑定。 当数据更新到 state 后， React 又刷新了页面。  // Path: src/components/event/EventOnClick.js  import { useState } from \u0026#34;react\u0026#34; export default function EventOnChange() { const [username, setUsername] = useState(\u0026#34;zhangsan\u0026#34;) return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;OnChange 事件实现数据双向绑定\u0026lt;/h2\u0026gt; {/* 1. {username} 实现数据从 state 到 UI 的单向绑定 2."},{"id":19,"href":"/books/react/library/redux/redux-react-setup/","title":"2. Redux 与 React - 环境准备","parent":"redux","content":"官方要求安装两个其他插件\n  Redux Toolkit (RTK): 官方推荐编写 Redux 逻辑的方式， 是一套工具的集合， 可以 简化书写方式\n 简化 store 的配置 内置 immer 支持可变状态的修改 内置 thunk 更好的支持 异步创建    react-redux: 用于 链接 Redux 和 React 的中间件\n   1. 插件安装     $ npm install @reduxjs/toolkit react-redux 安装后可以在 package.json 中查看版本。\n\u0026#34;dependencies\u0026#34;: { \u0026#34;@reduxjs/toolkit\u0026#34;: \u0026#34;^2.2.1\u0026#34;, \u0026#34;react-redux\u0026#34;: \u0026#34;^9.1.0\u0026#34;, }, 比 教学视频 的版本高。 (2024-02-20)\n\u0026#34;dependencies\u0026#34;: { \u0026#34;@reduxjs/toolkit\u0026#34;: \u0026#34;^1.9.3\u0026#34;, \u0026#34;react-redux\u0026#34;: \u0026#34;^8.0.5\u0026#34;, }, 2. store 目录结构设计     创建 /src/store 根目录，\n 通常集中状态管理部分都会 单独创建 store 目录， 一般位置为 /src/store/ 应用通常会有很多个 子 store 模块， 所以创建一个 /src/store/modules/ 目录， 在目录内 通过文件独立维护子 store 创建 入口文件 /src/store/index.js， 用于组合 modules 中的所有子模块， 并导出 store。   ","description":"官方要求安装两个其他插件\n  Redux Toolkit (RTK): 官方推荐编写 Redux 逻辑的方式， 是一套工具的集合， 可以 简化书写方式\n 简化 store 的配置 内置 immer 支持可变状态的修改 内置 thunk 更好的支持 异步创建    react-redux: 用于 链接 Redux 和 React 的中间件\n   1. 插件安装     $ npm install @reduxjs/toolkit react-redux 安装后可以在 package.json 中查看版本。\n\u0026#34;dependencies\u0026#34;: { \u0026#34;@reduxjs/toolkit\u0026#34;: \u0026#34;^2.2.1\u0026#34;, \u0026#34;react-redux\u0026#34;: \u0026#34;^9.1.0\u0026#34;, }, 比 教学视频 的版本高。 (2024-02-20)\n\u0026#34;dependencies\u0026#34;: { \u0026#34;@reduxjs/toolkit\u0026#34;: \u0026#34;^1.9.3\u0026#34;, \u0026#34;react-redux\u0026#34;: \u0026#34;^8.0.5\u0026#34;, }, 2. store 目录结构设计     创建 /src/store 根目录，"},{"id":20,"href":"/books/react/demos/redux-meituan/","title":"2. redux-meituan","parent":"99. 项目案例","content":"","description":""},{"id":21,"href":"/books/react/react/hooks/use-effect/dependencies/","title":"2. 不同依赖项行为","parent":"useEffect 生命周期管理","content":"2. 不同依赖项的不同渲染行为     不同状态 的数组影响第一参数函数的执行。 1. 数据被省略时： 在组件加载时执行， 且在任意渲染时执行。 2. 数组为空时： 仅在组件加载时执行 （仅执行一次）。 3. 数组中有依赖项时： 在组件加载时执行， 且在 仅在依赖项变化时触发的渲染时执行\n 在 /src/components/hooks/UseEffectDependencies.jsx 中\nimport { useState, useEffect } from \u0026#34;react\u0026#34;; export default function UseEffectDependencies() { const [count, setCount] = useState(0) const [trigger, setTrigger] = useState(0) // (1) none dependency  // 组件加载时，执行一次  // 无依赖项，每次组件更新时，都会执行  useEffect(() =\u0026gt; { console.log(\u0026#39;NONE: useEffect called\u0026#39;); }); // (2) empty dependency  // 仅在组件加载时执行一次  useEffect(() =\u0026gt; { console.log(\u0026#39;EMPTY: useEffect called\u0026#39;); }, []); // (3) strict dependency  // 组件加载时执行一次  // 仅在依赖项发生变化时，才会执行  useEffect(() =\u0026gt; { console.log(\u0026#39;STRICT: useEffect called\u0026#39;); }, [count]); return ( \u0026lt;div\u0026gt; \u0026lt;h4\u0026gt;4.1 UseEffict 依赖项行为差异\u0026lt;/h4\u0026gt; {/* \u0026lt;span\u0026gt;Count: {count}, Trigger: {trigger}\u0026lt;/span\u0026gt; */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Count\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setTrigger(trigger + 1)}\u0026gt;trigger\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } ","description":"2. 不同依赖项的不同渲染行为     不同状态 的数组影响第一参数函数的执行。 1. 数据被省略时： 在组件加载时执行， 且在任意渲染时执行。 2. 数组为空时： 仅在组件加载时执行 （仅执行一次）。 3. 数组中有依赖项时： 在组件加载时执行， 且在 仅在依赖项变化时触发的渲染时执行\n 在 /src/components/hooks/UseEffectDependencies.jsx 中\nimport { useState, useEffect } from \u0026#34;react\u0026#34;; export default function UseEffectDependencies() { const [count, setCount] = useState(0) const [trigger, setTrigger] = useState(0) // (1) none dependency  // 组件加载时，执行一次  // 无依赖项，每次组件更新时，都会执行  useEffect(() =\u0026gt; { console.log(\u0026#39;NONE: useEffect called\u0026#39;); }); // (2) empty dependency  // 仅在组件加载时执行一次  useEffect(() =\u0026gt; { console."},{"id":22,"href":"/books/react/javascript/introduce/position/","title":"2. 书写位置","parent":"1. 入门简介","content":"书写位置包括以下三部分\n 1. 内部     在 html body 内部书写， 使用 script 标签包裹。 通常写在最后， 即 \u0026lt;/body\u0026gt; 的前方，以便在 script 中获取 html 中的元素信息。\n 注意: 将 \u0026lt;script\u0026gt; 放到 HTML文件底部 附近时因为浏览器会按照代码在文件中的位置 顺序加载。 如果加载的 script 期望修改器下方的 HTML 元素，那么就因为因为元素为被加载而失败。 因此 将 js 代码放在 HTML 页面底附近通常是最好的策略。\n 2. 外部     即 引用js文件。\n head 中引用： 公共库一般放在这里。 body 中引用： 自己写的一般放在这里， 位置参考 内部script  注意: 闭合标签中不在写其他内容。\n\u0026lt;head\u0026gt; \u0026lt;script src=\u0026#34;http://cdn.example.com/jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;name\u0026#34;\u0026gt;点我\u0026lt;/button\u0026gt; \u0026lt;script src=\u0026#34;./position.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 3. 内联     写在元素内部， 属性 的位置\n\u0026lt;body\u0026gt; \u0026lt;!-- 3. 内联 --\u0026gt; \u0026lt;botton onclick=\u0026#34;alert(\u0026#39;内联 js\u0026#39;)\u0026#34;\u0026gt;内联\u0026lt;/botton\u0026gt; \u0026lt;/body\u0026gt; demo     position.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;1.2. 书写位置\u0026lt;/title\u0026gt; \u0026lt;!-- 2.1. 外部 --\u0026gt; \u0026lt;script src=\u0026#34;http://cdn.example.com/position.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 2.2. 外部 --\u0026gt; \u0026lt;script src=\u0026#34;./position.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 1. 内部  console.log(\u0026#39;script标签可以放在body标签内部\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;!-- 3. 内联 --\u0026gt; \u0026lt;botton onclick=\u0026#34;alert(\u0026#39;内联 js\u0026#39;)\u0026#34;\u0026gt;内联\u0026lt;/botton\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","description":"书写位置包括以下三部分\n 1. 内部     在 html body 内部书写， 使用 script 标签包裹。 通常写在最后， 即 \u0026lt;/body\u0026gt; 的前方，以便在 script 中获取 html 中的元素信息。\n 注意: 将 \u0026lt;script\u0026gt; 放到 HTML文件底部 附近时因为浏览器会按照代码在文件中的位置 顺序加载。 如果加载的 script 期望修改器下方的 HTML 元素，那么就因为因为元素为被加载而失败。 因此 将 js 代码放在 HTML 页面底附近通常是最好的策略。\n 2. 外部     即 引用js文件。\n head 中引用： 公共库一般放在这里。 body 中引用： 自己写的一般放在这里， 位置参考 内部script  注意: 闭合标签中不在写其他内容。\n\u0026lt;head\u0026gt; \u0026lt;script src=\u0026#34;http://cdn.example.com/jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;name\u0026#34;\u0026gt;点我\u0026lt;/button\u0026gt; \u0026lt;script src=\u0026#34;."},{"id":23,"href":"/books/react/react/events/","title":"2. 事件绑定","parent":"3. React","content":"","description":""},{"id":24,"href":"/books/react/demos/redux-meituan/initial-store/","title":"2. 使用 redux 管理数据","parent":"2. redux-meituan","content":"1. 创建 takeaway slice     在 /src/demos/redux-meituan/store/modules/takeaway.js\n 使用 @reduxjs/toolkit 提供的 createSlice 创建 state 对象 并导出 reducer  import { createSlice } from \u0026#39;@reduxjs/toolkit\u0026#39; import { defaultFoodsList } from \u0026#39;./default\u0026#39; const takeaway = createSlice({ // 名称  name: \u0026#39;takeaway\u0026#39;, // 初始数据  initialState: { foodsList: defaultFoodsList, }, // actions  reducers: { } }) // 导出 reducer 在 store/index.js 中合并 const takeawayReducer = takeaway.reducer export default takeawayReducer 初始化 foodsList 的时候使用了 精简版 的默认值， 保证数据解构完整性。 以避免从服务器获取数据失败时的渲染报错。\n// 设置默认数据， 避免数据为空时异常 const defaultFoodsList = [ { \u0026#34;tag\u0026#34;: \u0026#34;318569657\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;一人套餐\u0026#34;, \u0026#34;foods\u0026#34;: [ { \u0026#34;id\u0026#34;: 8078956697, \u0026#34;name\u0026#34;: \u0026#34;烤羊肉串(10串)\u0026#34;, \u0026#34;like_ratio_desc\u0026#34;: \u0026#34;好评度100%\u0026#34;, \u0026#34;month_saled\u0026#34;: 40, \u0026#34;unit\u0026#34;: \u0026#34;10串\u0026#34;, \u0026#34;food_tag_list\u0026#34;: [\u0026#34;点评网友推荐\u0026#34;], \u0026#34;price\u0026#34;: 90, \u0026#34;picture\u0026#34;: \u0026#34;https://zqran.gitee.io/images/waimai/8078956697.jpg\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;318569657\u0026#34; } ] } ] export { defaultFoodsList } 2. 创建 store     在 /src/demos/redux-meituan/store/index.js 中\n 使用 @reduxjs/toolkit 提供的 configureStore 创建 store 并导出  import { configureStore } from \u0026#34;@reduxjs/toolkit\u0026#34; import takeawayReducer from \u0026#39;./modules/takeaway\u0026#39; const store = configureStore({ reducer: { takeaway: takeawayReducer } }) export default store 3. 使用 Provider 提供 store     创建 入口组件 /src/demos/redux-meituan/index.jsx\n使用 react-redux 提供的 Provider 提供 store\nimport { Provider } from \u0026#39;react-redux\u0026#39; import ReduxMeituan from \u0026#39;./ReduxMeituan\u0026#39; import store from \u0026#39;./store\u0026#39; export default function RootReduxMeituan() { return ( \u0026lt;div\u0026gt; \u0026lt;Provider store={store}\u0026gt; \u0026lt;ReduxMeituan /\u0026gt; \u0026lt;/Provider\u0026gt; \u0026lt;/div\u0026gt; ) } 4. 使用 useSelector 获取 store 数据     在 /src/demos/redux-meituan/ReduxMeituan.jsx 中\n使用 useSelector 解构 reducer 中提供的 foodsList 数据。 并删除原来静态定义的 foodsList。\n// const foodsList = []  const ReduxMeituan = () =\u0026gt; { const { foodsList } = useSelector(state =\u0026gt; state.takeaway) // 省略... }  5. 创建 thunk 异步函数从服务端获取数据     在 /src/demos/redux-meituan/store/modules/takeaway.js 中，\n 添加 reducer 的 action 方法 setFoodsList 并创建 thunk 异步函数， 使用 dispatch 触发修改 使用 axios 从 json-server 获取数据  import axios from \u0026#39;axios\u0026#39; import { takeawayURL } from \u0026#39;../../mock/index\u0026#39; const takeaway = createSlice({ // ...省略  // actions  reducers: { setFoodsList: (state, action) =\u0026gt; { state.foodsList = action.payload } } }) // 2. 创建异步 thunk 获取数据 const { setFoodsList } = takeaway.actions const getFoodsList = () =\u0026gt; { return async (dispatch) =\u0026gt; { // 异步请求 不再返回 resp  await axios .get(takeawayURL) // 直接在 .then 中进行正常逻辑处理  .then( resp =\u0026gt; { // console.log(\u0026#39;resp\u0026#39;, resp);  // return resp  dispatch(setFoodsList(resp.data)) } ) // 使用 .catch 捕获异常  .catch( err =\u0026gt; console.log(\u0026#39;err\u0026#39;, err) ); // 未处理网络错误代码  // const resp = await axios.get(url)  // console.log(\u0026#39;resp\u0026#39;, resp);  // // dispatch action  // if (resp?.status === 200) {  // dispatch(setFoodsList(resp.data))  // }  } } export { getFoodsList } export { getFoodsList } 6. 使用 useDispatch 修改 store 数据     在 /src/demos/redux-meituan/ReduxMeituan.jsx 中\n 使用 useEffect 实现在页面加载时触发数据获取动作。 使用 react-redux 提供的 useDispatch 触发 store 的数据修改行为  import { useDispatch } from \u0026#39;react-redux\u0026#39; import { getFoodsList } from \u0026#39;./store/modules/takeaway\u0026#39; import { useEffect } from \u0026#39;react\u0026#39; const ReduxMeituan = () =\u0026gt; { // 使用 useSelector 获取 store 数据  const { foodsList } = useSelector(state =\u0026gt; state.takeaway) // 使用 dispatch 修改 store 数据  const dispatch = useDispatch() useEffect(() =\u0026gt; { dispatch(getFoodsList()) }, [dispatch]) // 省略... }  7. 使用 store 数据修改 Menu 菜单     在 /src/demos/redux-meituan/components/Menu/index.js 中\n 使用 useSelector 从 state.takeaway 中获取数据 并替换原来的 foodsList 即可。  import { useSelector } from \u0026#39;react-redux\u0026#39; const Menu = () =\u0026gt; { // 删除  // const foodsList = []  // 使用 useSelector 获取 store 中的数据  const { foodsList } = useSelector(state =\u0026gt; state.takeaway) } ","description":"1. 创建 takeaway slice     在 /src/demos/redux-meituan/store/modules/takeaway.js\n 使用 @reduxjs/toolkit 提供的 createSlice 创建 state 对象 并导出 reducer  import { createSlice } from \u0026#39;@reduxjs/toolkit\u0026#39; import { defaultFoodsList } from \u0026#39;./default\u0026#39; const takeaway = createSlice({ // 名称  name: \u0026#39;takeaway\u0026#39;, // 初始数据  initialState: { foodsList: defaultFoodsList, }, // actions  reducers: { } }) // 导出 reducer 在 store/index.js 中合并 const takeawayReducer = takeaway.reducer export default takeawayReducer 初始化 foodsList 的时候使用了 精简版 的默认值， 保证数据解构完整性。 以避免从服务器获取数据失败时的渲染报错。"},{"id":25,"href":"/books/react/setup/initialize/","title":"2. 初始化项目","parent":"1. 环境配置","content":"2. 创建项目     npx create-react-app react-basic  npx 是 node.js 的工具命令， 查找并执行后续包命令。 create-react-app 是 核心包（固定写法）， 用于创建 react 项目 react-basic 是 react 项目名称， 可以自定义。  3. 项目配置     ## 启动命令 npm start ## 编译命令 npm run build # 注意这个 run 用不用都可以 可以在 package.json 中看到核心组建与启动命令\n// 依赖组建 \u0026quot;dependencies\u0026quot;: { \u0026quot;@testing-library/jest-dom\u0026quot;: \u0026quot;^5.17.0\u0026quot;, \u0026quot;@testing-library/react\u0026quot;: \u0026quot;^13.4.0\u0026quot;, \u0026quot;@testing-library/user-event\u0026quot;: \u0026quot;^13.5.0\u0026quot;, \u0026quot;react\u0026quot;: \u0026quot;^18.2.0\u0026quot;, \u0026quot;react-dom\u0026quot;: \u0026quot;^18.2.0\u0026quot;, \u0026quot;react-scripts\u0026quot;: \u0026quot;5.0.1\u0026quot;, \u0026quot;web-vitals\u0026quot;: \u0026quot;^2.1.4\u0026quot; }, // 启动命令 \u0026quot;scripts\u0026quot;: { \u0026quot;start\u0026quot;: \u0026quot;react-scripts start\u0026quot;, \u0026quot;build\u0026quot;: \u0026quot;react-scripts build\u0026quot;, \u0026quot;test\u0026quot;: \u0026quot;react-scripts test\u0026quot;, \u0026quot;eject\u0026quot;: \u0026quot;react-scripts eject\u0026quot; }, 4. 清理文件     /src 是代码目录， 清理暂时不用的文件， 留下核心\n4.1. 删除文件     删除除了 index.js, App.js 以外的文件。\n此时， 需要在 index.js 和 App.js 中删除引用\ninjex.js\nimport React from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom/client\u0026#39;; // import \u0026#39;./index.css\u0026#39;; import App from \u0026#39;./App\u0026#39;; // import reportWebVitals from \u0026#39;./reportWebVitals\u0026#39;; App.js, 删除引用文件， 并修改返回内容。\n// import logo from \u0026#39;./logo.svg\u0026#39;; // import \u0026#39;./App.css\u0026#39;;  function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; this is my app \u0026lt;/div\u0026gt; ); } export default App; 4.2. 关闭严格模式     在 index.js 中，注释 StrictMode\nconst root = ReactDOM.createRoot(document.getElementById(\u0026#39;root\u0026#39;)); root.render( // \u0026lt;React.StrictMode\u0026gt;  \u0026lt;App /\u0026gt; // \u0026lt;/React.StrictMode\u0026gt; ); 4.3. 关闭性能监控     在 index.js 中注释 reportWebVitals() 关闭性能监控\n// // If you want to start measuring performance in your app, pass a function // // to log results (for example: reportWebVitals(console.log)) // // or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals // reportWebVitals(); 5. 说明     5.1. DOM 初始化     在 index.js 中,\n 通过 React.createRoot 创建了一个 DOM。 并通过 document.getElementById('root') 绑定到了 public/index.html 中的 root 节点上上。  // 这个 root 节点在 public/index.html 中定义。 const root = ReactDOM.createRoot(document.getElementById(\u0026#39;root\u0026#39;)); root.render( // \u0026lt;React.StrictMode\u0026gt;  \u0026lt;App /\u0026gt; // \u0026lt;/React.StrictMode\u0026gt; ); 5.2. 组件     在 App.js 中\n// App -引入-\u0026gt; index.js -渲染-\u0026gt; index.html function App() { return ( // return 出去  \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; this is my app \u0026lt;/div\u0026gt; ); }  组件的渲染流程大概如下: App -引入-\u0026gt; index.js -渲染-\u0026gt; index.html 所有组件中都有一个 return 将结果丢给 React. 注意 \u0026lt;className=\u0026quot;App\u0026quot;\u0026gt; 不是 index 语法了， 而是 react 语法了。  其他      中文官网： https://zh-hans.react.dev/learn/start-a-new-react-project B站视频： https://www.bilibili.com/video/BV1ZB4y1Z7o8?p=3\u0026amp;vd_source=0259bb47833cfe6d7c4749c69a49a9d2  ","description":"2. 创建项目     npx create-react-app react-basic  npx 是 node.js 的工具命令， 查找并执行后续包命令。 create-react-app 是 核心包（固定写法）， 用于创建 react 项目 react-basic 是 react 项目名称， 可以自定义。  3. 项目配置     ## 启动命令 npm start ## 编译命令 npm run build # 注意这个 run 用不用都可以 可以在 package.json 中看到核心组建与启动命令\n// 依赖组建 \u0026quot;dependencies\u0026quot;: { \u0026quot;@testing-library/jest-dom\u0026quot;: \u0026quot;^5.17.0\u0026quot;, \u0026quot;@testing-library/react\u0026quot;: \u0026quot;^13.4.0\u0026quot;, \u0026quot;@testing-library/user-event\u0026quot;: \u0026quot;^13.5.0\u0026quot;, \u0026quot;react\u0026quot;: \u0026quot;^18.2.0\u0026quot;, \u0026quot;react-dom\u0026quot;: \u0026quot;^18.2.0\u0026quot;, \u0026quot;react-scripts\u0026quot;: \u0026quot;5.0.1\u0026quot;, \u0026quot;web-vitals\u0026quot;: \u0026quot;^2.1.4\u0026quot; }, // 启动命令 \u0026quot;scripts\u0026quot;: { \u0026quot;start\u0026quot;: \u0026quot;react-scripts start\u0026quot;, \u0026quot;build\u0026quot;: \u0026quot;react-scripts build\u0026quot;, \u0026quot;test\u0026quot;: \u0026quot;react-scripts test\u0026quot;, \u0026quot;eject\u0026quot;: \u0026quot;react-scripts eject\u0026quot; }, 4."},{"id":26,"href":"/books/react/react/components/define-component/","title":"2. 如何定义组件","parent":"3. 组件","content":"组件的定义方式有两种。\n 函数式组件： 最常用 类式组件  组件名通常使用 大驼峰 命名方式， 即 首字母大写的驼峰\n例如， MyButton, UserInfoDisplay\n1. 组件的定义     1.1. 函数式组件     在 /src/components/component/FuncComponent.js 中\nfunction FunctionButtion() { return ( \u0026lt;button\u0026gt;function buttion\u0026lt;/button\u0026gt; ) } export default FunctionButtion; 1.2. 箭头函数式组件     箭头函数也是函数， 所以和上面 function 定义没什么区别。 也在 /src/components/component/FuncComponent.js 中\nexport const ArrowFuncButtion = () =\u0026gt; { return ( \u0026lt;button\u0026gt;arrow func button\u0026lt;/button\u0026gt; ) } 1.3. 类式组件     这个有有点特别了， 在 React 18 中， 已经不怎么用了。\n在 /src/components/component/ClassComponent.js 中\n 必须要 import React 创建的类要 继承 自 React.Component 必须存在 类方法 render。 render 最终返回一对 标签， 与 函数式组件 一样了。  // 必须要引入 React import React from \u0026#34;react\u0026#34;; // 1. 创建类式组件 class MyClassComponent extends React.Component { // 1. 构建函数 「不是必须存在」  // 2. render 必须存在  // render 是放在哪里的？ -- MyClassComponent 类 的原型对象上， 供实例使用。  // render 中的 this 是谁？ -- MyClassComponent 的实例对象。  render() { console.log(this); return ( \u0026lt;button\u0026gt;class component\u0026lt;/button\u0026gt; ) } } export default MyClassComponent; 2. 组件的导出     同一文件中的组件是可以互相引用的。 如果允许组件被外部引用， 则需要使用 export 关键字。\n 每个文件 最多只有一个 export default。 最少可以没有， 及没有默认导出。 参考  FunctionComponent MyClassComponenet   如果有其他组件还需要导出， 则可以在定义的所在位置使用 export 关键字  参考 ArrowFuncComponenet    3. 组件的引用     在 /src/components/component/RootComponent.js 中\n组件的使用， 与 标准HTML标签 的使用方式一样。\n 自闭和标签 成对标签  import MyClassComponent from \u0026#34;./ClassComponent\u0026#34; import FunctionButtion, { ArrowFuncButtion } from \u0026#34;./FuncComponent\u0026#34;; function RootComponent() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;4. 组件的定义和使用\u0026lt;/h2\u0026gt; {/* 组件的使用 {/* 1. 自闭和标签 */} \u0026lt;FunctionButtion /\u0026gt; {/* 2. 成对标签 */} \u0026lt;ArrowFuncButtion\u0026gt;\u0026lt;/ArrowFuncButtion\u0026gt; {/* 引用外部文件组件 */} \u0026lt;MyClassComponent /\u0026gt; \u0026lt;/div\u0026gt; ) } 在使用标签之前， 需要确定标签是否被引用到本文件。\n  如果 当前组件(RootComponenet) 与 被引用组件 在同一个文件中， 不需要使用 import\n  如果 被引用组件 是 默认导出组件， 则直接 import\n  import FunctionButtion from \u0026#34;./FuncComponent\u0026#34;; 如果 被引用组件 是 非默认导出组件， 则需要使用 花括号{} 包裹引用组件名。  import { ArrowFuncButtion } from \u0026#34;./FuncComponent\u0026#34;; 如果一个文件有多个组件被引用， 可以合并写在一行  import FunctionButtion, { ArrowFuncButtion, OtherButton } from \u0026#34;./FuncComponent\u0026#34;; 默认导出组件名 可以与其 所在文件名 不同。  import MyClassComponent from \u0026#34;./ClassComponent\u0026#34; ","description":"组件的定义方式有两种。\n 函数式组件： 最常用 类式组件  组件名通常使用 大驼峰 命名方式， 即 首字母大写的驼峰\n例如， MyButton, UserInfoDisplay\n1. 组件的定义     1.1. 函数式组件     在 /src/components/component/FuncComponent.js 中\nfunction FunctionButtion() { return ( \u0026lt;button\u0026gt;function buttion\u0026lt;/button\u0026gt; ) } export default FunctionButtion; 1.2. 箭头函数式组件     箭头函数也是函数， 所以和上面 function 定义没什么区别。 也在 /src/components/component/FuncComponent.js 中\nexport const ArrowFuncButtion = () =\u0026gt; { return ( \u0026lt;button\u0026gt;arrow func button\u0026lt;/button\u0026gt; ) } 1.3. 类式组件     这个有有点特别了， 在 React 18 中， 已经不怎么用了。"},{"id":27,"href":"/books/react/react/communication/props/parent-to-children/","title":"2. 父传子通信","parent":"1. props 通信","content":"/src/components/communication/Parent2Children.jsx\n实现步骤\n 传递数据: 父组件 在 子组件 上 绑定属性 接收数据: 子组件 使用 props 参数接收数据。   function Parent() { const name = \u0026#34;Zhangsan\u0026#34;; const age = 18; return ( \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;Parent Area: \u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;name=Zhangsan, age=18\u0026lt;/span\u0026gt; {/* 1. 通过属性给 Child 传递数据 */} \u0026lt;Child name={name} age={age} /\u0026gt; \u0026lt;/div\u0026gt; ); } // 2. 定义的时候， 使用 props 接收参数 function Child(props) { // 打印所有 props  console.log(props); return ( \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;Child Area: \u0026lt;/span\u0026gt; {/* 3. 使用的时候， 使用 props.name 接收。 name 则是传递过来的属性名 */} \u0026lt;span\u0026gt;name: {props.name}, age: {props.age}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ); } ","description":"/src/components/communication/Parent2Children.jsx\n实现步骤\n 传递数据: 父组件 在 子组件 上 绑定属性 接收数据: 子组件 使用 props 参数接收数据。   function Parent() { const name = \u0026#34;Zhangsan\u0026#34;; const age = 18; return ( \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;Parent Area: \u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;name=Zhangsan, age=18\u0026lt;/span\u0026gt; {/* 1. 通过属性给 Child 传递数据 */} \u0026lt;Child name={name} age={age} /\u0026gt; \u0026lt;/div\u0026gt; ); } // 2. 定义的时候， 使用 props 接收参数 function Child(props) { // 打印所有 props  console.log(props); return ( \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;Child Area: \u0026lt;/span\u0026gt; {/* 3. 使用的时候， 使用 props."},{"id":28,"href":"/books/react/react/router/navigate/","title":"2. 路由导航","parent":"6. React-Router","content":"使用 路由导航 可以在不同组件之间切换。\n创建两个组件 Login 和 Article。 目录结构如下。\n 统一 import 到 RootRouter 下管理， 对应的 router 也需要做调整。\nimport { createBrowserRouter, RouterProvider } from \u0026#34;react-router-dom\u0026#34;; import Login from \u0026#34;./Login\u0026#34;; import Article from \u0026#34;./Article\u0026#34;; const router = createBrowserRouter([ { path: \u0026#34;/login\u0026#34;, element: \u0026lt;Login /\u0026gt; // 登录 Login  }, { path: \u0026#34;/article\u0026#34;, element: \u0026lt;Article /\u0026gt; // 文章 Article  } ]) export default function RootRouter() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;8. 路由页面 Root Page\u0026lt;/h2\u0026gt; \u0026lt;RouterProvider router={router} /\u0026gt; \u0026lt;/div\u0026gt; ); }  声明式导航     声明式导航: 是指通过在模版中使用 \u0026lt;Link /\u0026gt; 组件描述出要跳转到哪里去。 比如后台管理系统的左侧菜单通常使用这种方式进行。\n在文章页面 /src/components/router/Article/index.jsx 中使用 声明式导航\nimport { Link } from \u0026#34;react-router-dom\u0026#34;; export default function Article() { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;8.2 文章页面\u0026lt;/h3\u0026gt; {/* 声明路由 */} {/* to 是固定字段 */} {/* /login 是要跳转的页面 */} \u0026lt;Link to=\u0026#34;/login\u0026#34;\u0026gt;点击登录\u0026lt;/Link\u0026gt; \u0026lt;p\u0026gt;文章页面\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } 语法说明： 通过给组件 to 属性 指定要跳转的 路由 path， 组件会被渲染为浏览器支持的 a 链接。 如果需要传参数， 则可以通过 字符串拼接 的方式。\n编程式导航     编程式导航 是指通过 useNavigate 钩子得到 导航方法， 然后通过调用方法 以命令的形式 进行路由跳转。\n比如想在登录请求完毕之后跳转到某个页面， 就可以使用这种方法， 更加灵活。\n在登录页面 /src/components/router/Login/index.jsx 中使用 编程式导航。\nimport { useNavigate } from \u0026#34;react-router-dom\u0026#34;; export default function Login() { // 通过 useNavigate 获取导航函数  const navigate = useNavigate(); return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;8.1 登录页面\u0026lt;/h3\u0026gt; {/* 点击跳转到页面 */} \u0026lt;button onClick={() =\u0026gt; navigate(\u0026#39;/article\u0026#39;)}\u0026gt;跳转到文章页\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;登录页面\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } 语法说明： 通过调用 navigate 方法传入 path 实现跳转。\n","description":"使用 路由导航 可以在不同组件之间切换。\n创建两个组件 Login 和 Article。 目录结构如下。\n 统一 import 到 RootRouter 下管理， 对应的 router 也需要做调整。\nimport { createBrowserRouter, RouterProvider } from \u0026#34;react-router-dom\u0026#34;; import Login from \u0026#34;./Login\u0026#34;; import Article from \u0026#34;./Article\u0026#34;; const router = createBrowserRouter([ { path: \u0026#34;/login\u0026#34;, element: \u0026lt;Login /\u0026gt; // 登录 Login  }, { path: \u0026#34;/article\u0026#34;, element: \u0026lt;Article /\u0026gt; // 文章 Article  } ]) export default function RootRouter() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;8. 路由页面 Root Page\u0026lt;/h2\u0026gt; \u0026lt;RouterProvider router={router} /\u0026gt; \u0026lt;/div\u0026gt; ); }  声明式导航     声明式导航: 是指通过在模版中使用 \u0026lt;Link /\u0026gt; 组件描述出要跳转到哪里去。 比如后台管理系统的左侧菜单通常使用这种方式进行。"},{"id":29,"href":"/books/react/react/","title":"3. React","parent":"","content":"基于 React18\n","description":"基于 React18"},{"id":30,"href":"/books/react/library/redux/redux-react-counter/","title":"3. Redux 与 React - 实现 Counter(同步)","parent":"redux","content":"先来看一张 Redux 与 React 调用全图。\n  全图左右两个部分， 中间使用 store 关联起来。 左边使用 @reduxjs@toolkit 创建 reducer 管理 store. 右边使用 react-redux 获取数据并修改。   1. 创建 Slice 并初始化 counterReducer     在 /src/store/modules/counterStore.js 创建 reducer 和 actions\n 从 @reduxjs/toolkit 中导入并使用 createSlice 创建 通过 counterSlice.reducer 获取 reducer 并导出。  在 index.js 中引用， 创建 合并reducer   通过 counterSlice.actions 获取 actions 并导出。  在外部代码引用， 使用 useDispatch 调用修改 state 的值。    import { createSlice } from \u0026#39;@reduxjs/toolkit\u0026#39;; const counterSlice = createSlice({ // 设置名称  name: \u0026#39;counter\u0026#39;, // 设置初始状态 state  initialState: { value: 0, }, // 设置修改方法 actions  reducers: { increment: (state) =\u0026gt; { state.value += 1; }, decrement: (state) =\u0026gt; { state.value -= 1; } } }); // 获取并导出 action 对象 const { increment, decrement } = counterSlice.actions; export { increment, decrement }; // 获取并导出 reducer 函数 const counterReducer = counterSlice.reducer; export default counterReducer; 2. 在 index.js 中创建 store     在 /src/store/index.js 中合并 reducers\n 从 @reduxjs/toolkit 中导入并使用 configureStore 创建 store， 合并 reduder。 创建时需要 提供 reducer 对象， 固定名字 不能修改。  使用 counter 作为 counterReducer 的别名。 （这里就有点绕了）   导出 store。  在外部导入， 并使用 Provider 为组件提供 store。    import { configureStore } from \u0026#39;@reduxjs/toolkit\u0026#39;; import counterReducer from \u0026#39;./modules/counterStore\u0026#39;; const store = configureStore({ reducer: { counter: counterReducer }, }); export default store; 3. 父组件使用 Provider 提供 store     在 /src/components/communication/redux/RootReduxReact.jsx 中， 导入 redux state 并为子组件提供\n 从 react-redux 中导入 Provider 使用 Provider 包裹需要使用 redux state 的 父组件  import ReduxCounter from \u0026#34;./ReduxCounter\u0026#34;; import { Provider } from \u0026#34;react-redux\u0026#34;; import store from \u0026#34;../../../store\u0026#34;; export default function RootReduxReact() { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt; 7.5 Redux 与 React\u0026lt;/h3\u0026gt; \u0026lt;Provider store={store}\u0026gt; \u0026lt;ReduxCounter /\u0026gt; \u0026lt;/Provider\u0026gt; \u0026lt;hr\u0026gt;\u0026lt;/hr\u0026gt; \u0026lt;/div\u0026gt; ); } 4. 子组件使用 useSelector 和 useDispatch 获取和操作 reducer state     在 /src/components/communication/redux/ReduxCounter.jsx 获取和操作 reducer state\n  从 react-redux 中导入 useSelector。\n 从 store 中获取对应的的 reducer state. 并通过 解构赋值 拿到 state 对应的 value。    从 react-redux 中导入 useDispatch\n 执行 useDispatch() 获取 dispatch 函数。    方法一： 推荐\n 从对应的 couterStore 中导入对应的 actions， 以备调用。 使用 dispatch 函数调用需要操作的 action 即可。  方法二 是 Github Copilot 自动补全的。 个人觉得并不如 方法一 有关联性\nimport { useSelector, useDispatch } from \u0026#39;react-redux\u0026#39;; // 引入需要被操作的 action import { decrement, increment } from \u0026#39;../../../store/modules/counterStore\u0026#39;; export default function ReduxCounter() { // 有点绕  // reducer 来自 store/index.js 里的 store  // counter 来自 store/index.js 里的 reducer  // value 来自 counter 对应的得 store/modules/counterStore.js 里的 state  const { value } = useSelector(reducer =\u0026gt; reducer.counter); // 执行 useDispatch 获取 dispath 函数  const dispatch = useDispatch(); return ( \u0026lt;div\u0026gt; \u0026lt;h4\u0026gt; 7.5.1 Redux Counter\u0026lt;/h4\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; {/* 写法一： 更推荐 */} {/* 使用 dispatch 调用 action */} \u0026lt;button onClick={() =\u0026gt; dispatch(decrement())}\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;value: {value}\u0026lt;/span\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch(increment())}\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 写法二 */} \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;counter/decrement\u0026#39; })}\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;value: {value}\u0026lt;/span\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;counter/increment\u0026#39; })}\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;hr\u0026gt;\u0026lt;/hr\u0026gt; \u0026lt;/div\u0026gt; ); } 5. 使用 dispatch 提交信息时 action payload 参数      书接上回， 在 /src/store/modules/counterStore.js 中， 添加新的 reducers 行为。\n addMore: 参数 payload 是一个简单值。 addMorePayload: payload 是一个对象。  注意:\n 对应的函数接受参数是 两个， state 和 action。 action.payload 是 固定字段， 不可更改。  如果 payload 是 数组 或者 对象， 则按照其对应类型处理。    const counterSlice = createSlice({ // 设置名称  name: \u0026#39;counter\u0026#39;, // 设置初始状态  initialState: { value: 0, }, // 设置修改方法  reducers: { increment: (state) =\u0026gt; { state.value += 1; }, decrement: (state) =\u0026gt; { state.value -= 1; }, // 支持多个参数  addMore: (state, action) =\u0026gt; { state.value += action.payload }, // action.payload 是固定字段  // 如果要传递多个值， payload 可以是对象或者数组  addMorePayload: (state, action) =\u0026gt; { state.value += action.payload.value } } }); // 导出 addMore const { addMore, addMorePayload } = counterSlice.actions; export { addMore, addMorePayload } 回到 /src/components/communication/redux/ReduxCounter.jsx 中。\n在调用 addMore 和 addMorePayload 的时候 有一个参数传递\nimport { useSelector, useDispatch } from \u0026#39;react-redux\u0026#39;; // 引入需要被操作的 action import { addMore, addMorePayload } from \u0026#39;../../../store/modules/counterStore\u0026#39;; export default function ReduxCounter() { const { value } = useSelector(reducer =\u0026gt; reducer.counter); // 执行 useDispatch 获取 dispath 函数  const dispatch = useDispatch(); // 为 addMorePayload 定义 payload 对象  const payload = { \u0026#34;value\u0026#34;: 10, } return ( \u0026lt;div\u0026gt; \u0026lt;h4\u0026gt; 7.5.1 Redux Counter\u0026lt;/h4\u0026gt; \u0026lt;div\u0026gt; {/* 使用 dispatch 调用 action */} \u0026lt;button onClick={() =\u0026gt; dispatch(decrement())}\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;value: {value}\u0026lt;/span\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch(increment())}\u0026gt;+\u0026lt;/button\u0026gt; {/* 注意: 这里 addMore 传递的 payload 是一个值 */} \u0026lt;button onClick={() =\u0026gt; dispatch(addMore(10))}\u0026gt; payload=+10 \u0026lt;/button\u0026gt; {/* 注意: 传递的 payload 是一个对象 */} \u0026lt;button onClick={() =\u0026gt; dispatch(addMorePayload(payload))}\u0026gt; payload.value=+10 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } ","description":"先来看一张 Redux 与 React 调用全图。\n  全图左右两个部分， 中间使用 store 关联起来。 左边使用 @reduxjs@toolkit 创建 reducer 管理 store. 右边使用 react-redux 获取数据并修改。   1. 创建 Slice 并初始化 counterReducer     在 /src/store/modules/counterStore.js 创建 reducer 和 actions\n 从 @reduxjs/toolkit 中导入并使用 createSlice 创建 通过 counterSlice.reducer 获取 reducer 并导出。  在 index.js 中引用， 创建 合并reducer   通过 counterSlice.actions 获取 actions 并导出。  在外部代码引用， 使用 useDispatch 调用修改 state 的值。    import { createSlice } from \u0026#39;@reduxjs/toolkit\u0026#39;; const counterSlice = createSlice({ // 设置名称  name: \u0026#39;counter\u0026#39;, // 设置初始状态 state  initialState: { value: 0, }, // 设置修改方法 actions  reducers: { increment: (state) =\u0026gt; { state."},{"id":31,"href":"/books/react/react/jsx/list-render/","title":"3. 列表与字典渲染","parent":"1. jsx 基础用法","content":"代码在 /src/components/jsx/ListRender.js 中\n列表默认情况是这样的\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;liubei\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;guanyu\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;zhangfei\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 1. 标准版的渲染     const list = [\u0026#39;liubei\u0026#39;, \u0026#39;guanyu\u0026#39;, \u0026#39;zhangfei\u0026#39;] function ListRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;2.3. 循环渲染\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; list = [\u0026#39;liubei\u0026#39;, \u0026#39;guanyu\u0026#39;, \u0026#39;zhangfei\u0026#39;]\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;箭头函数， 完整版。 带 key \u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; // (1) 保留外城的 ul  { list.map((item, index) =\u0026gt; { // (2) 循环什么就返回什么。  // (3) key 是 React 渲染的唯一表示  return \u0026lt;li key={index}\u0026gt;{item}\u0026lt;/li\u0026gt; }) } \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } 当我们要进行 列表渲染 的时候，\n 使用 列表的 map 方法。 循环的是 \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; 标签， 就在循环中返回该标签。 标签属性 一定要使用 key。 且 key 的值 必须 是 唯一的 unique。  key 是 React 在进行渲染的时候做 diff 算法的标识。 如果不用， 在列表删除的时候就会出现数据偏差。    2. 不规范的省略写法     最常见的不规范写法， 就是省略了 唯一key\n(item) =\u0026gt; (\u0026lt;li\u0026gt;{item}\u0026lt;/li\u0026gt;) 打开控制台， 可以看到 警告 如下：\nWarning: Each child in a list should have a unique \u0026quot;key\u0026quot; prop.  function ListRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;箭头函数 省略版： 有括号\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; { list.map((item) =\u0026gt; (\u0026lt;li\u0026gt;{item}\u0026lt;/li\u0026gt;)) } \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } const list = [\u0026#39;liubei\u0026#39;, \u0026#39;guanyu\u0026#39;, \u0026#39;zhangfei\u0026#39;] 除此之外， 还有一种更省略的写法就是： 省略 圆括号， 这是 JS 的语法特性。\nlist.map(item =\u0026gt; \u0026lt;li\u0026gt;{item}\u0026lt;/li\u0026gt;) 这两种都不是什么好的写法， 不用过多关注， 但是要知道可以这么写。\n其他:      React 的列表渲染 - 黑马 JS Array Usage  ","description":"代码在 /src/components/jsx/ListRender.js 中\n列表默认情况是这样的\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;liubei\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;guanyu\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;zhangfei\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 1. 标准版的渲染     const list = [\u0026#39;liubei\u0026#39;, \u0026#39;guanyu\u0026#39;, \u0026#39;zhangfei\u0026#39;] function ListRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;2.3. 循环渲染\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; list = [\u0026#39;liubei\u0026#39;, \u0026#39;guanyu\u0026#39;, \u0026#39;zhangfei\u0026#39;]\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;箭头函数， 完整版。 带 key \u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; // (1) 保留外城的 ul  { list.map((item, index) =\u0026gt; { // (2) 循环什么就返回什么。  // (3) key 是 React 渲染的唯一表示  return \u0026lt;li key={index}\u0026gt;{item}\u0026lt;/li\u0026gt; }) } \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } 当我们要进行 列表渲染 的时候，"},{"id":32,"href":"/books/react/javascript/introduce/comment/","title":"3. 注释与结束符","parent":"1. 入门简介","content":"1. 注释      单行注释 : // statment 多行注释 : /* statment */  // comment  /* line 1 line 2 */ 2. 结束符     结束符为 分号 ;， 但是大部分时候 不写\n","description":"1. 注释      单行注释 : // statment 多行注释 : /* statment */  // comment  /* line 1 line 2 */ 2. 结束符     结束符为 分号 ;， 但是大部分时候 不写"},{"id":33,"href":"/books/react/react/hooks/use-effect/clear-side-effect/","title":"3. 清理副作用","parent":"useEffect 生命周期管理","content":"3. 清除函数副作用     useEffect 的第一个参数时一个函数。 当该函数有 return 返回值 statement 的时候， 会在 组件被卸载/取消挂载 的时候执行。\n如下代码， return 返回的 箭头函数 会在其所在的组件的组件被卸载的时候 停止计时器 。\n useEffect( () =\u0026gt; { const id = setInterval(() =\u0026gt; { console.log(\u0026#39;Child: setInterval called\u0026#39;); }, 1000); // 当省略清理函数时，  // 组件卸载时，定时器不会被清除  // 当重新加载组件时，会创建新的定时器， 多个定时器会同时运行  return () =\u0026gt; { clearInterval(id); } }, [] // 依赖项为空数组，只有在加载时执行一次， 只有在组件卸载时才会执行清理函数  ) 如果没有这段 return 清空计时器的代码， 那么当所在组件 反复 被挂载时， 每次加载都会启动一个新的定时器， 结果就是 启动无数个 计时器。\n 完整代码     完整代码在 /src/components/hooks/UseEffectClearSideEffect.jsx\n import { useEffect, useState } from \u0026#34;react\u0026#34; export default function UseEffectClearSideEffect() { const [showChild, setShowChild] = useState(true); return ( \u0026lt;div\u0026gt; \u0026lt;h4\u0026gt;4.2 UseEffict 清理副作用\u0026lt;/h4\u0026gt; \u0026lt;p\u0026gt;当组件卸载时，清理副作用\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;打开控制台查看信息： Child: setInterval called\u0026lt;/p\u0026gt; {showChild \u0026amp;\u0026amp; \u0026lt;Child /\u0026gt;} \u0026lt;button onClick={() =\u0026gt; { setShowChild(!showChild) }}\u0026gt;点我清除 Child 组件\u0026lt;/button\u0026gt; \u0026lt;/div \u0026gt; ) } function Child() { useEffect( () =\u0026gt; { const id = setInterval(() =\u0026gt; { console.log(\u0026#39;Child: setInterval called\u0026#39;); }, 1000); // 当省略清理函数时，  // 组件卸载时，定时器不会被清除  // 当重新加载组件时，会创建新的定时器， 多个定时器会同时运行  return () =\u0026gt; { clearInterval(id); } }, [] // 依赖项为空数组，只有在加载时执行一次， 只有在组件卸载时才会执行清理函数  ) return ( \u0026lt;div\u0026gt; \u0026lt;/div\u0026gt; ) } ","description":"3. 清除函数副作用     useEffect 的第一个参数时一个函数。 当该函数有 return 返回值 statement 的时候， 会在 组件被卸载/取消挂载 的时候执行。\n如下代码， return 返回的 箭头函数 会在其所在的组件的组件被卸载的时候 停止计时器 。\n useEffect( () =\u0026gt; { const id = setInterval(() =\u0026gt; { console.log(\u0026#39;Child: setInterval called\u0026#39;); }, 1000); // 当省略清理函数时，  // 组件卸载时，定时器不会被清除  // 当重新加载组件时，会创建新的定时器， 多个定时器会同时运行  return () =\u0026gt; { clearInterval(id); } }, [] // 依赖项为空数组，只有在加载时执行一次， 只有在组件卸载时才会执行清理函数  ) 如果没有这段 return 清空计时器的代码， 那么当所在组件 反复 被挂载时， 每次加载都会启动一个新的定时器， 结果就是 启动无数个 计时器。"},{"id":34,"href":"/books/react/react/communication/props/slot-children/","title":"3. 特殊的 children 插槽","parent":"1. props 通信","content":"/src/components/communication/RootCommunication.jsx\nexport default function RootCommunication() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt; 7. 组件通信\u0026lt;/h2\u0026gt; {/* 1. 自闭和标签 */} \u0026lt;Parent2Children /\u0026gt; {/* 2. 成对标签， 默认插槽 */} \u0026lt;PropChild\u0026gt; \u0026lt;span\u0026gt;span1\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;span2\u0026lt;/span\u0026gt; \u0026lt;/PropChild\u0026gt; \u0026lt;/div\u0026gt; ); } 可以看到在使用 PropChild\n 使用的是 成对标签。 标签中放入了两个 span 标签。  function PropChild(props) { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;7.1. 特殊的 props.children\u0026lt;/h3\u0026gt; {/* 拿到默认的 children 属性 */} \u0026lt;span\u0026gt;prop child: {props.children}\u0026lt;/span\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;/div\u0026gt; ) } 在 PropChild 内部， 使用 props.children 拿到了传过来的标签值\n 使用 React Developer Tool 可以更清晰的看到其属性\n ","description":"/src/components/communication/RootCommunication.jsx\nexport default function RootCommunication() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt; 7. 组件通信\u0026lt;/h2\u0026gt; {/* 1. 自闭和标签 */} \u0026lt;Parent2Children /\u0026gt; {/* 2. 成对标签， 默认插槽 */} \u0026lt;PropChild\u0026gt; \u0026lt;span\u0026gt;span1\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;span2\u0026lt;/span\u0026gt; \u0026lt;/PropChild\u0026gt; \u0026lt;/div\u0026gt; ); } 可以看到在使用 PropChild\n 使用的是 成对标签。 标签中放入了两个 span 标签。  function PropChild(props) { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;7.1. 特殊的 props.children\u0026lt;/h3\u0026gt; {/* 拿到默认的 children 属性 */} \u0026lt;span\u0026gt;prop child: {props.children}\u0026lt;/span\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;/div\u0026gt; ) } 在 PropChild 内部， 使用 props.children 拿到了传过来的标签值\n 使用 React Developer Tool 可以更清晰的看到其属性"},{"id":35,"href":"/books/react/react/components/","title":"3. 组件","parent":"3. React","content":"","description":""},{"id":36,"href":"/books/react/demos/redux-meituan/menu/","title":"3. 菜单交互","parent":"2. redux-meituan","content":" 1. 菜单选中     在 /src/demos/redux-meituan/store/modules/takeaway.js 中\n 增加新的 state 字段 activeIndex 表示选中的菜单。 其值为对应的 foodsList 数组的 index 位置。 增加新的 reducer action setActiveIndex , 这是一个 同步 方法。 导出 setActiveIndex 以供外部使用  部分代码\nconst takeaway = createSlice({ // 名称  name: \u0026#39;takeaway\u0026#39;, // 初始数据  initialState: { // 当前选中的菜单分类  activeIndex: 0, }, // actions  reducers: { setActiveIndex: (state, action) =\u0026gt; { state.activeIndex = action.payload } } }) // 省略 ...  // 3. 导出 activeIndex 的 action export const { setActiveIndex } = takeaway.actions 在 /src/demos/redux-meituan/components/Menu/index.js 中，\n 使用 useSelector 从 state 中获取 activeIndex 。 使用 useDispatch 在菜单栏选中的时候调用 setActiveIndex 修改值。 使用 className 库， 通过 逻辑判断 返回 active 标签。  import classNames from \u0026#39;classnames\u0026#39; import \u0026#39;./index.scss\u0026#39; import { useSelector } from \u0026#39;react-redux\u0026#39; import { useDispatch } from \u0026#39;react-redux\u0026#39; import { setActiveIndex } from \u0026#39;../../store/modules/takeaway\u0026#39; const Menu = () =\u0026gt; { // 获取 activeIndex  const { activeIndex } = useSelector(state =\u0026gt; state.takeaway) const dispatch = useDispatch() const menus = foodsList.map(item =\u0026gt; ({ tag: item.tag, name: item.name })) return ( \u0026lt;nav className=\u0026#34;list-menu\u0026#34;\u0026gt; {/* 添加active类名会变成激活状态 */} {menus.map((item, index) =\u0026gt; { return ( \u0026lt;div key={item.tag} className={classNames( \u0026#39;list-menu-item\u0026#39;, // 如果当前的index等于activeIndex则添加active类名  activeIndex === index \u0026amp;\u0026amp; \u0026#39;active\u0026#39; )} // 点击时, 使用 dispatch 触发 setActiveIndex onClick={() =\u0026gt; dispatch(setActiveIndex(index))} \u0026gt; {item.name} \u0026lt;/div\u0026gt; ) })} \u0026lt;/nav\u0026gt; ) } // 省略 ... 2. 商品分类切换     在 /src/demos/redux-meituan/components/FoodsCategory/index.js 中可以看到\n所展示的 foods 信息是从上层传递过来的。\n// 上层传递的 foods const FoodsCategory = ({ name, foods }) =\u0026gt; { return ( \u0026lt;div className=\u0026#34;category\u0026#34;\u0026gt; {/* 省略 ... */} \u0026lt;/div\u0026gt; ) } 找到上层调用文件 /src/demos/redux-meituan/ReduxMeituan.jsx\n可以看到， 这里将所有的 foodsList 通过 map 方法直接展示了。\nconst ReduxMeituan = () =\u0026gt; { // 使用 useSelector 获取 store 数据  const { foodsList } = useSelector(state =\u0026gt; state.takeaway) return ( // 省略 ...  \u0026lt;div className=\u0026#34;goods-list\u0026#34;\u0026gt; {/* 外卖商品列表 */} {foodsList.map((item) =\u0026gt; { // 根据条件判断是否显示  return ( \u0026lt;FoodsCategory key={item.tag} // 列表标题 name={item.name} // 列表商品 foods={item.foods} /\u0026gt; ) })} \u0026lt;/div\u0026gt; // 省略 ...  ) } 如果要根据前面实现的 所选分类 进行展示， 就需要对 foodsList 过滤。\n2.1. 使用 map 方法对渲染对象进行过滤      在使用 map 方法的时候传入的函数具有两个参数： item 和 index。 通过 index 和 activeIndex 进行对比， 判断对象是否需要渲染并返回。  // {/* 方法1: 内部过滤 */}  {foodsList.map((item, index) =\u0026gt; { // 根据条件判断是否显示 if (index === activeIndex) { return ( \u0026lt;FoodsCategory key={item.tag} // 列表标题 name={item.name} // 列表商品 foods={item.foods} /\u0026gt; ) } })} 2.2. 使用 filter 方法对 foodsList 过滤      这种方法在渲染的时候 行为 保持不变。 但是对于被渲染的 foodsList 使用 filter 方法进行 提前 过滤。  const ReduxMeituan = () =\u0026gt; { // 使用 useSelector 获取 store 数据  // 使用 let 定义 foodsList, 可以修改  let { foodsList } = useSelector(state =\u0026gt; state.takeaway) // 使用 filter 方法过滤。 并用同名变量接收  foodsList = foodsList.filter( (_, index) =\u0026gt; { return index === activeIndex } ) return ( // 省略 ...  \u0026lt;div className=\u0026#34;home\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;goods-list\u0026#34;\u0026gt; {/* 外卖商品列表 */} {/* 方法2: 外部过滤 */} { foodsList.map( (item) =\u0026gt; { return ( \u0026lt;FoodsCategory key={item.tag} // 列表标题 name={item.name} // 列表商品 foods={item.foods} /\u0026gt; ) } ) } \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; // 省略 ...  ) } 实现的方法不一样，效果一样。 法无定法。\n","description":"1. 菜单选中     在 /src/demos/redux-meituan/store/modules/takeaway.js 中\n 增加新的 state 字段 activeIndex 表示选中的菜单。 其值为对应的 foodsList 数组的 index 位置。 增加新的 reducer action setActiveIndex , 这是一个 同步 方法。 导出 setActiveIndex 以供外部使用  部分代码\nconst takeaway = createSlice({ // 名称  name: \u0026#39;takeaway\u0026#39;, // 初始数据  initialState: { // 当前选中的菜单分类  activeIndex: 0, }, // actions  reducers: { setActiveIndex: (state, action) =\u0026gt; { state.activeIndex = action.payload } } }) // 省略 ."},{"id":37,"href":"/books/react/react/router/navigate-params/","title":"3. 路由传参","parent":"6. React-Router","content":"有 两种 方式可以通过 路由地址 进行参数传递。\n 路径传参: /path/1234/zhangsan query请求传参: /article?id=1101\u0026amp;name=wangwu  1. 路径传参     顾名思义， 就是 将参数放在 path 中。\n 在使用之前需要 定义参数名称和位置。 使用 useParams 接受参数  在 /src/components/router/RootRouter.jsx 中\nconst router = createBrowserRouter([ { // 定义参数位置和名称  path: \u0026#34;/article/:id/:name\u0026#34;, element: \u0026lt;Article /\u0026gt; } ]) 在 /src/components/router/Article/index.jsx 中使用 useParams 使用 解构赋值 接受参数\nimport { Link } from \u0026#34;react-router-dom\u0026#34;; import { useParams } from \u0026#34;react-router-dom\u0026#34;; export default function Article() { // 使用 解构赋值 获取路由参数  const { id, name } = useParams(); return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;8.2 文章页面\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;文章页面\u0026lt;/p\u0026gt; {/* 使用路由参数 */} \u0026lt;span\u0026gt;id: {id}, name: {name}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ); } 2. query请求传参      在 path 后面添加请求参数。 使用 useSearchParams 接受参数。  使用 .get 方法获取 参数名对应的值。 setParams 可以更新请求参数列表。    在 /src/components/router/Login/index.jsx 中， 使用 useSearchParams 接收参数\nimport { useNavigate } from \u0026#34;react-router-dom\u0026#34;; import { useSearchParams } from \u0026#34;react-router-dom\u0026#34;; export default function Login() { // 接收参数  const [params, setParams] = useSearchParams(); // 通过 get 方法获取参数  let id = params.get(\u0026#39;id\u0026#39;); let name = params.get(\u0026#39;name\u0026#39;); return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;8.1 登录页面\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;登录页面\u0026lt;/p\u0026gt; \u0026lt;span\u0026gt;id: {id}, name: {name}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ); } ","description":"有 两种 方式可以通过 路由地址 进行参数传递。\n 路径传参: /path/1234/zhangsan query请求传参: /article?id=1101\u0026amp;name=wangwu  1. 路径传参     顾名思义， 就是 将参数放在 path 中。\n 在使用之前需要 定义参数名称和位置。 使用 useParams 接受参数  在 /src/components/router/RootRouter.jsx 中\nconst router = createBrowserRouter([ { // 定义参数位置和名称  path: \u0026#34;/article/:id/:name\u0026#34;, element: \u0026lt;Article /\u0026gt; } ]) 在 /src/components/router/Article/index.jsx 中使用 useParams 使用 解构赋值 接受参数\nimport { Link } from \u0026#34;react-router-dom\u0026#34;; import { useParams } from \u0026#34;react-router-dom\u0026#34;; export default function Article() { // 使用 解构赋值 获取路由参数  const { id, name } = useParams(); return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;8."},{"id":38,"href":"/books/react/react/hooks/","title":"4. Hooks","parent":"3. React","content":"Hook 是用来实现 逻辑的封装和复用 的函数。\n在官网中， 有对 Hook 函数的专门介绍\n1. Hook 使用使用规则     Hook 函数有 两条核心 使用规则\n 只能在 React Function（组件） 内部调用。 即 不能 在  普通 JS 函数 中调用。 不能在 React Fucntion 外部调用    // 错误示范: 外部调用 const [count, setCount] = useState(0) function MyComponenet() { return ( \u0026lt;div\u0026gt; \u0026lt;/div\u0026gt; ) } 只能在 顶层 使用 Hook。 即 不能 在以下位置使用  loop: 循环 condition: 条件语句 netsted function: 嵌套函数    export default function MyComponenet() { function Add() { if (Math.random() \u0026gt; 0.5) { // 错误示范， 在条件语句中使用 Hook  const [count, setCount] = useState(0) setCount(count + 1) } } return ( \u0026lt;div\u0026gt; \u0026lt;/div\u0026gt; ) } 2. Hook 列表     在官网中，提供了 Hooks API Reference 列表和用法\n  Basic Hooks:\n useState useEffect useContext    Additional Hooks:\n useReducer useCallback useRef ...    Library Hooks:\n useSyncExternalStore useInsertionEffect    ","description":"Hook 是用来实现 逻辑的封装和复用 的函数。\n在官网中， 有对 Hook 函数的专门介绍\n1. Hook 使用使用规则     Hook 函数有 两条核心 使用规则\n 只能在 React Function（组件） 内部调用。 即 不能 在  普通 JS 函数 中调用。 不能在 React Fucntion 外部调用    // 错误示范: 外部调用 const [count, setCount] = useState(0) function MyComponenet() { return ( \u0026lt;div\u0026gt; \u0026lt;/div\u0026gt; ) } 只能在 顶层 使用 Hook。 即 不能 在以下位置使用  loop: 循环 condition: 条件语句 netsted function: 嵌套函数    export default function MyComponenet() { function Add() { if (Math."},{"id":39,"href":"/books/react/library/redux/redux-react-channel/","title":"4. Redux 与 React - 实现 Channel (异步)","parent":"redux","content":"异步 的实现方法和同步差不多。\n1. 使用 createSlice 创建     在 /src/store/modules/channelStore.js 中创建 Channel Store。 这一步同步是一样的。\nconst channelSlice = createSlice({ // 名称  name: \u0026#39;channel\u0026#39;, // 初始化数据  initialState: { channels: [ { id: 1, name: \u0026#39;网络不通， 检查网络\u0026#39; }, ], }, // actions 方法  reducers: { setChannels(state, action) { state.channels = action.payload; } }, }) 2. 导出 reducer 到 store/index.js     这一部分也一样\n在 /src/store/modules/channelStore.js 中导出 reduder，\n// 导出 reducer 到 store/index.js 中 const channelReducer = channelSlice.reducer; export default channelReducer; 并组合到 /src/store/index.js 中。\nimport { configureStore } from \u0026#39;@reduxjs/toolkit\u0026#39;; // 引入 import channelReducer from \u0026#39;./modules/channelStore\u0026#39;; const store = configureStore({ reducer: { // 组合，命名  channel: channelReducer, }, }); 3. 使用 thunk 封装异步函数并导出     注意: 这一步就 很不一样 了。 由于需要 异步 操作，\n 就需要 封装并返回 thunk 函数， 并 返回一个异步函数， 使用 dispatch 执行调用。  在 /src/store/modules/channelStore.js 中， 针对 setChannels 行为封装了一个名为 fetchChannels 的函数\n// 异步请求不在直接提供 action，而是提供了一个 thunk 函数 const { setChannels } = channelSlice.actions; // export { setChannels };  // 定义一个 thunk 函数返回一个异步函数 const fetchChannels = () =\u0026gt; { // 返回一个异步函数  // 传入 dispatch 参数。 这个参数来自于外部调用这个函数的地方。  // const dispath = useDispatch();  return async (dispatch) =\u0026gt; { const res = await axios.get(`http://geek.itheima.net/v1_0/channels`) .catch( err =\u0026gt; console.log(err) ) if (res?.status === 200) { // 这个函数会在 dispatch 的时候执行  dispatch(setChannels(res.data.data.channels)); } } } // 导出 thunk 函数 export { fetchChannels }; 4. 外部使用 useSelector 获取数据     这一步没什么不同。\n在 /src/components/communication/redux/ReduxChannel.jsx 中\nimport { useSelector, useDispatch } from \u0026#39;react-redux\u0026#39;; export default function ReduxChannel() { // useSelector 用于获取 store/index.js 中的 channel 对象  // channels: 使用解构赋值获取。 来自于 channel reducer 中的 state 对象  const { channels } = useSelector(reducer =\u0026gt; reducer.channel); return ( \u0026lt;div\u0026gt; \u0026lt;h4\u0026gt; 7.5.2 Redux Channel（异步）\u0026lt;/h4\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {channels.map(channel =\u0026gt; ( \u0026lt;li key={channel.id}\u0026gt;{channel.name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } 5. 外部使用 useDispatch 调用修改数据     在使用方便， 异步和同步 差别不大， 都使用 useDispatch 调用。\n在 /src/components/communication/redux/ReduxChannel.jsx 中\n 获取 thunk 函数 fetchChannels 使用 dispatch(fn) 调用。 这里使用了 useEffect 生命周期函数辅助调用。  明明这里是 dispatch 在调用 fn， 但是在在 fn 的实现中时将 dispatch 作为参数传递到内部了的。 至于这里怎么把 dispatch 传递给 fn 的我就搞不清楚了。\nimport { useSelector, useDispatch } from \u0026#39;react-redux\u0026#39;; // 导入 fetchChannels import { fetchChannels } from \u0026#39;../../../store/modules/channelStore\u0026#39;; import { useEffect } from \u0026#39;react\u0026#39;; export default function ReduxChannel() { // useSelector 用于获取 store/index.js 中的 channel 对象  // channels: 使用解构赋值获取。 来自于 channel reducer 中的 state 对象  const { channels } = useSelector(reducer =\u0026gt; reducer.channel); // 获取 dispatch  const dispatch = useDispatch(); useEffect(() =\u0026gt; { // 使用 dispatch 调用  dispatch(fetchChannels()); }, [dispatch]); return ( \u0026lt;div\u0026gt; \u0026lt;h4\u0026gt; 7.5.2 Redux Channel（异步）\u0026lt;/h4\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {channels.map(channel =\u0026gt; ( \u0026lt;li key={channel.id}\u0026gt;{channel.name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } 不清楚视频中使用 useEffect 时为什么依赖 dispatch。\n","description":"异步 的实现方法和同步差不多。\n1. 使用 createSlice 创建     在 /src/store/modules/channelStore.js 中创建 Channel Store。 这一步同步是一样的。\nconst channelSlice = createSlice({ // 名称  name: \u0026#39;channel\u0026#39;, // 初始化数据  initialState: { channels: [ { id: 1, name: \u0026#39;网络不通， 检查网络\u0026#39; }, ], }, // actions 方法  reducers: { setChannels(state, action) { state.channels = action.payload; } }, }) 2. 导出 reducer 到 store/index.js     这一部分也一样\n在 /src/store/modules/channelStore.js 中导出 reduder，"},{"id":40,"href":"/books/react/react/communication/props/children-to-parent/","title":"4. 子传父通信","parent":"1. props 通信","content":"/src/components/communication/Children2Parent.jsx\n核心思路: 父组件可以给子组件传递一个函数， 子组件通过调用函数向父组件传递数据\n  父组件通过 props 向子组件传递数据， 但 在子组件中 props 是只读的。 因此 数据只能在父组件中被修改  function Parent() { const original = \u0026#34;Father.React\u0026#34; // 在父组件定义一个状态数据  const [name, setName] = useState(original) // 重置名字  function resetName() { setName(original) } // 1. 通过函数修改父组件的状态数据  function changeName(name) { setName(name) } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;父组件名字: {name}\u0026lt;/p\u0026gt; \u0026lt;b\u0026gt;父组件区域: \u0026lt;/b\u0026gt; \u0026lt;button onClick={resetName}\u0026gt;重置名称\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;重置父组件名字\u0026lt;/span\u0026gt; {/* 1. 通过 props 将函数传递给子组件 2. props 属性名字加上 on 表示调用执行 */} \u0026lt;hr\u0026gt;\u0026lt;/hr\u0026gt; \u0026lt;Child onChangeName={changeName} /\u0026gt; \u0026lt;/div\u0026gt; ) } 在 父组件中\n 使用 useState 创建一个状态数据 name， 用于管理变量的变化。 创建 changeName 函数， 修改 name 值的状态。 在 Child 组件中， 使用 onChangeName 作为 props 属性名称， 表示 事件触发。  // 在子组件中通过 props 调用父组件的函数 // 使用解构赋值的方式获取父组件传递的函数 function Child({ onChangeName }) { return ( \u0026lt;div\u0026gt; \u0026lt;b\u0026gt;子组件区域: \u0026lt;/b\u0026gt; \u0026lt;button onClick={() =\u0026gt; onChangeName(\u0026#34;Child.Vue\u0026#34;)}\u0026gt;点我修改\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;将父组件名字修改为 Child.Vue\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ) } 在 子组件中\n 接受 props 参数。 案例中使用了 ES 的解构语法({ onChangeName })获取了 onChangeName 在 button 中使用 onClick 事件， 调用 onChangeName 函数， 向父组件传递新名字。  注意: 如果没有使用解构语法， 则使用 props.onChangeName 调用即可。\n ","description":"/src/components/communication/Children2Parent.jsx\n核心思路: 父组件可以给子组件传递一个函数， 子组件通过调用函数向父组件传递数据\n  父组件通过 props 向子组件传递数据， 但 在子组件中 props 是只读的。 因此 数据只能在父组件中被修改  function Parent() { const original = \u0026#34;Father.React\u0026#34; // 在父组件定义一个状态数据  const [name, setName] = useState(original) // 重置名字  function resetName() { setName(original) } // 1. 通过函数修改父组件的状态数据  function changeName(name) { setName(name) } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;父组件名字: {name}\u0026lt;/p\u0026gt; \u0026lt;b\u0026gt;父组件区域: \u0026lt;/b\u0026gt; \u0026lt;button onClick={resetName}\u0026gt;重置名称\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;重置父组件名字\u0026lt;/span\u0026gt; {/* 1. 通过 props 将函数传递给子组件 2. props 属性名字加上 on 表示调用执行 */} \u0026lt;hr\u0026gt;\u0026lt;/hr\u0026gt; \u0026lt;Child onChangeName={changeName} /\u0026gt; \u0026lt;/div\u0026gt; ) } 在 父组件中"},{"id":41,"href":"/books/react/react/router/nested-routers/","title":"4. 嵌套路由","parent":"6. React-Router","content":"嵌套路由: 在一级路由中 内嵌 了其他路由， 这种路由关系就叫做 嵌套路由。\n嵌套到一级路由内的路由又被称为 二级路由。 以此类推， 三级、四级路由。\n 最常见应用场景， 就是 系统管理界面， 如图。\n 1. 使用 children 属性配置路由嵌套关系     在 /src/components/router/RootRouter.jsx 中， 添加路由表。\nconst router = createBrowserRouter([ { path: \u0026#34;/\u0026#34;, element: \u0026lt;Layout /\u0026gt;, // 指定子路由  children: [ // 子路由与父路由定义方式一样  { path: \u0026#34;/board\u0026#34;, element: \u0026lt;Board /\u0026gt; }, { path: \u0026#34;/about\u0026#34;, element: \u0026lt;About /\u0026gt; } ], } ]) 2. 使用 \u0026lt;Outlet /\u0026gt; 指定二级路由渲染位置     在 /src/components/router/Layout/index.jsx 中， 使用 \u0026lt;Outlet /\u0026gt; 指定二级页面渲染位置。\nimport { Link, Outlet } from \u0026#34;react-router-dom\u0026#34;; export default function Layout() { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;8.3 Layout\u0026lt;/h3\u0026gt; \u0026lt;Link to=\u0026#34;/\u0026#34;\u0026gt;首页｜\u0026lt;/Link\u0026gt; \u0026lt;Link to=\u0026#34;/board\u0026#34;\u0026gt;面板｜\u0026lt;/Link\u0026gt; \u0026lt;Link to=\u0026#34;/about\u0026#34;\u0026gt;关于\u0026lt;/Link\u0026gt; {/* 子页面渲染占位 */} \u0026lt;Outlet /\u0026gt; \u0026lt;/div\u0026gt; ); } 3. 默认二级路由     当访问一级路由时， 默认的 二级路由和组件 可以被渲染。\n 在二级路由位置 去掉 path 增加 index: true 属性。  由于去掉了 path, 则对应的二级路由路径则不存在了。\nconst router = createBrowserRouter([ { path: \u0026#34;/\u0026#34;, element: \u0026lt;Layout /\u0026gt;, children: [ { // 删除 path 属性，增加 index: 表示默认路由  // path: \u0026#34;/board\u0026#34;,  index: true, element: \u0026lt;Board /\u0026gt; }, { path: \u0026#34;/about\u0026#34;, element: \u0026lt;About /\u0026gt; } ], } ]) ","description":"嵌套路由: 在一级路由中 内嵌 了其他路由， 这种路由关系就叫做 嵌套路由。\n嵌套到一级路由内的路由又被称为 二级路由。 以此类推， 三级、四级路由。\n 最常见应用场景， 就是 系统管理界面， 如图。\n 1. 使用 children 属性配置路由嵌套关系     在 /src/components/router/RootRouter.jsx 中， 添加路由表。\nconst router = createBrowserRouter([ { path: \u0026#34;/\u0026#34;, element: \u0026lt;Layout /\u0026gt;, // 指定子路由  children: [ // 子路由与父路由定义方式一样  { path: \u0026#34;/board\u0026#34;, element: \u0026lt;Board /\u0026gt; }, { path: \u0026#34;/about\u0026#34;, element: \u0026lt;About /\u0026gt; } ], } ]) 2. 使用 \u0026lt;Outlet /\u0026gt; 指定二级路由渲染位置     在 /src/components/router/Layout/index."},{"id":42,"href":"/books/react/react/jsx/conditional-render/","title":"4. 条件渲染","parent":"1. jsx 基础用法","content":"React 根据条件运算返回的不同结果进行结果渲染， 主要分为以下几种\n 逻辑判断： \u0026amp;\u0026amp;, ||, ! 三目运算符: condition? yes : no 分支语句： if-else, switch  1. 逻辑运算符     逻辑运算符：\n \u0026amp;\u0026amp; 且 || 或 ! 非  function ConditionalRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;04. 条件渲染: isLogin={String(isLogin)}\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;1. 逻辑语句\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;isLogin \u0026amp;\u0026amp; Login \u0026lt;/p\u0026gt; {isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt;} \u0026lt;p\u0026gt;isLogin || Logout\u0026lt;/p\u0026gt; {isLogin || \u0026lt;Logout /\u0026gt;} \u0026lt;p\u0026gt;isLogin \u0026amp;\u0026amp; Login || Logout\u0026lt;/p\u0026gt; {isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; || \u0026lt;Logout /\u0026gt;} {(isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt;) || \u0026lt;Logout /\u0026gt;} \u0026lt;/div \u0026gt; ) } const isLogin = false;  条件语句 必须要在最前面。 \u0026amp;\u0026amp; 和 || 可以单独使用； 也可以一起使用， 一起使用时效果类似 三目运算符。  但是 React 并不推荐这么做， 如果这样做了会给予提示： 混合使用 \u0026amp;\u0026amp; 和 ||。 请用 圆括号 指定执行顺序\nLine 10:16: Unexpected mix of '\u0026amp;\u0026amp;' and '||'. Use parentheses to clarify the intended order of operations 因此我们可以通过 圆括号 进行归类， 注意括号未知。\n{(isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt;) || \u0026lt;Logout /\u0026gt;} {isLogin \u0026amp;\u0026amp; (\u0026lt;Login /\u0026gt; || \u0026lt;Logout /\u0026gt;)} 2. 三目运算符     三目运算符 具有固定格式： condition? yes : no ， 注意分隔符。\nfunction ConditionalRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;2. 三目运算符 \u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;isLogin ? Login : Logout\u0026lt;/p\u0026gt; {isLogin ? \u0026lt;Login /\u0026gt; : \u0026lt;Logout /\u0026gt;} \u0026lt;/div \u0026gt; ) } const isLogin = false; 3. 分支条件语句     分支条件语句\n 在 statement 中可以实现更复杂的操作 可以返回更多的 条件结果。  function ConditionalRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;04. 条件渲染: isLogin={String(isLogin)}\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;3. 分支函数\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;if (isLogin); return Login; else return Logout; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{Condition()}\u0026lt;/p\u0026gt; \u0026lt;/div \u0026gt; ) } const isLogin = false; function Condition() { if (isLogin) { {/* 其他操作 */} console.log(isLogin) return \u0026lt;Login /\u0026gt; } else { return \u0026lt;Logout /\u0026gt; } } 注意 Condition 由于 只有两个条件 结果， 非此即彼。因此函数还可以写成 以下形式 不用 else。\nfunction Condition() { if (isLogin) { return \u0026lt;Login /\u0026gt; } return \u0026lt;Logout /\u0026gt; } 其他:      如何渲染布尔值: String(bool1) jsx 简单条件渲染 jsx 复杂条件渲染  ","description":"React 根据条件运算返回的不同结果进行结果渲染， 主要分为以下几种\n 逻辑判断： \u0026amp;\u0026amp;, ||, ! 三目运算符: condition? yes : no 分支语句： if-else, switch  1. 逻辑运算符     逻辑运算符：\n \u0026amp;\u0026amp; 且 || 或 ! 非  function ConditionalRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;04. 条件渲染: isLogin={String(isLogin)}\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;1. 逻辑语句\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;isLogin \u0026amp;\u0026amp; Login \u0026lt;/p\u0026gt; {isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt;} \u0026lt;p\u0026gt;isLogin || Logout\u0026lt;/p\u0026gt; {isLogin || \u0026lt;Logout /\u0026gt;} \u0026lt;p\u0026gt;isLogin \u0026amp;\u0026amp; Login || Logout\u0026lt;/p\u0026gt; {isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; || \u0026lt;Logout /\u0026gt;} {(isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt;) || \u0026lt;Logout /\u0026gt;} \u0026lt;/div \u0026gt; ) } const isLogin = false;  条件语句 必须要在最前面。 \u0026amp;\u0026amp; 和 || 可以单独使用； 也可以一起使用， 一起使用时效果类似 三目运算符。  但是 React 并不推荐这么做， 如果这样做了会给予提示： 混合使用 \u0026amp;\u0026amp; 和 ||。 请用 圆括号 指定执行顺序"},{"id":43,"href":"/books/react/demos/redux-meituan/cart-list/","title":"4. 购物车管理","parent":"2. redux-meituan","content":"1. 添加购物车     在 /src/demos/redux-meituan/components/Cart/index.js 中可以看到 购物车 的相关配置。\n可以看到 购物车 的数据定义是 cart=[] 空数组。\nconst Cart = () =\u0026gt; { const cart = [] // 省略 ... } 在 /src/demos/redux-meituan/components/FoodsCategory/FoodItem/index.js 中\n可以看到 具体商品 配置。 从传入的 props 中解构出来了所有商品字段。\nconst Foods = ({ id, picture, name, unit, description, food_tag_list, month_saled, like_ratio_desc, price, tag, count }) =\u0026gt; { // 省略 ... } 1.1. 优化 store     因此在 /src/demos/redux-meituan/store/modules/takeaway.js 中\n 定义 state.cartList 增加 action 添加商品到购物车  判断商品是否 已经存在 如果存在， 则商品 count+1 如果不存在， 则将商品 push 到购物车 并 count=1    const takeaway = createSlice({ // 名称  name: \u0026#39;takeaway\u0026#39;, // 初始数据  initialState: { // 购物车列表数据  cartList: [], }, // actions  reducers: { // 增加物品到购物车  addCartList: (state, action) =\u0026gt; { // 1. 判断购物车中是否已经有该物品  // 如果没有找到，则返回 -1  const index = state.cartList.findIndex(item =\u0026gt; item.id === action.payload.id) // 2. 如果有，则数量 +1  if (index \u0026gt; -1) { state.cartList[index].count += 1 return } // 3. 如果没有，则添加到购物车, 并且数量为 1  // 使用 解构语法  state.cartList.push({ ...action.payload, count: 1 }) }, } }) 1.2. 添加商品交互     在 /src/demos/redux-meituan/components/FoodsCategory/FoodItem/index.js 中，\n找到 添加按钮(plus)， 绑定 onClick 事件。\n 定义 onPlus 方法， 使用 dispatch 添加数据。 在调用 onPlus 方法的时候， 需要传入 整个 商品对象。 代码看起来有点臃肿。  import { useDispatch } from \u0026#39;react-redux\u0026#39; import { addCartList } from \u0026#39;../../../store/modules/takeaway\u0026#39; const Foods = ({...}) =\u0026gt; { const dispatch = useDispatch() const onPlus = (item) =\u0026gt; { dispatch(addCartList(item)) } return ( \u0026lt;div className=\u0026#34;cate-goods\u0026#34;\u0026gt; {/* 添加购物车 */} \u0026lt;div className=\u0026#34;goods-count\u0026#34;\u0026gt; \u0026lt;span className=\u0026#34;plus\u0026#34; onClick={() =\u0026gt; onPlus( { id, picture, name, unit, description, food_tag_list, month_saled, like_ratio_desc, price, tag, count } )}\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } 随后就可以通过 Redux DevTools 插件 进行数据测试了\n 2. 显示购物车     回到 购物车 /src/demos/redux-meituan/components/Cart/index.js 中，\n 使用 useSelector 从 state 中获取数据。  由于在 state 中定义的字段是 cartList， 因此在解构赋值的时候， 使用了别名。 其他渲染代码不变   修改 购物车 panel 的标签属性。 增加 visable 显示购物车。  import classNames from \u0026#39;classnames\u0026#39; import { useSelector } from \u0026#39;react-redux\u0026#39; const Cart = () =\u0026gt; { // const cart = []  // 解构赋值， 并使用别名  const { cartList: cart } = useSelector(state =\u0026gt; state.takeaway) return ( \u0026lt;div className=\u0026#34;cartContainer\u0026#34;\u0026gt; {/* 添加visible类名 div会显示出来 */} {/* 显示购物车 */} \u0026lt;div className={classNames( \u0026#39;cartPanel\u0026#39;, \u0026#39;visible\u0026#39; )}\u0026gt; \u0026lt;div className=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;span className=\u0026#34;text\u0026#34;\u0026gt;购物车\u0026lt;/span\u0026gt; \u0026lt;span className=\u0026#34;clearCart\u0026#34;\u0026gt; 清空购物车 \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) }  3. 购物车统计功能     在 /src/demos/redux-meituan/components/Cart/index.js 中\n 使用 reduce 统计已选商品数量 使用 reduce 计算已选商品价格 判断已选商品价格是否达到最低配送标准  import classNames from \u0026#39;classnames\u0026#39; import Count from \u0026#39;../Count\u0026#39; import \u0026#39;./index.scss\u0026#39; import { useSelector } from \u0026#39;react-redux\u0026#39; const Cart = () =\u0026gt; { // const cart = []  const { cartList: cart } = useSelector(state =\u0026gt; state.takeaway) // #78.1 统计选中数量  // 同一个商品选择多个的时候，需要参与数量统计  const selectedNumber = cart.reduce( (prev, current) =\u0026gt; { return prev + current.count }, 0) // #78.2 统计价格  const totalPrice = cart.reduce( // 计算价格: prev 代表上一次的结果  (prev, current) =\u0026gt; { return prev + current.price * current.count }, // 默认总价  0 ) // #78.3 判断是否可以结算  // 购物车总价是否大于等于 20  const lowestPrice = 50 const canCheckout = totalPrice \u0026gt;= lowestPrice return ( \u0026lt;div className=\u0026#34;cartContainer\u0026#34;\u0026gt; {/* 遮罩层 添加visible类名可以显示出来 */} \u0026lt;div className={classNames(\u0026#39;cartOverlay\u0026#39;)} /\u0026gt; \u0026lt;div className=\u0026#34;cart\u0026#34;\u0026gt; {/* fill 添加fill类名可以切换购物车状态*/} {/* 购物车数量 */} \u0026lt;div className={classNames( \u0026#39;icon\u0026#39;, canCheckout \u0026amp;\u0026amp; \u0026#39;fill\u0026#39;, )}\u0026gt; {true \u0026amp;\u0026amp; \u0026lt;div className=\u0026#34;cartCornerMark\u0026#34;\u0026gt;{selectedNumber}\u0026lt;/div\u0026gt;} \u0026lt;/div\u0026gt; {/* 购物车价格 */} \u0026lt;div className=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;price\u0026#34;\u0026gt; \u0026lt;span className=\u0026#34;payableAmount\u0026#34;\u0026gt; \u0026lt;span className=\u0026#34;payableAmountUnit\u0026#34;\u0026gt;¥\u0026lt;/span\u0026gt; {totalPrice.toFixed(2)} \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;span className=\u0026#34;text\u0026#34;\u0026gt;预估另需配送费 ¥5\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; {/* 结算 or 起送 */} {canCheckout ? ( \u0026lt;div className=\u0026#34;goToPreview\u0026#34;\u0026gt;去结算\u0026lt;/div\u0026gt; ) : ( \u0026lt;div className=\u0026#34;minFee\u0026#34;\u0026gt;¥{lowestPrice}起送\u0026lt;/div\u0026gt; )} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) }  针对总金额， 需要使用 .toFixed(2) 方法设置小数点后面只有 2位。 否则由于浮点数精度问题， 可能出现以下情况。\n 4. 购物车功能操作     在 /src/demos/redux-meituan/components/Count/index.js 中，\n可以看到， 购物车内项目的 数量及加减操作 都是在 上层 Cart 中传递过来的。\n4.1. 增加 state action     到 /src/demos/redux-meituan/store/modules/takeaway.js 中， 定义\n 数量增加 action  寻找商品是否存在， 存在则增加。   数量减少 action  寻找商品是否存在， 存在且 数量\u0026gt;0 时则减少。 当 数量=0 时则 将商品从购物车中删除。   清空购物车 action 导出所有 action  const takeaway = createSlice({ // 名称  name: \u0026#39;takeaway\u0026#39;, // 初始数据  initialState: { }, // actions  reducers: { // #79.2 减少物品到购物车  minusCartList: (state, action) =\u0026gt; { // 判断购物车中是否已经有该物品  const item = state.cartList.find(item =\u0026gt; item.id === action.payload.id) // 如果有物品  if (item) { // 2. 如果数量大于 1，则数量 -1  if (item.count \u0026gt; 0) { item.count -= 1 } // 如果数量等于 0，则从购物车中删除该物品  if (item.count === 0) { state.cartList = state.cartList.filter(item =\u0026gt; item.id !== action.payload.id) } } }, // #79.2 增加物品到购物车  plusCartList: (state, action) =\u0026gt; { // 判断购物车中是否已经有该物品  const item = state.cartList.find(item =\u0026gt; item.id === action.payload.id) // 如果有物品  if (item) { // 2. 如果数量大于 1，则数量 -1  item.count += 1 } }, // #79.3 清空购物车  clearCartList: (state) =\u0026gt; { state.cartList = [] } } }) // 5. 购物车操作 export const { minusCartList, plusCartList, clearCartList } = takeaway.actions 这里使用的是 Array.find() 方法。 和之前的 Array.findIndex() 差不多。\n4.2. 增加购物车功能     回到 /src/demos/redux-meituan/components/Cart/index.js 中，\nimport classNames from \u0026#39;classnames\u0026#39; import Count from \u0026#39;../Count\u0026#39; import \u0026#39;./index.scss\u0026#39; import { useSelector, useDispatch } from \u0026#39;react-redux\u0026#39; import { clearCartList, plusCartList, minusCartList } from \u0026#39;../../store/modules/takeaway\u0026#39; const Cart = () =\u0026gt; { const dispatch = useDispatch() // #79.1 显示/隐藏 购物车明细  const isShowCartDetail = selectedNumber \u0026gt; 0 // #79.2 购物车内调整商品数量  // 增加  function onCountPlus(item) { dispatch(plusCartList(item)) } // 减少  function onCoundMinus(item) { dispatch(minusCartList(item)) } // #79.3 清空购物车  function clearCart() { dispatch(clearCartList()) } return ( \u0026lt;div className=\u0026#34;cartContainer\u0026#34;\u0026gt; {/* 显示购物车 */} \u0026lt;div className={classNames( \u0026#39;cartPanel\u0026#39;, isShowCartDetail \u0026amp;\u0026amp; \u0026#39;visible\u0026#39; )}\u0026gt; {/* 购物车列表 */} \u0026lt;div className=\u0026#34;scrollArea\u0026#34;\u0026gt; {cart.map(item =\u0026gt; { return ( \u0026lt;div className=\u0026#34;cartItem\u0026#34; key={item.id}\u0026gt; \u0026lt;img className=\u0026#34;shopPic\u0026#34; src={item.picture} alt=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;div className=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;skuInfo\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;name\u0026#34;\u0026gt;{item.name}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;payableAmount\u0026#34;\u0026gt; \u0026lt;span className=\u0026#34;yuan\u0026#34;\u0026gt;¥\u0026lt;/span\u0026gt; \u0026lt;span className=\u0026#34;price\u0026#34;\u0026gt;{item.price}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;skuBtnWrapper btnGroup\u0026#34;\u0026gt; {/* 增加 onPlus 和 onMinus 方法传递 */} \u0026lt;Count count={item.count} onPlus={() =\u0026gt; onCountPlus(item)} onMinus={() =\u0026gt; onCoundMinus(item)} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) })} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) }  5. 购物车显示/隐藏管理      点击购物车时， 切换购物车状态。 只有购物车中 有商品时， 点击购物车 才会 展示显示详情。 购物车 处于展示状态 时， 同时 打开蒙层。 反之亦然。 当 点击蒙层 时， 关闭购物车和蒙层。  在 /src/demos/redux-meituan/components/Cart/index.js 中\n由于购物车状态是 私有状态， 即 不会被其他组件使用。 因此使用 useState 就行了， 不需要使用 Redux\nimport { useState } from \u0026#39;react\u0026#39; const Cart = () =\u0026gt; { // #79.1 显示/隐藏 购物车明细  const isShowCartDetail = selectedNumber \u0026gt; 0 // #79.3 清空购物车  function clearCart() { dispatch(clearCartList()) // #80. 同时关闭购物车  disableCart() } // #80. 购物车显示状态  // 购物车显示的时候， 同时出现蒙层遮盖。 反之  const [isCartVisable, setIsCartVisable] = useState(false) // #80.1 点击购物车，切换购物车状态  function toggleCart() { // 只有当购物车明细显示的时候，才可以显示购物车  isShowCartDetail \u0026amp;\u0026amp; setIsCartVisable(!isCartVisable) } // #80.2 点击蒙层，关闭购物车  function disableCart() { setIsCartVisable(false) } return ( \u0026lt;div className=\u0026#34;cartContainer\u0026#34;\u0026gt; {/* 遮罩层 添加visible类名可以显示出来 */} {/* 显示购物车的时候， 显示蒙层 */} \u0026lt;div className={classNames( \u0026#39;cartOverlay\u0026#39;, isCartVisable \u0026amp;\u0026amp; \u0026#39;visible\u0026#39; )} // #80.2 点击蒙层，关闭购物车 onClick={disableCart} /\u0026gt; \u0026lt;div className=\u0026#34;cart\u0026#34; // #80.1 切换购物车状态 onClick={toggleCart} \u0026gt; \u0026lt;/div\u0026gt; {/* 添加visible类名 div会显示出来 */} {/* 显示购物车 */} \u0026lt;div className={classNames( \u0026#39;cartPanel\u0026#39;, // #80.1 切换购物车状态  isCartVisable \u0026amp;\u0026amp; \u0026#39;visible\u0026#39; )}\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) }  ","description":"1. 添加购物车     在 /src/demos/redux-meituan/components/Cart/index.js 中可以看到 购物车 的相关配置。\n可以看到 购物车 的数据定义是 cart=[] 空数组。\nconst Cart = () =\u0026gt; { const cart = [] // 省略 ... } 在 /src/demos/redux-meituan/components/FoodsCategory/FoodItem/index.js 中\n可以看到 具体商品 配置。 从传入的 props 中解构出来了所有商品字段。\nconst Foods = ({ id, picture, name, unit, description, food_tag_list, month_saled, like_ratio_desc, price, tag, count }) =\u0026gt; { // 省略 ... } 1.1. 优化 store     因此在 /src/demos/redux-meituan/store/modules/takeaway.js 中"},{"id":44,"href":"/books/react/javascript/introduce/input-output/","title":"4. 输入输出","parent":"1. 入门简介","content":"1. 输入      prompt  // 输入 const name = prompt(\u0026#39;请输入你的名字\u0026#39;); 2. 输出      document.write console.log alert  // 输出 console.log(\u0026#39;可以输出信息到控制台: \u0026#39; + name); document.write(\u0026#39;可以输出信息到页面: \u0026#39; + name); alert(\u0026#39;可以弹出一个警告框: \u0026#39; + name); demo     input-output.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;1.5 输入输出\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 输入  const name = prompt(\u0026#39;请输入你的名字\u0026#39;); // 输出  console.log(\u0026#39;可以输出信息到控制台: \u0026#39; + name); document.write(\u0026#39;可以输出信息到页面: \u0026#39; + name); alert(\u0026#39;可以弹出一个警告框: \u0026#39; + name); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","description":"1. 输入      prompt  // 输入 const name = prompt(\u0026#39;请输入你的名字\u0026#39;); 2. 输出      document.write console.log alert  // 输出 console.log(\u0026#39;可以输出信息到控制台: \u0026#39; + name); document.write(\u0026#39;可以输出信息到页面: \u0026#39; + name); alert(\u0026#39;可以弹出一个警告框: \u0026#39; + name); demo     input-output.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;1.5 输入输出\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 输入  const name = prompt(\u0026#39;请输入你的名字\u0026#39;); // 输出  console."},{"id":45,"href":"/books/react/react/communication/props/brothers/","title":"5. 兄弟通信","parent":"1. props 通信","content":"/src/components/communication/Brothers.jsx\n兄弟组件没有关联关系， 因此需要 通过共同的父组件 进行数据的传递。 这并不是一个新东西， 而是将 父传子、子传父 组合案例。\n function Parent() { // 1. 在父节点定义状态数据  const [name, setName] = useState(\u0026#34;\u0026#34;) // 2. 在父节点定义修改状态数据的方法  function changeName(name) { setName(name) } return ( \u0026lt;div\u0026gt; {/* 3. 给 Child A 传递修改数据方法 */} \u0026lt;ChildA onChangeName={changeName} /\u0026gt; {/* 3. 给 Child B 传递数据 */} \u0026lt;ChildB name={name} /\u0026gt; \u0026lt;/div\u0026gt; ); } 在 父节点\n 使用 useState 定义状态数据 name 定义 修改函数 changeName 将修改传输传递给 ChildA, 将状态数据传递给 ChildB  function ChildA({ onChangeName }) { return ( \u0026lt;div\u0026gt; \u0026lt;b\u0026gt;Child A: \u0026lt;/b\u0026gt; {/* 4. Chila A 修改父节点数据 */} \u0026lt;button onClick={() =\u0026gt; onChangeName(\u0026#34;ChildA\u0026#34;)}\u0026gt;点我传递\u0026lt;/button\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;/div\u0026gt; ); } function ChildB(props) { return ( \u0026lt;div\u0026gt; \u0026lt;b\u0026gt;Child B: \u0026lt;/b\u0026gt; {/* 4. Child B 展示父节点数据 */} \u0026lt;span\u0026gt;接收名字: {props.name}\u0026lt;/span\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;/div\u0026gt; ); } 在 子节点\n ChildA 点击事件调用修改函数， 修改父组件的 name 值， setName 触发重新渲染。 ChildB 使用并展示 name 值。   ","description":"/src/components/communication/Brothers.jsx\n兄弟组件没有关联关系， 因此需要 通过共同的父组件 进行数据的传递。 这并不是一个新东西， 而是将 父传子、子传父 组合案例。\n function Parent() { // 1. 在父节点定义状态数据  const [name, setName] = useState(\u0026#34;\u0026#34;) // 2. 在父节点定义修改状态数据的方法  function changeName(name) { setName(name) } return ( \u0026lt;div\u0026gt; {/* 3. 给 Child A 传递修改数据方法 */} \u0026lt;ChildA onChangeName={changeName} /\u0026gt; {/* 3. 给 Child B 传递数据 */} \u0026lt;ChildB name={name} /\u0026gt; \u0026lt;/div\u0026gt; ); } 在 父节点\n 使用 useState 定义状态数据 name 定义 修改函数 changeName 将修改传输传递给 ChildA, 将状态数据传递给 ChildB  function ChildA({ onChangeName }) { return ( \u0026lt;div\u0026gt; \u0026lt;b\u0026gt;Child A: \u0026lt;/b\u0026gt; {/* 4."},{"id":46,"href":"/books/react/javascript/introduce/literal/","title":"5. 字面量","parent":"1. 入门简介","content":"一个概念， 不用深究。\n在计算机科学中， 字面量(literal) 就是 在计算机中描述的事或物\n 工资是 1000 中 1000 就是 数字字面量 名字是 zhangsan 中的 zhangsan 就是 字符串字面量 [] 表示 数组字面量 {} 表示 对象字面量 以及其他  ","description":"一个概念， 不用深究。\n在计算机科学中， 字面量(literal) 就是 在计算机中描述的事或物\n 工资是 1000 中 1000 就是 数字字面量 名字是 zhangsan 中的 zhangsan 就是 字符串字面量 [] 表示 数组字面量 {} 表示 对象字面量 以及其他  "},{"id":47,"href":"/books/react/react/jsx/style/","title":"5. 样式的使用","parent":"1. jsx 基础用法","content":"源代码在 /src/components/styles/RootStyle.jsx\n1. 行内样式     在标签内使用使用 style={{key:v1, k2:v2}} 实现样式管理。\n\u0026lt;p style={{ color: \u0026#34;red\u0026#34;, fontSize: \u0026#34;18px\u0026#34; }}\u0026gt;1.1. 行内样式\u0026lt;/p\u0026gt;  外层 {}: 开始 React 语法。 {k1:v1, k2:v2}: 是一个 Object 对象。 key 使用 驼峰 规则: font-size =\u0026gt; fontSize  向上面直接写在行内的方式， 管理起来并不清晰。 因此可以将 样式 赋值给一个 变量 保存。\nexport default function RootStyle() { return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p style={style}\u0026gt;1.2. 行内样式2\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } const style = { color: \u0026#34;blue\u0026#34;, fontSize: \u0026#34;18px\u0026#34; } 2. css 文件     样式当然可以保存到 css 文件中\n/* demo.css */ .demo { color: green; font-size: 18px; font-style: italic; } 在 JSX 文件中使用 import 导入\nimport \u0026#34;./demo.css\u0026#34; export default function RootStyle() { return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p className=\u0026#34;demo\u0026#34;\u0026gt;2. Import CSS\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } 注意： 这里是 React 规则 的 className， 驼峰 命令\n","description":"源代码在 /src/components/styles/RootStyle.jsx\n1. 行内样式     在标签内使用使用 style={{key:v1, k2:v2}} 实现样式管理。\n\u0026lt;p style={{ color: \u0026#34;red\u0026#34;, fontSize: \u0026#34;18px\u0026#34; }}\u0026gt;1.1. 行内样式\u0026lt;/p\u0026gt;  外层 {}: 开始 React 语法。 {k1:v1, k2:v2}: 是一个 Object 对象。 key 使用 驼峰 规则: font-size =\u0026gt; fontSize  向上面直接写在行内的方式， 管理起来并不清晰。 因此可以将 样式 赋值给一个 变量 保存。\nexport default function RootStyle() { return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p style={style}\u0026gt;1.2. 行内样式2\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } const style = { color: \u0026#34;blue\u0026#34;, fontSize: \u0026#34;18px\u0026#34; } 2."},{"id":48,"href":"/books/react/react/communication/","title":"5. 组件通信","parent":"3. React","content":"组件通信 就是 组件之间的数据传递。 根据组件嵌套的关系不同， 有不同的通信方法。\n ","description":"组件通信 就是 组件之间的数据传递。 根据组件嵌套的关系不同， 有不同的通信方法。\n "},{"id":49,"href":"/books/react/react/router/default-router/","title":"5. 默认路由","parent":"6. React-Router","content":"在 router 配置的时候， path 的值使用 * 即可配置默认路径。 当用户访问路径无法匹配时返回。\n通常， 默认路径可以用于 优化 404 页面， 提高用户体验。\n 在 /src/components/router/RootRouter.jsx 中,\nconst router = createBrowserRouter([ { // 使用 * 匹配所有路由  path: \u0026#34;*\u0026#34;, element: \u0026lt;NotFound /\u0026gt; } ]) ","description":"在 router 配置的时候， path 的值使用 * 即可配置默认路径。 当用户访问路径无法匹配时返回。\n通常， 默认路径可以用于 优化 404 页面， 提高用户体验。\n 在 /src/components/router/RootRouter.jsx 中,\nconst router = createBrowserRouter([ { // 使用 * 匹配所有路由  path: \u0026#34;*\u0026#34;, element: \u0026lt;NotFound /\u0026gt; } ]) "},{"id":50,"href":"/books/react/react/router/","title":"6. React-Router","parent":"3. React","content":"","description":""},{"id":51,"href":"/books/react/react/router/router-modes/","title":"6. 路由模式","parent":"6. React-Router","content":"   路由模式 URL表现 底层原理 是否需要后端支持     history url/login history对象+pushState事件 需要   hash url/#/login 监听 hashChange 事件 不需要   memory url ?? ??    1. Hash 模式     使用 createHashRouter 创建 Hash 模式。 path 上有 # 。 单页面模式\nimport { createHashRouter } from \u0026#34;react-router-dom\u0026#34;; const router = createHashRouter([ { path: \u0026#34;/login\u0026#34;, element: \u0026lt;Login /\u0026gt; } ]) 2. Memory 模式     使用 createMemoryRouter 模式。 path 路径 不会 在 URL 上体现出来。 单页面模式\nimport { createMemoryRouter } from \u0026#34;react-router-dom\u0026#34;; const router = createMemoryRouter([ { path: \u0026#34;/login\u0026#34;, element: \u0026lt;Login /\u0026gt; } ]) ","description":"路由模式 URL表现 底层原理 是否需要后端支持     history url/login history对象+pushState事件 需要   hash url/#/login 监听 hashChange 事件 不需要   memory url ?? ??    1. Hash 模式     使用 createHashRouter 创建 Hash 模式。 path 上有 # 。 单页面模式\nimport { createHashRouter } from \u0026#34;react-router-dom\u0026#34;; const router = createHashRouter([ { path: \u0026#34;/login\u0026#34;, element: \u0026lt;Login /\u0026gt; } ]) 2. Memory 模式     使用 createMemoryRouter 模式。 path 路径 不会 在 URL 上体现出来。 单页面模式"},{"id":52,"href":"/books/react/library/","title":"98. 三方库","parent":"","content":"","description":""},{"id":53,"href":"/books/react/demos/","title":"99. 项目案例","parent":"","content":"","description":""},{"id":54,"href":"/books/react/library/chassnames/","title":"classnames","parent":"98. 三方库","content":"    项目地址: https://github.com/JedWatson/classnames\n安装方式     npm install classnames Demo     import classNames from \u0026#39;classnames\u0026#39;; classNames(\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;); // =\u0026gt; \u0026#39;foo bar\u0026#39; classNames(\u0026#39;foo\u0026#39;, { bar: true }); // =\u0026gt; \u0026#39;foo bar\u0026#39; classNames({ \u0026#39;foo-bar\u0026#39;: true }); // =\u0026gt; \u0026#39;foo-bar\u0026#39; classNames({ \u0026#39;foo-bar\u0026#39;: false }); // =\u0026gt; \u0026#39;\u0026#39; classNames({ foo: true }, { bar: true }); // =\u0026gt; \u0026#39;foo bar\u0026#39; classNames({ foo: true, bar: true }); // =\u0026gt; \u0026#39;foo bar\u0026#39;  // lots of arguments of various types classNames(\u0026#39;foo\u0026#39;, { bar: true, duck: false }, \u0026#39;baz\u0026#39;, { quux: true }); // =\u0026gt; \u0026#39;foo bar baz quux\u0026#39;  // other falsy values are just ignored classNames(null, false, \u0026#39;bar\u0026#39;, undefined, 0, { baz: null }, \u0026#39;\u0026#39;); // =\u0026gt; \u0026#39;bar\u0026#39; ","description":"    项目地址: https://github.com/JedWatson/classnames\n安装方式     npm install classnames Demo     import classNames from \u0026#39;classnames\u0026#39;; classNames(\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;); // =\u0026gt; \u0026#39;foo bar\u0026#39; classNames(\u0026#39;foo\u0026#39;, { bar: true }); // =\u0026gt; \u0026#39;foo bar\u0026#39; classNames({ \u0026#39;foo-bar\u0026#39;: true }); // =\u0026gt; \u0026#39;foo-bar\u0026#39; classNames({ \u0026#39;foo-bar\u0026#39;: false }); // =\u0026gt; \u0026#39;\u0026#39; classNames({ foo: true }, { bar: true }); // =\u0026gt; \u0026#39;foo bar\u0026#39; classNames({ foo: true, bar: true }); // =\u0026gt; \u0026#39;foo bar\u0026#39;  // lots of arguments of various types classNames(\u0026#39;foo\u0026#39;, { bar: true, duck: false }, \u0026#39;baz\u0026#39;, { quux: true }); // =\u0026gt; \u0026#39;foo bar baz quux\u0026#39;  // other falsy values are just ignored classNames(null, false, \u0026#39;bar\u0026#39;, undefined, 0, { baz: null }, \u0026#39;\u0026#39;); // =\u0026gt; \u0026#39;bar\u0026#39; "},{"id":55,"href":"/books/react/library/dayjs/","title":"dayjs 时间处理","parent":"98. 三方库","content":"dayjs 是一款 nodejs 的 时间 处理库。 与 js 原生时间库 Date 相比， 更好用。\n 官网: https://day.js.org/docs/en/installation/typescript 中文网: https://dayjs.fenxianglu.cn/category/#node-js  1. install\nnpm install dayjs 2. Usage\nimport dayjs from \u0026#39;dayjs\u0026#39; // https://day.js.org/docs/en/parse/string-format dayjs().format(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;) // 2023-03-18 19:33:24 更多直接查看官网。\n","description":"dayjs 是一款 nodejs 的 时间 处理库。 与 js 原生时间库 Date 相比， 更好用。\n 官网: https://day.js.org/docs/en/installation/typescript 中文网: https://dayjs.fenxianglu.cn/category/#node-js  1. install\nnpm install dayjs 2. Usage\nimport dayjs from \u0026#39;dayjs\u0026#39; // https://day.js.org/docs/en/parse/string-format dayjs().format(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;) // 2023-03-18 19:33:24 更多直接查看官网。"},{"id":56,"href":"/books/react/javascript/","title":"JavaScript","parent":"","content":"","description":""},{"id":57,"href":"/books/react/library/lodash/","title":"lodash 工具库","parent":"98. 三方库","content":"","description":""},{"id":58,"href":"/books/react/library/redux/","title":"redux","parent":"98. 三方库","content":"Redux 是 React 中常用的 技术状态管理工具， 可以独立于 React 运行。\n ","description":"Redux 是 React 中常用的 技术状态管理工具， 可以独立于 React 运行。\n "},{"id":59,"href":"/books/react/react/communication/redux/","title":"redux","parent":"5. 组件通信","content":"到 三方库/redux 中查看\n","description":"到 三方库/redux 中查看"},{"id":60,"href":"/books/react/tags/","title":"Tags","parent":"","content":"","description":""},{"id":61,"href":"/books/react/typescript/","title":"TypeScript","parent":"","content":"","description":""},{"id":62,"href":"/books/react/react/hooks/use-context/","title":"useContext 数据传递","parent":"4. Hooks","content":"","description":""},{"id":63,"href":"/books/react/react/hooks/use-effect/","title":"useEffect 生命周期管理","parent":"4. Hooks","content":" Lifecycle of Reactive Effects 深入详解React生命周期  useEffect 是一个 React Hook 函数， 用于在 React 组件中创建 不是由事件引起 而是 由渲染本身引起的操作， 比如 ajax 请求， 更改 DOM 等等\n 说明： 上面的组件中没有发生任何的 用户事件， 组件渲染完毕之后 就向服务器请求数据， 整个过程数据 只由渲染引起的操作。\n触发时机包括：\n 加载 重新渲染 卸载   ","description":" Lifecycle of Reactive Effects 深入详解React生命周期  useEffect 是一个 React Hook 函数， 用于在 React 组件中创建 不是由事件引起 而是 由渲染本身引起的操作， 比如 ajax 请求， 更改 DOM 等等\n 说明： 上面的组件中没有发生任何的 用户事件， 组件渲染完毕之后 就向服务器请求数据， 整个过程数据 只由渲染引起的操作。\n触发时机包括：\n 加载 重新渲染 卸载   "},{"id":64,"href":"/books/react/react/hooks/use-immer/","title":"useImmer 状态数据","parent":"4. Hooks","content":"useImmer 是 useState 的 加强版。\n https://github.com/immerjs/use-immer  npm install immer use-immer ","description":"useImmer 是 useState 的 加强版。\n https://github.com/immerjs/use-immer  npm install immer use-immer "},{"id":65,"href":"/books/react/react/hooks/use-ref/","title":"useRef 获取 DOM","parent":"4. Hooks","content":"在 React 中 获取/操作 DOM， 需要使用 useRef 钩子函数\nimport { useRef } from \u0026#39;react\u0026#39;; export default function UseRef() { // 1. 使用 useRef 生成 ref 对象  const inputRef = useRef(null); function showDOM() { // 使用 console.log 查看 ref 对象  console.log(inputRef.current); // 使用 console.dir 展开 ref 对象  console.dir(inputRef.current); // 焦点锁定  inputRef.current.focus() } return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;3. useRef 获取 DOM\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;点击 Button 在控制台查看输出\u0026lt;/p\u0026gt; {/* 将 ref 绑定到标签属性上 */} \u0026lt;input type=\u0026#34;text\u0026#34; ref={inputRef} /\u0026gt; {/* 3. 在渲染完毕时， DOM可用 使用箭头函数调用渲染完毕的 DOM 元素。 */} \u0026lt;button onClick={showDOM}\u0026gt;获取DOM值\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } 1. 绑定对象      使用 useRef() 定义一个 ref  useRef(null) 中的 null 表示， 在绑定之前的对象是 null。\nconst xxxRef = useRef(null) 将 xxxRef 放到 被操作对象 的属性中  \u0026lt;input type=\u0026#34;text\u0026#34; ref={xxxRef} /\u0026gt; 2. 获取 DOM     在 DOM 可用时， 使用 xxxRef.current 可以拿到 DOM 对象。 随后在根据需求操作 DOM 即可\nconsole.log(xxxRef.current) DOM 可用: 页面渲染完毕后， 使用 onClick 事件触发 函数 延迟获取。\n例如， 焦点锁定\ninputRef.current.focus()  ","description":"在 React 中 获取/操作 DOM， 需要使用 useRef 钩子函数\nimport { useRef } from \u0026#39;react\u0026#39;; export default function UseRef() { // 1. 使用 useRef 生成 ref 对象  const inputRef = useRef(null); function showDOM() { // 使用 console.log 查看 ref 对象  console.log(inputRef.current); // 使用 console.dir 展开 ref 对象  console.dir(inputRef.current); // 焦点锁定  inputRef.current.focus() } return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;3. useRef 获取 DOM\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;点击 Button 在控制台查看输出\u0026lt;/p\u0026gt; {/* 将 ref 绑定到标签属性上 */} \u0026lt;input type=\u0026#34;text\u0026#34; ref={inputRef} /\u0026gt; {/* 3."},{"id":66,"href":"/books/react/react/hooks/use-state/","title":"useState 状态数据","parent":"4. Hooks","content":"React 讲究的是 数据驱动页面。 意思是 当状态数据被修改了，页面内容也会被重新渲染更新。\n如果要上述这个效果， 就需要用到 useState 这个 钩子(Hook)\n 使用 useState 时， 需要先导入。  import { useState } from \u0026#34;react\u0026#34; 使用 const/let 进行结构赋值。 count 和 setCount 是一对 3. useState 创建 状态， 并定义变量的默认值。  count 被称为状态变量，不应该被直接修改， 推荐使用 const 初始化 setCount 是一个函数, 修改 count 的函数。 通过 setCount 修改 count 的值，会触发相关组件的重新渲染。    // const: count 不能被修改 const [count, setCount] = useState(0) // let: count 可以被修改 let [count, setCount] = useState(0) 注意: 使用 let 定义时， count 非只读， 可以直接修改。 但不会触发组件的重新渲染。\n1. 修改简单类型     Demo 在 /src/components/hooks/UseStateSimpleType.jsx\nimport { useState } from \u0026#34;react\u0026#34; export default function UseStateSimpleType() { const [count, setCount] = useState(0) const handler = () =\u0026gt; { const n = count + 1 setCount(n) // 使用 setCount, 修改 count 的值，会触发组件的重新渲染。  } return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;简单类型， number, string\u0026lt;/h3\u0026gt; \u0026lt;button onClick={handler}\u0026gt;Handler1 重新渲染: {count - 1}+1 ={count}\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } 2. 修改对象类型     Demo 在 /src/components/hooks/UseStateObject.jsx\nimport { useState } from \u0026#34;react\u0026#34; export default function UseStateObject() { const [user, setUser] = useState({ \u0026#34;name\u0026#34;: \u0026#34;zhangfei\u0026#34;, \u0026#34;age\u0026#34;: 18, \u0026#34;address\u0026#34;: \u0026#34;beijing\u0026#34; }) // 使用 setCount, 修改 count 的值，会触发组件的重新渲染。  const handler = () =\u0026gt; { setUser( // 注意：setUser 传递时第一个对象， 因此需要使用 {} 包裹。  { ...user, // 解构语法，展开 user 所有属性  age: user.age + 1 // 修改 age 属性  } ) } return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;修改对象某个属性\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;name: {user.name}, age: {user.age}, address: {user.address}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handler}\u0026gt;Handler1 解构语法: \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } 注意： user 是通过 const 定义的\n 其 本身不能直接被修改， 即 user={name:x, age:x, address:x}。 但是其 字段可以被修改， 即 user.age=100  import { useState } from \u0026#34;react\u0026#34; export default function UseStateObject() { const [user, setUser] = useState({ \u0026#34;name\u0026#34;: \u0026#34;zhangfei\u0026#34;, \u0026#34;age\u0026#34;: 18, \u0026#34;address\u0026#34;: \u0026#34;beijing\u0026#34; }) const handler2 = () =\u0026gt; { user.age = user.age + 1 // setUser(user) // 不会触发重新渲染  setUser({ ...user }) } } 另外， 在使用 setUser 的时候， 可以 直接 传入一个 全新 对象\nconst guanyu = { \u0026#34;name\u0026#34;: \u0026#34;guanyu\u0026#34;, \u0026#34;age\u0026#34;: 22, \u0026#34;address\u0026#34;: \u0026#34;tianjing\u0026#34; } const handlerGuanyu = () =\u0026gt; { setUser(guanyu) } 但是 user 本身不能直接传入， 而需要通过 解构 创建一个 全新 对象\n// setUser 传入 user 不会渲染， 数据会被修改， 但页面不会被渲染。 const handler2 = () =\u0026gt; { user.age = user.age + 1 console.log(user); // age 已经修改  setUser(user) // 不会触发重新渲染 } // setUser 通过解构创建一个新对象, 页面会被渲染。 const handler2 = () =\u0026gt; { user.age = user.age + 1 console.log(user); setUser({ // 通过解构创建一个新对象  ...user }) } 使用 setUser(user) 时， 由于传入的是 user ， 虽然其字段发生变化， 但其本身的 指针地址 没有变化， 因此 React 认为没有变化， 不会渲染页面。\n3. 嵌套对象 与 数组     嵌套对象、 数组 与 对象 一样， 都是引用类型。\n因此，在更新渲染时， 都需要传入 新值。 换句话说， 也需要使用 解构语法。\n参考: https://zh-hans.react.dev/reference/react/useState#updating-objects-and-arrays-in-state\n其他      useState - React zhcn  ","description":"React 讲究的是 数据驱动页面。 意思是 当状态数据被修改了，页面内容也会被重新渲染更新。\n如果要上述这个效果， 就需要用到 useState 这个 钩子(Hook)\n 使用 useState 时， 需要先导入。  import { useState } from \u0026#34;react\u0026#34; 使用 const/let 进行结构赋值。 count 和 setCount 是一对 3. useState 创建 状态， 并定义变量的默认值。  count 被称为状态变量，不应该被直接修改， 推荐使用 const 初始化 setCount 是一个函数, 修改 count 的函数。 通过 setCount 修改 count 的值，会触发相关组件的重新渲染。    // const: count 不能被修改 const [count, setCount] = useState(0) // let: count 可以被修改 let [count, setCount] = useState(0) 注意: 使用 let 定义时， count 非只读， 可以直接修改。 但不会触发组件的重新渲染。"},{"id":67,"href":"/books/react/library/uuid/","title":"uuid","parent":"98. 三方库","content":"uuid 生成 UUID 随机数。\n https://github.com/uuidjs/uuid https://www.npmjs.com/package/uuid 1. Install  npm install uuid 2. Create a UUID (ES6 module syntax)\nimport { v4 as uuidv4 } from \u0026#39;uuid\u0026#39;; uuidv4(); // ⇨ \u0026#39;9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d\u0026#39; \u0026hellip; or using CommonJS syntax:\nconst { v4: uuidv4 } = require(\u0026#39;uuid\u0026#39;); uuidv4(); // ⇨ \u0026#39;1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed\u0026#39; const { v4: uuidv4 } = require(\u0026#39;uuid\u0026#39;); uuidv4(); // ⇨ \u0026#39;1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed\u0026#39; ","description":"uuid 生成 UUID 随机数。\n https://github.com/uuidjs/uuid https://www.npmjs.com/package/uuid 1. Install  npm install uuid 2. Create a UUID (ES6 module syntax)\nimport { v4 as uuidv4 } from \u0026#39;uuid\u0026#39;; uuidv4(); // ⇨ \u0026#39;9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d\u0026#39; \u0026hellip; or using CommonJS syntax:\nconst { v4: uuidv4 } = require(\u0026#39;uuid\u0026#39;); uuidv4(); // ⇨ \u0026#39;1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed\u0026#39; const { v4: uuidv4 } = require(\u0026#39;uuid\u0026#39;); uuidv4(); // ⇨ \u0026#39;1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed\u0026#39; "},{"id":68,"href":"/books/react/react/hooks/customize-hook/","title":"自定义 Hook","parent":"4. Hooks","content":"简单的说 自定义 Hook 就是创建一个以 use开头的函数。 往复杂了说还需要考虑各种数据状态、冲突。\n自定义 Hook 通用思路      以 use 开头的函数 函数内部可以调用其他 Hook 通常返回一个数组或对象（包含状态数据和控制方法）， 以便在组件中使用 其他组件则可以直接调用该函数，而不需要关心内部实现  代码在 /src/components/hooks/CustomizeHook.jsx\n 1. 原始对象， 直接管理     export default function CustomizeHook() { // 使用 useState 直接管理  const [isShow, setIsShow] = useState(true) const toggle = () =\u0026gt; { setIsShow(!isShow) } return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;5. CustomizeHook\u0026lt;/h3\u0026gt; \u0026lt;button onClick={toggle}\u0026gt;Toggle: 隐藏或显示\u0026lt;/button\u0026gt; {isShow \u0026amp;\u0026amp; \u0026lt;p\u0026gt;this is a span\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ) } 2. 自定义 useToggle Hook 封装     function useToggle() { // 定义状态  const [isShow, setIsShow] = useState(true) // 定义状态的修改方法  const toggle = () =\u0026gt; { setIsShow(!isShow) } // 通过对象返回  return { isShow, // 状态  toggle // 修改方法  } } export default function CustomizeHook() { // 通过解构方法获取状态数据与修改方法  const { isShow, toggle } = useToggle() return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;5. CustomizeHook\u0026lt;/h3\u0026gt; \u0026lt;button onClick={toggle}\u0026gt;Toggle: 隐藏或显示\u0026lt;/button\u0026gt; {isShow \u0026amp;\u0026amp; \u0026lt;p\u0026gt;this is a span\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ) } 也可以使用 数组 返回状态数据和修改方法\nfunction useToggle() { // ...  // 通过数组返回  return [ isShow, // 状态  toggle // 修改方法  ] } export default function CustomizeHook() { // 通过数组接收状态数据与修改方法  const [ isShow, toggle ] = useToggle() // ... } ","description":"简单的说 自定义 Hook 就是创建一个以 use开头的函数。 往复杂了说还需要考虑各种数据状态、冲突。\n自定义 Hook 通用思路      以 use 开头的函数 函数内部可以调用其他 Hook 通常返回一个数组或对象（包含状态数据和控制方法）， 以便在组件中使用 其他组件则可以直接调用该函数，而不需要关心内部实现  代码在 /src/components/hooks/CustomizeHook.jsx\n 1. 原始对象， 直接管理     export default function CustomizeHook() { // 使用 useState 直接管理  const [isShow, setIsShow] = useState(true) const toggle = () =\u0026gt; { setIsShow(!isShow) } return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;5. CustomizeHook\u0026lt;/h3\u0026gt; \u0026lt;button onClick={toggle}\u0026gt;Toggle: 隐藏或显示\u0026lt;/button\u0026gt; {isShow \u0026amp;\u0026amp; \u0026lt;p\u0026gt;this is a span\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ) } 2."}]