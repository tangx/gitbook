<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>React18</title><link>https://typonotes.com/books/react/</link><description>Recent content on React18</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://typonotes.com/books/react/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://typonotes.com/books/react/SUMMARY/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/SUMMARY/</guid><description>React 18 学习笔记 初始化项目</description></item><item><title>1. jsx 的介绍</title><link>https://typonotes.com/books/react/react/jsx/introduce/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/jsx/introduce/</guid><description>之前在 /src/App.js 中说到了 className 是 react 语法。 更准确的说是 JSX 语法。
这是一个带有变量的例子
// 定义 变量 const message = &amp;#34;this is a message&amp;#34; function App() { // return 中的内容是 jsx 语法 return ( &amp;lt;div className=&amp;#34;App&amp;#34;&amp;gt; // className 不是 HTML 语法 {message} // 使用变量 &amp;lt;/div&amp;gt; ); } 1. 什么是 jsx jsx 是 js 的一种扩展语法， 继承了 js 和 xml 的优点。
可以使用 HTML 的声明式模版。 可以使用 js 的可编程能力。 由于 jsx 本身不是标准语法。 因此需要使用 Babel 进行编译后， 才能在 浏览器 上运行。 TypeScript同理， 也是需要编译成 js 后才能在浏览器上运行。</description></item><item><title>1. onClick 点击事件</title><link>https://typonotes.com/books/react/react/events/on-click/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/events/on-click/</guid><description>事件名称统一为 onXXXX Hanlder 函数支持多种方式定义， 变量形式 与 函数形式 // 不接受参数 // 变量形式 const handler1 = () =&amp;gt; { console.log(count); count = count + 1 } // 接收事件 // 函数形式 function handler2(event) { console.log(event) // count = count + 2 } 这里是是 onClick 点击事件。
1. 不接受参数 这种最简单， 只需要在 标签 中的 属性 中， 使用 onClick 事件时 指定 调用 handler 函数 即可。
&amp;lt;button onClick={handler1}&amp;gt;button +1&amp;lt;/button&amp;gt; 如上， 是在 button 中接收了的 onClick 事件。 注意</description></item><item><title>1. Redux计数器（纯网页版）</title><link>https://typonotes.com/books/react/library/redux/counter-demo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/library/redux/counter-demo/</guid><description>在不使用 React 框架的情况下。 仅使用 Redux 实现一个计数器功能。
使用步骤 定义一个 reducer 函数。 （根据当前想要做的修改返回一个心的状态） 使用 createStore 方法传入 reducer， 生成一个 store 实例对象 使用 store 实例的 subscribe 方法 订阅数据变化。 （数据一旦变化， 可以得到通知） 使用 store 实例的 dispatch 方法提交 action 对象 触发数据变化。 （告诉 reducer 所需要执行的操作） 使用 store 实例 getState 方法 获取最新的状态数据， 并更新到试图中。 注意： Redux 不会主动更新视图， 需要主动调用 document DOM 绑定数据。
示例代码 本案例中使用 redux@4.2.1， 最新版本 5.0.x API 有新变化， 页面代码不兼容。 （2024-02-18）</description></item><item><title>1. 基础语法</title><link>https://typonotes.com/books/react/react/hooks/use-effect/basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/use-effect/basic/</guid><description>1. 语法规则 import { useEffect } from &amp;#39;react&amp;#39; useEffect(()=&amp;gt;{}, []) useEffect 支持两个参数
参数一是 函数 ()=&amp;gt;{}。 可以称其为 副作用函数， 在函数内部可以放置要执行的操作。 如果函数由返回值， 则表示在 组件卸载时执行， 这个后面讨论。 参数二是 数组 []（可选）， 在数组里放置 依赖项。 不同依赖项数据量导致渲染行为不一致， 这个后面讨论。 在 /src/components/hooks/UseEffectBasic.jsx 中。
import { useEffect, useState } from &amp;#34;react&amp;#34; const URL = &amp;#39;http://geek.itheima.net/v1_0/channels&amp;#39; export default function UseEffectBasic() { const [channels, setChannels] = useState([]) // 定义副作用函数， 只执行一次 useEffect(() =&amp;gt; { console.</description></item><item><title>1. 安装</title><link>https://typonotes.com/books/react/react/router/setup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/router/setup/</guid><description>ReactRouter 为 React 提供路由管理的组件。
安装 $ npm install react-router-dom 在 package.json 中， 可以看到版本为 6.22.1
&amp;#34;dependencies&amp;#34;: { &amp;#34;react-router-dom&amp;#34;: &amp;#34;^6.22.1&amp;#34;, }, 使用 在 /src/components/router/RootRouter.jsx 中
使用 createBrowserRouter 创建 路由列表 router。 在组件中， 使用 RouterProvider 使用路由页面。 注意： 当前路由中使用的是 element 字段， 而非 componenet。
之后就可以访问 http://localhost:3000/page1 或者 http://localhost:3000/page2 切换页面了。
import { createBrowserRouter, RouterProvider } from &amp;#34;react-router-dom&amp;#34;; // 创建路由 const router = createBrowserRouter([ { path: &amp;#34;/page1&amp;#34;, element: &amp;lt;div&amp;gt;Page1&amp;lt;/div&amp;gt;, }, { path: &amp;#34;/page2&amp;#34;, element: &amp;lt;div&amp;gt;Page2&amp;lt;/div&amp;gt; } ]) export default function RootRouter() { return ( &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;8.</description></item><item><title>1. 支持的数据类型</title><link>https://typonotes.com/books/react/react/communication/props/props/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/props/props/</guid><description>/src/components/communication/Parent2Children.jsx
props 可以传递任意数据 数字, 字符串, 布尔值 数组, 对象 函数, JSX function Parent() { return ( &amp;lt;div&amp;gt; &amp;lt;Child name={&amp;#34;Wangwu&amp;#34;} age={20} isTrue={true} list={[1, 2, 3]} obj={{ name: &amp;#34;Zhaoliu&amp;#34; }} func={() =&amp;gt; { console.log(&amp;#34;Hello&amp;#34;) }} child={&amp;lt;span&amp;gt;this is a span&amp;lt;/span&amp;gt;} /&amp;gt; &amp;lt;/div&amp;gt; ); } props 是 只读对象: 子组件 只能读取 props 中的数据， 不能直接修改。 如果要修改， 只能在父组件中 由父组件修改。 参考 子传父通信 3. 兄弟通信 状态提升</description></item><item><title>1. 环境准备</title><link>https://typonotes.com/books/react/demos/redux-meituan/setup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/demos/redux-meituan/setup/</guid><description>1. 解压项目 解压 /src/demos/redux-meituan.tgz
2. mock 数据 创建 /src/demos/redux-meituan/mock 目录， 创建mock 数据。
$ npm install json-server 启动服务
$ json-server --watch data.json --port 3101 3. 对外提供数据 对外提供数据
const takeawayURL = &amp;#39;http://localhost:3101/takeaway&amp;#39; export { takeawayURL }</description></item><item><title>1. 组件式开发</title><link>https://typonotes.com/books/react/react/components/what-is-component/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/components/what-is-component/</guid><description>1. 组件是什么 组件是用户界面的一部分， 他可以有自己的的逻辑和外观。
组件之间 可以互相嵌套 组件 可以多次重复使用 组件化开发， 可以让开发者像搭积木一样构建一个庞大而完整的新系统。
2. 如何定义组件</description></item><item><title>1. 配置开发环境</title><link>https://typonotes.com/books/react/setup/install/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/setup/install/</guid><description>安装 NodeJS 安装 NodeJS wget -c https://nodejs.org/dist/v20.11.0/node-v20.11.0-darwin-arm64.tar.gz tar xf node-v20.11.0-darwin-arm64.tar.gz mv node-v20.11.0-darwin-arm64 /usr/local/nodejs 配置环境变量 export NODE_ROOT=/usr/local/nodejs export PATH=$NODE_ROOT/bin:$PATH alias cnpm=&amp;#39;npm --registry=https://registry.npmmirror.com &amp;#39; 配置国内源 yarn config set registry https://registry.npmmirror.com npm config set registry https://registry.npmmirror.com Chrome 插件 React Developer Tools</description></item><item><title>2. context 跨层级通信</title><link>https://typonotes.com/books/react/react/communication/context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/context/</guid><description>和 Golang 的 context 差不多。 在 context.Provider 下的所有节点都可以通过关键字 useContext 获取数据。
解决了 props 中不相关的组件之间需要传递数据时 状态提升 的复杂操作。
使用 createContext 方法创建一个 上下文对象 Ctx 在顶层组件 (如图, App) 中使用 Ctx.Provider 组件提供数据。 在下层组件 (如图, B) 中使用 useContext 钩子获取消费数据。 在 /src/components/communication/UseContext.jsx 中， 定义三个组件形成嵌套关系
UseContext, 对应上图中的 App A 对应 A B 对应 B 1. 定义 MsgContext 在文件级别， 使用 createContext 创建 Context 对象
注意: 经测试， 创建时提供的 default value 并不起作用。 实际 可用数据 还是需要在 &amp;lt;MsgContext.</description></item><item><title>2. jsx 的常用用法</title><link>https://typonotes.com/books/react/react/jsx/basic-syntax/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/jsx/basic-syntax/</guid><description>在 jsx 中， 可以通过 大括号语法{} 识别 JavaScript 中的表达式。
常见的包括
常量调用 变量调用 函数调用 方法调用 使用 js 对象 等等 1. 常量调用 在 BasicSyntax 内部使用 {'this is const string'}
// BasicSyntax 基础语法组建 function BasicSyntax() { return ( &amp;lt;div className=&amp;#34;BasicSyntax&amp;#34;&amp;gt; &amp;lt;h3&amp;gt;1. 常量调用&amp;lt;/h3&amp;gt; &amp;lt;p&amp;gt;{&amp;#39;this is const string&amp;#39;}&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; ); } 2. 变量调用 在 BasicSyntax 组建外部定义 变量 val。 在内部使用 {val} 调用 // BasicSyntax 基础语法组建 function BasicSyntax() { return ( &amp;lt;div className=&amp;#34;BasicSyntax&amp;#34;&amp;gt; &amp;lt;h3&amp;gt;2.</description></item><item><title>2. onChange 数据双向绑定</title><link>https://typonotes.com/books/react/react/events/on-change/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/events/on-change/</guid><description>在 /src/components/event/EventOnChange.js 中实现了 数据的双向绑定。 即
使用 useState 管理变量 username 的状态 使用 {username} 实现数据 从 state 到 UI 的单向绑定。 使用 onChange 捕捉控件的变化事件。 随后通过 箭头函数 获取 当前事件目标的值(e.target.value) 并通过 setUsername 保存数据， 从而数据 从 UI 到 state 的单向绑定。 当数据更新到 state 后， React 又刷新了页面。 // Path: src/components/event/EventOnClick.js import { useState } from &amp;#34;react&amp;#34; export default function EventOnChange() { const [username, setUsername] = useState(&amp;#34;zhangsan&amp;#34;) return ( &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;OnChange 事件实现数据双向绑定&amp;lt;/h2&amp;gt; {/* 1. {username} 实现数据从 state 到 UI 的单向绑定 2.</description></item><item><title>2. Redux 与 React - 环境准备</title><link>https://typonotes.com/books/react/library/redux/redux-react-setup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/library/redux/redux-react-setup/</guid><description>官方要求安装两个其他插件
Redux Toolkit (RTK): 官方推荐编写 Redux 逻辑的方式， 是一套工具的集合， 可以 简化书写方式
简化 store 的配置 内置 immer 支持可变状态的修改 内置 thunk 更好的支持 异步创建 react-redux: 用于 链接 Redux 和 React 的中间件
1. 插件安装 $ npm install @reduxjs/toolkit react-redux 安装后可以在 package.json 中查看版本。
&amp;#34;dependencies&amp;#34;: { &amp;#34;@reduxjs/toolkit&amp;#34;: &amp;#34;^2.2.1&amp;#34;, &amp;#34;react-redux&amp;#34;: &amp;#34;^9.1.0&amp;#34;, }, 比 教学视频 的版本高。 (2024-02-20)
&amp;#34;dependencies&amp;#34;: { &amp;#34;@reduxjs/toolkit&amp;#34;: &amp;#34;^1.9.3&amp;#34;, &amp;#34;react-redux&amp;#34;: &amp;#34;^8.0.5&amp;#34;, }, 2. store 目录结构设计 创建 /src/store 根目录，</description></item><item><title>2. 不同依赖项行为</title><link>https://typonotes.com/books/react/react/hooks/use-effect/dependencies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/use-effect/dependencies/</guid><description>2. 不同依赖项的不同渲染行为 不同状态 的数组影响第一参数函数的执行。 1. 数据被省略时： 在组件加载时执行， 且在任意渲染时执行。 2. 数组为空时： 仅在组件加载时执行 （仅执行一次）。 3. 数组中有依赖项时： 在组件加载时执行， 且在 仅在依赖项变化时触发的渲染时执行
在 /src/components/hooks/UseEffectDependencies.jsx 中
import { useState, useEffect } from &amp;#34;react&amp;#34;; export default function UseEffectDependencies() { const [count, setCount] = useState(0) const [trigger, setTrigger] = useState(0) // (1) none dependency // 组件加载时，执行一次 // 无依赖项，每次组件更新时，都会执行 useEffect(() =&amp;gt; { console.log(&amp;#39;NONE: useEffect called&amp;#39;); }); // (2) empty dependency // 仅在组件加载时执行一次 useEffect(() =&amp;gt; { console.</description></item><item><title>2. 使用 redux 管理数据</title><link>https://typonotes.com/books/react/demos/redux-meituan/initial-store/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/demos/redux-meituan/initial-store/</guid><description>1. 创建 takeaway slice 在 /src/demos/redux-meituan/store/modules/takeaway.js
使用 @reduxjs/toolkit 提供的 createSlice 创建 state 对象 并导出 reducer import { createSlice } from &amp;#39;@reduxjs/toolkit&amp;#39; import { defaultFoodsList } from &amp;#39;./default&amp;#39; const takeaway = createSlice({ // 名称 name: &amp;#39;takeaway&amp;#39;, // 初始数据 initialState: { foodsList: defaultFoodsList, }, // actions reducers: { } }) // 导出 reducer 在 store/index.js 中合并 const takeawayReducer = takeaway.reducer export default takeawayReducer 初始化 foodsList 的时候使用了 精简版 的默认值， 保证数据解构完整性。 以避免从服务器获取数据失败时的渲染报错。</description></item><item><title>2. 初始化项目</title><link>https://typonotes.com/books/react/setup/initialize/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/setup/initialize/</guid><description>2. 创建项目 npx create-react-app react-basic npx 是 node.js 的工具命令， 查找并执行后续包命令。 create-react-app 是 核心包（固定写法）， 用于创建 react 项目 react-basic 是 react 项目名称， 可以自定义。 3. 项目配置 ## 启动命令 npm start ## 编译命令 npm run build # 注意这个 run 用不用都可以 可以在 package.json 中看到核心组建与启动命令
// 依赖组建 &amp;quot;dependencies&amp;quot;: { &amp;quot;@testing-library/jest-dom&amp;quot;: &amp;quot;^5.17.0&amp;quot;, &amp;quot;@testing-library/react&amp;quot;: &amp;quot;^13.4.0&amp;quot;, &amp;quot;@testing-library/user-event&amp;quot;: &amp;quot;^13.5.0&amp;quot;, &amp;quot;react&amp;quot;: &amp;quot;^18.2.0&amp;quot;, &amp;quot;react-dom&amp;quot;: &amp;quot;^18.2.0&amp;quot;, &amp;quot;react-scripts&amp;quot;: &amp;quot;5.0.1&amp;quot;, &amp;quot;web-vitals&amp;quot;: &amp;quot;^2.1.4&amp;quot; }, // 启动命令 &amp;quot;scripts&amp;quot;: { &amp;quot;start&amp;quot;: &amp;quot;react-scripts start&amp;quot;, &amp;quot;build&amp;quot;: &amp;quot;react-scripts build&amp;quot;, &amp;quot;test&amp;quot;: &amp;quot;react-scripts test&amp;quot;, &amp;quot;eject&amp;quot;: &amp;quot;react-scripts eject&amp;quot; }, 4.</description></item><item><title>2. 如何定义组件</title><link>https://typonotes.com/books/react/react/components/define-component/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/components/define-component/</guid><description>组件的定义方式有两种。
函数式组件： 最常用 类式组件 组件名通常使用 大驼峰 命名方式， 即 首字母大写的驼峰
例如， MyButton, UserInfoDisplay
1. 组件的定义 1.1. 函数式组件 在 /src/components/component/FuncComponent.js 中
function FunctionButtion() { return ( &amp;lt;button&amp;gt;function buttion&amp;lt;/button&amp;gt; ) } export default FunctionButtion; 1.2. 箭头函数式组件 箭头函数也是函数， 所以和上面 function 定义没什么区别。 也在 /src/components/component/FuncComponent.js 中
export const ArrowFuncButtion = () =&amp;gt; { return ( &amp;lt;button&amp;gt;arrow func button&amp;lt;/button&amp;gt; ) } 1.3. 类式组件 这个有有点特别了， 在 React 18 中， 已经不怎么用了。</description></item><item><title>2. 父传子通信</title><link>https://typonotes.com/books/react/react/communication/props/parent-to-children/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/props/parent-to-children/</guid><description>/src/components/communication/Parent2Children.jsx
实现步骤
传递数据: 父组件 在 子组件 上 绑定属性 接收数据: 子组件 使用 props 参数接收数据。 function Parent() { const name = &amp;#34;Zhangsan&amp;#34;; const age = 18; return ( &amp;lt;div&amp;gt; &amp;lt;span&amp;gt;Parent Area: &amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;name=Zhangsan, age=18&amp;lt;/span&amp;gt; {/* 1. 通过属性给 Child 传递数据 */} &amp;lt;Child name={name} age={age} /&amp;gt; &amp;lt;/div&amp;gt; ); } // 2. 定义的时候， 使用 props 接收参数 function Child(props) { // 打印所有 props console.log(props); return ( &amp;lt;div&amp;gt; &amp;lt;span&amp;gt;Child Area: &amp;lt;/span&amp;gt; {/* 3. 使用的时候， 使用 props.</description></item><item><title>2. 路由导航</title><link>https://typonotes.com/books/react/react/router/navigate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/router/navigate/</guid><description>使用 路由导航 可以在不同组件之间切换。
创建两个组件 Login 和 Article。 目录结构如下。
统一 import 到 RootRouter 下管理， 对应的 router 也需要做调整。
import { createBrowserRouter, RouterProvider } from &amp;#34;react-router-dom&amp;#34;; import Login from &amp;#34;./Login&amp;#34;; import Article from &amp;#34;./Article&amp;#34;; const router = createBrowserRouter([ { path: &amp;#34;/login&amp;#34;, element: &amp;lt;Login /&amp;gt; // 登录 Login }, { path: &amp;#34;/article&amp;#34;, element: &amp;lt;Article /&amp;gt; // 文章 Article } ]) export default function RootRouter() { return ( &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;8. 路由页面 Root Page&amp;lt;/h2&amp;gt; &amp;lt;RouterProvider router={router} /&amp;gt; &amp;lt;/div&amp;gt; ); } 声明式导航 声明式导航: 是指通过在模版中使用 &amp;lt;Link /&amp;gt; 组件描述出要跳转到哪里去。 比如后台管理系统的左侧菜单通常使用这种方式进行。</description></item><item><title>3. Redux 与 React - 实现 Counter(同步)</title><link>https://typonotes.com/books/react/library/redux/redux-react-counter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/library/redux/redux-react-counter/</guid><description>先来看一张 Redux 与 React 调用全图。
全图左右两个部分， 中间使用 store 关联起来。 左边使用 @reduxjs@toolkit 创建 reducer 管理 store. 右边使用 react-redux 获取数据并修改。 1. 创建 Slice 并初始化 counterReducer 在 /src/store/modules/counterStore.js 创建 reducer 和 actions
从 @reduxjs/toolkit 中导入并使用 createSlice 创建 通过 counterSlice.reducer 获取 reducer 并导出。 在 index.js 中引用， 创建 合并reducer 通过 counterSlice.actions 获取 actions 并导出。 在外部代码引用， 使用 useDispatch 调用修改 state 的值。 import { createSlice } from &amp;#39;@reduxjs/toolkit&amp;#39;; const counterSlice = createSlice({ // 设置名称 name: &amp;#39;counter&amp;#39;, // 设置初始状态 state initialState: { value: 0, }, // 设置修改方法 actions reducers: { increment: (state) =&amp;gt; { state.</description></item><item><title>3. 列表与字典渲染</title><link>https://typonotes.com/books/react/react/jsx/list-render/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/jsx/list-render/</guid><description>代码在 /src/components/jsx/ListRender.js 中
列表默认情况是这样的
&amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;liubei&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;guanyu&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;zhangfei&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; 1. 标准版的渲染 const list = [&amp;#39;liubei&amp;#39;, &amp;#39;guanyu&amp;#39;, &amp;#39;zhangfei&amp;#39;] function ListRender() { return ( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;2.3. 循环渲染&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt; list = [&amp;#39;liubei&amp;#39;, &amp;#39;guanyu&amp;#39;, &amp;#39;zhangfei&amp;#39;]&amp;lt;/p&amp;gt; &amp;lt;h3&amp;gt;箭头函数， 完整版。 带 key &amp;lt;/h3&amp;gt; &amp;lt;ul&amp;gt; // (1) 保留外城的 ul { list.map((item, index) =&amp;gt; { // (2) 循环什么就返回什么。 // (3) key 是 React 渲染的唯一表示 return &amp;lt;li key={index}&amp;gt;{item}&amp;lt;/li&amp;gt; }) } &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; ) } 当我们要进行 列表渲染 的时候，</description></item><item><title>3. 清理副作用</title><link>https://typonotes.com/books/react/react/hooks/use-effect/clear-side-effect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/use-effect/clear-side-effect/</guid><description>3. 清除函数副作用 useEffect 的第一个参数时一个函数。 当该函数有 return 返回值 statement 的时候， 会在 组件被卸载/取消挂载 的时候执行。
如下代码， return 返回的 箭头函数 会在其所在的组件的组件被卸载的时候 停止计时器 。
useEffect( () =&amp;gt; { const id = setInterval(() =&amp;gt; { console.log(&amp;#39;Child: setInterval called&amp;#39;); }, 1000); // 当省略清理函数时， // 组件卸载时，定时器不会被清除 // 当重新加载组件时，会创建新的定时器， 多个定时器会同时运行 return () =&amp;gt; { clearInterval(id); } }, [] // 依赖项为空数组，只有在加载时执行一次， 只有在组件卸载时才会执行清理函数 ) 如果没有这段 return 清空计时器的代码， 那么当所在组件 反复 被挂载时， 每次加载都会启动一个新的定时器， 结果就是 启动无数个 计时器。</description></item><item><title>3. 特殊的 children 插槽</title><link>https://typonotes.com/books/react/react/communication/props/slot-children/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/props/slot-children/</guid><description>/src/components/communication/RootCommunication.jsx
export default function RootCommunication() { return ( &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt; 7. 组件通信&amp;lt;/h2&amp;gt; {/* 1. 自闭和标签 */} &amp;lt;Parent2Children /&amp;gt; {/* 2. 成对标签， 默认插槽 */} &amp;lt;PropChild&amp;gt; &amp;lt;span&amp;gt;span1&amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;span2&amp;lt;/span&amp;gt; &amp;lt;/PropChild&amp;gt; &amp;lt;/div&amp;gt; ); } 可以看到在使用 PropChild
使用的是 成对标签。 标签中放入了两个 span 标签。 function PropChild(props) { return ( &amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;7.1. 特殊的 props.children&amp;lt;/h3&amp;gt; {/* 拿到默认的 children 属性 */} &amp;lt;span&amp;gt;prop child: {props.children}&amp;lt;/span&amp;gt; &amp;lt;hr /&amp;gt; &amp;lt;/div&amp;gt; ) } 在 PropChild 内部， 使用 props.children 拿到了传过来的标签值
使用 React Developer Tool 可以更清晰的看到其属性</description></item><item><title>3. 路由传参</title><link>https://typonotes.com/books/react/react/router/navigate-params/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/router/navigate-params/</guid><description>有 两种 方式可以通过 路由地址 进行参数传递。
路径传参: /path/1234/zhangsan query请求传参: /article?id=1101&amp;amp;name=wangwu 1. 路径传参 顾名思义， 就是 将参数放在 path 中。
在使用之前需要 定义参数名称和位置。 使用 useParams 接受参数 在 /src/components/router/RootRouter.jsx 中
const router = createBrowserRouter([ { // 定义参数位置和名称 path: &amp;#34;/article/:id/:name&amp;#34;, element: &amp;lt;Article /&amp;gt; } ]) 在 /src/components/router/Article/index.jsx 中使用 useParams 使用 解构赋值 接受参数
import { Link } from &amp;#34;react-router-dom&amp;#34;; import { useParams } from &amp;#34;react-router-dom&amp;#34;; export default function Article() { // 使用 解构赋值 获取路由参数 const { id, name } = useParams(); return ( &amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;8.</description></item><item><title>4. Redux 与 React - 实现 Channel (异步)</title><link>https://typonotes.com/books/react/library/redux/redux-react-channel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/library/redux/redux-react-channel/</guid><description>异步 的实现方法和同步差不多。
1. 使用 createSlice 创建 在 /src/store/modules/channelStore.js 中创建 Channel Store。 这一步同步是一样的。
const channelSlice = createSlice({ // 名称 name: &amp;#39;channel&amp;#39;, // 初始化数据 initialState: { channels: [ { id: 1, name: &amp;#39;网络不通， 检查网络&amp;#39; }, ], }, // actions 方法 reducers: { setChannels(state, action) { state.channels = action.payload; } }, }) 2. 导出 reducer 到 store/index.js 这一部分也一样
在 /src/store/modules/channelStore.js 中导出 reduder，</description></item><item><title>4. 子传父通信</title><link>https://typonotes.com/books/react/react/communication/props/children-to-parent/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/props/children-to-parent/</guid><description>/src/components/communication/Children2Parent.jsx
核心思路: 父组件可以给子组件传递一个函数， 子组件通过调用函数向父组件传递数据
父组件通过 props 向子组件传递数据， 但 在子组件中 props 是只读的。 因此 数据只能在父组件中被修改 function Parent() { const original = &amp;#34;Father.React&amp;#34; // 在父组件定义一个状态数据 const [name, setName] = useState(original) // 重置名字 function resetName() { setName(original) } // 1. 通过函数修改父组件的状态数据 function changeName(name) { setName(name) } return ( &amp;lt;div&amp;gt; &amp;lt;p&amp;gt;父组件名字: {name}&amp;lt;/p&amp;gt; &amp;lt;b&amp;gt;父组件区域: &amp;lt;/b&amp;gt; &amp;lt;button onClick={resetName}&amp;gt;重置名称&amp;lt;/button&amp;gt; &amp;lt;span&amp;gt;重置父组件名字&amp;lt;/span&amp;gt; {/* 1. 通过 props 将函数传递给子组件 2. props 属性名字加上 on 表示调用执行 */} &amp;lt;hr&amp;gt;&amp;lt;/hr&amp;gt; &amp;lt;Child onChangeName={changeName} /&amp;gt; &amp;lt;/div&amp;gt; ) } 在 父组件中</description></item><item><title>4. 嵌套路由</title><link>https://typonotes.com/books/react/react/router/nested-routers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/router/nested-routers/</guid><description>嵌套路由: 在一级路由中 内嵌 了其他路由， 这种路由关系就叫做 嵌套路由。
嵌套到一级路由内的路由又被称为 二级路由。 以此类推， 三级、四级路由。
最常见应用场景， 就是 系统管理界面， 如图。
1. 使用 children 属性配置路由嵌套关系 在 /src/components/router/RootRouter.jsx 中， 添加路由表。
const router = createBrowserRouter([ { path: &amp;#34;/&amp;#34;, element: &amp;lt;Layout /&amp;gt;, // 指定子路由 children: [ // 子路由与父路由定义方式一样 { path: &amp;#34;/board&amp;#34;, element: &amp;lt;Board /&amp;gt; }, { path: &amp;#34;/about&amp;#34;, element: &amp;lt;About /&amp;gt; } ], } ]) 2. 使用 &amp;lt;Outlet /&amp;gt; 指定二级路由渲染位置 在 /src/components/router/Layout/index.</description></item><item><title>4. 条件渲染</title><link>https://typonotes.com/books/react/react/jsx/conditional-render/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/jsx/conditional-render/</guid><description>React 根据条件运算返回的不同结果进行结果渲染， 主要分为以下几种
逻辑判断： &amp;amp;&amp;amp;, ||, ! 三目运算符: condition? yes : no 分支语句： if-else, switch 1. 逻辑运算符 逻辑运算符：
&amp;amp;&amp;amp; 且 || 或 ! 非 function ConditionalRender() { return ( &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;04. 条件渲染: isLogin={String(isLogin)}&amp;lt;/h2&amp;gt; &amp;lt;h3&amp;gt;1. 逻辑语句&amp;lt;/h3&amp;gt; &amp;lt;p&amp;gt;isLogin &amp;amp;&amp;amp; Login &amp;lt;/p&amp;gt; {isLogin &amp;amp;&amp;amp; &amp;lt;Login /&amp;gt;} &amp;lt;p&amp;gt;isLogin || Logout&amp;lt;/p&amp;gt; {isLogin || &amp;lt;Logout /&amp;gt;} &amp;lt;p&amp;gt;isLogin &amp;amp;&amp;amp; Login || Logout&amp;lt;/p&amp;gt; {isLogin &amp;amp;&amp;amp; &amp;lt;Login /&amp;gt; || &amp;lt;Logout /&amp;gt;} {(isLogin &amp;amp;&amp;amp; &amp;lt;Login /&amp;gt;) || &amp;lt;Logout /&amp;gt;} &amp;lt;/div &amp;gt; ) } const isLogin = false; 条件语句 必须要在最前面。 &amp;amp;&amp;amp; 和 || 可以单独使用； 也可以一起使用， 一起使用时效果类似 三目运算符。 但是 React 并不推荐这么做， 如果这样做了会给予提示： 混合使用 &amp;amp;&amp;amp; 和 ||。 请用 圆括号 指定执行顺序</description></item><item><title>5. 兄弟通信</title><link>https://typonotes.com/books/react/react/communication/props/brothers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/props/brothers/</guid><description>/src/components/communication/Brothers.jsx
兄弟组件没有关联关系， 因此需要 通过共同的父组件 进行数据的传递。 这并不是一个新东西， 而是将 父传子、子传父 组合案例。
function Parent() { // 1. 在父节点定义状态数据 const [name, setName] = useState(&amp;#34;&amp;#34;) // 2. 在父节点定义修改状态数据的方法 function changeName(name) { setName(name) } return ( &amp;lt;div&amp;gt; {/* 3. 给 Child A 传递修改数据方法 */} &amp;lt;ChildA onChangeName={changeName} /&amp;gt; {/* 3. 给 Child B 传递数据 */} &amp;lt;ChildB name={name} /&amp;gt; &amp;lt;/div&amp;gt; ); } 在 父节点
使用 useState 定义状态数据 name 定义 修改函数 changeName 将修改传输传递给 ChildA, 将状态数据传递给 ChildB function ChildA({ onChangeName }) { return ( &amp;lt;div&amp;gt; &amp;lt;b&amp;gt;Child A: &amp;lt;/b&amp;gt; {/* 4.</description></item><item><title>5. 样式的使用</title><link>https://typonotes.com/books/react/react/jsx/style/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/jsx/style/</guid><description>源代码在 /src/components/styles/RootStyle.jsx
1. 行内样式 在标签内使用使用 style={{key:v1, k2:v2}} 实现样式管理。
&amp;lt;p style={{ color: &amp;#34;red&amp;#34;, fontSize: &amp;#34;18px&amp;#34; }}&amp;gt;1.1. 行内样式&amp;lt;/p&amp;gt; 外层 {}: 开始 React 语法。 {k1:v1, k2:v2}: 是一个 Object 对象。 key 使用 驼峰 规则: font-size =&amp;gt; fontSize 向上面直接写在行内的方式， 管理起来并不清晰。 因此可以将 样式 赋值给一个 变量 保存。
export default function RootStyle() { return ( &amp;lt;div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;p style={style}&amp;gt;1.2. 行内样式2&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; ) } const style = { color: &amp;#34;blue&amp;#34;, fontSize: &amp;#34;18px&amp;#34; } 2.</description></item><item><title>5. 默认路由</title><link>https://typonotes.com/books/react/react/router/default-router/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/router/default-router/</guid><description>在 router 配置的时候， path 的值使用 * 即可配置默认路径。 当用户访问路径无法匹配时返回。
通常， 默认路径可以用于 优化 404 页面， 提高用户体验。
在 /src/components/router/RootRouter.jsx 中,
const router = createBrowserRouter([ { // 使用 * 匹配所有路由 path: &amp;#34;*&amp;#34;, element: &amp;lt;NotFound /&amp;gt; } ])</description></item><item><title>6. 路由模式</title><link>https://typonotes.com/books/react/react/router/router-modes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/router/router-modes/</guid><description>路由模式 URL表现 底层原理 是否需要后端支持 history url/login history对象+pushState事件 需要 hash url/#/login 监听 hashChange 事件 不需要 memory url ?? ?? 1. Hash 模式 使用 createHashRouter 创建 Hash 模式。 path 上有 # 。 单页面模式
import { createHashRouter } from &amp;#34;react-router-dom&amp;#34;; const router = createHashRouter([ { path: &amp;#34;/login&amp;#34;, element: &amp;lt;Login /&amp;gt; } ]) 2. Memory 模式 使用 createMemoryRouter 模式。 path 路径 不会 在 URL 上体现出来。 单页面模式</description></item><item><title>classnames</title><link>https://typonotes.com/books/react/library/chassnames/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/library/chassnames/</guid><description> 项目地址: https://github.com/JedWatson/classnames
安装方式 npm install classnames Demo import classNames from &amp;#39;classnames&amp;#39;; classNames(&amp;#39;foo&amp;#39;, &amp;#39;bar&amp;#39;); // =&amp;gt; &amp;#39;foo bar&amp;#39; classNames(&amp;#39;foo&amp;#39;, { bar: true }); // =&amp;gt; &amp;#39;foo bar&amp;#39; classNames({ &amp;#39;foo-bar&amp;#39;: true }); // =&amp;gt; &amp;#39;foo-bar&amp;#39; classNames({ &amp;#39;foo-bar&amp;#39;: false }); // =&amp;gt; &amp;#39;&amp;#39; classNames({ foo: true }, { bar: true }); // =&amp;gt; &amp;#39;foo bar&amp;#39; classNames({ foo: true, bar: true }); // =&amp;gt; &amp;#39;foo bar&amp;#39; // lots of arguments of various types classNames(&amp;#39;foo&amp;#39;, { bar: true, duck: false }, &amp;#39;baz&amp;#39;, { quux: true }); // =&amp;gt; &amp;#39;foo bar baz quux&amp;#39; // other falsy values are just ignored classNames(null, false, &amp;#39;bar&amp;#39;, undefined, 0, { baz: null }, &amp;#39;&amp;#39;); // =&amp;gt; &amp;#39;bar&amp;#39;</description></item><item><title>dayjs 时间处理</title><link>https://typonotes.com/books/react/library/dayjs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/library/dayjs/</guid><description>dayjs 是一款 nodejs 的 时间 处理库。 与 js 原生时间库 Date 相比， 更好用。
官网: https://day.js.org/docs/en/installation/typescript 中文网: https://dayjs.fenxianglu.cn/category/#node-js 1. install
npm install dayjs 2. Usage
import dayjs from &amp;#39;dayjs&amp;#39; // https://day.js.org/docs/en/parse/string-format dayjs().format(&amp;#39;YYYY-MM-DD HH:mm:ss&amp;#39;) // 2023-03-18 19:33:24 更多直接查看官网。</description></item><item><title>lodash 工具库</title><link>https://typonotes.com/books/react/library/lodash/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/library/lodash/</guid><description/></item><item><title>redux</title><link>https://typonotes.com/books/react/react/communication/redux/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/redux/</guid><description>到 三方库/redux 中查看</description></item><item><title>sass</title><link>https://typonotes.com/books/react/lang/css/sass/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/lang/css/sass/</guid><description>npm install sass</description></item><item><title>useContext 数据传递</title><link>https://typonotes.com/books/react/react/hooks/use-context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/use-context/</guid><description/></item><item><title>useImmer 状态数据</title><link>https://typonotes.com/books/react/react/hooks/use-immer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/use-immer/</guid><description>useImmer 是 useState 的 加强版。
https://github.com/immerjs/use-immer npm install immer use-immer</description></item><item><title>useRef 获取 DOM</title><link>https://typonotes.com/books/react/react/hooks/use-ref/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/use-ref/</guid><description>在 React 中 获取/操作 DOM， 需要使用 useRef 钩子函数
import { useRef } from &amp;#39;react&amp;#39;; export default function UseRef() { // 1. 使用 useRef 生成 ref 对象 const inputRef = useRef(null); function showDOM() { // 使用 console.log 查看 ref 对象 console.log(inputRef.current); // 使用 console.dir 展开 ref 对象 console.dir(inputRef.current); // 焦点锁定 inputRef.current.focus() } return ( &amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;3. useRef 获取 DOM&amp;lt;/h3&amp;gt; &amp;lt;p&amp;gt;点击 Button 在控制台查看输出&amp;lt;/p&amp;gt; {/* 将 ref 绑定到标签属性上 */} &amp;lt;input type=&amp;#34;text&amp;#34; ref={inputRef} /&amp;gt; {/* 3.</description></item><item><title>useState 状态数据</title><link>https://typonotes.com/books/react/react/hooks/use-state/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/use-state/</guid><description>React 讲究的是 数据驱动页面。 意思是 当状态数据被修改了，页面内容也会被重新渲染更新。
如果要上述这个效果， 就需要用到 useState 这个 钩子(Hook)
使用 useState 时， 需要先导入。 import { useState } from &amp;#34;react&amp;#34; 使用 const/let 进行结构赋值。 count 和 setCount 是一对 3. useState 创建 状态， 并定义变量的默认值。 count 被称为状态变量，不应该被直接修改， 推荐使用 const 初始化 setCount 是一个函数, 修改 count 的函数。 通过 setCount 修改 count 的值，会触发相关组件的重新渲染。 // const: count 不能被修改 const [count, setCount] = useState(0) // let: count 可以被修改 let [count, setCount] = useState(0) 注意: 使用 let 定义时， count 非只读， 可以直接修改。 但不会触发组件的重新渲染。</description></item><item><title>uuid</title><link>https://typonotes.com/books/react/library/uuid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/library/uuid/</guid><description>uuid 生成 UUID 随机数。
https://github.com/uuidjs/uuid https://www.npmjs.com/package/uuid 1. Install npm install uuid 2. Create a UUID (ES6 module syntax)
import { v4 as uuidv4 } from &amp;#39;uuid&amp;#39;; uuidv4(); // ⇨ &amp;#39;9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d&amp;#39; &amp;hellip; or using CommonJS syntax:
const { v4: uuidv4 } = require(&amp;#39;uuid&amp;#39;); uuidv4(); // ⇨ &amp;#39;1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed&amp;#39; const { v4: uuidv4 } = require(&amp;#39;uuid&amp;#39;); uuidv4(); // ⇨ &amp;#39;1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed&amp;#39;</description></item><item><title>自定义 Hook</title><link>https://typonotes.com/books/react/react/hooks/customize-hook/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/customize-hook/</guid><description>简单的说 自定义 Hook 就是创建一个以 use开头的函数。 往复杂了说还需要考虑各种数据状态、冲突。
自定义 Hook 通用思路 以 use 开头的函数 函数内部可以调用其他 Hook 通常返回一个数组或对象（包含状态数据和控制方法）， 以便在组件中使用 其他组件则可以直接调用该函数，而不需要关心内部实现 代码在 /src/components/hooks/CustomizeHook.jsx
1. 原始对象， 直接管理 export default function CustomizeHook() { // 使用 useState 直接管理 const [isShow, setIsShow] = useState(true) const toggle = () =&amp;gt; { setIsShow(!isShow) } return ( &amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;5. CustomizeHook&amp;lt;/h3&amp;gt; &amp;lt;button onClick={toggle}&amp;gt;Toggle: 隐藏或显示&amp;lt;/button&amp;gt; {isShow &amp;amp;&amp;amp; &amp;lt;p&amp;gt;this is a span&amp;lt;/p&amp;gt;} &amp;lt;/div&amp;gt; ) } 2.</description></item></channel></rss>