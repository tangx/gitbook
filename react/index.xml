<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>React 18/19</title><link>https://typonotes.com/books/react/</link><description>Recent content on React 18/19</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://typonotes.com/books/react/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://typonotes.com/books/react/demos/account-book/data-analysis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/demos/account-book/data-analysis/</guid><description>1. lodash 根据时间分组数据 安装
$ npm install lodash 分组数据
const newList = lodash.groupBy(billList, (item) =&amp;gt; { return dayjs(item.date).format(&amp;#39;YYYY-MM&amp;#39;) }) console.log(&amp;#34;newList&amp;#34;, newList) 2. useMemo 缓存数据 useMemo 用于缓存数据， 依赖数据变化时， 才会重新计算。 类似 vue 中的 computed 用法与 useEffect 类似， 但是 useEffect 是用于处理副作用的， useMemo 是用于缓存数据的 // 获取原始数据 billList const { billList } = useSelector(state =&amp;gt; state.bill) const monthGroup = useMemo( // 计算函数 // 不需要传入参数， 因为依赖项已经在外部声明 // 错误示范 (billList)=&amp;gt;{return billList} () =&amp;gt; { // return billList return lodash.</description></item><item><title/><link>https://typonotes.com/books/react/SUMMARY/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/SUMMARY/</guid><description>React 18 学习笔记 初始化项目</description></item><item><title>01. 使用 @ 路径别名</title><link>https://typonotes.com/books/react/demos/account-book/pash-alias/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/demos/account-book/pash-alias/</guid><description>注意： 非注释行 是新添加的。
// import { defineConfig } from &amp;#39;vite&amp;#39; // import react from &amp;#39;@vitejs/plugin-react&amp;#39; import path from &amp;#39;path&amp;#39; // https://vitejs.dev/config/ export default defineConfig({ // plugins: [react()], resolve: { alias: { // @ =&amp;gt; src &amp;#34;@&amp;#34;: path.resolve(__dirname, &amp;#34;src&amp;#34;) }, }, }) 当然还可以添加更多， https://typonotes.com/posts/2021/09/28/vue3-with-alias-path/</description></item><item><title>01. 初始化</title><link>https://typonotes.com/books/react/demos/account-book/setup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/demos/account-book/setup/</guid><description>这个 demo 不要随意发挥， 尤其是在命名上。 因为有很多 格式代码 要直接复制课件。
1. 使用 npm vite 创建项目 $ npm create vite@latest # React -&amp;gt; JavaScript 2. 安装依赖插件 2.1. sass $ npm install sass --save 2.2. axios $ npm install axios --save 2.3. 3. 使用 JsonServer 模拟数据 $ json-server --port 8888 /src/server/data/data/json 3.</description></item><item><title>02. 初始化 route</title><link>https://typonotes.com/books/react/demos/account-book/route/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/demos/account-book/route/</guid><description>安装 react-route npm install react-router-dom 创建目录结构 tree . ├── components │ ├── Layout │ │ ├── Month │ │ │ └── index.jsx │ │ ├── Year │ │ │ └── index.jsx │ │ └── index.jsx │ └── New │ └── index.jsx 在 /src/routes/index.jsx 因为要写标签， 一定要用 jsx 中， 创建路由 import { createBrowserRouter } from &amp;#34;react-router-dom&amp;#34;; import Layout from &amp;#34;../components/Layout&amp;#34;; import Month from &amp;#34;../components/Layout/Month&amp;#34;; import Year from &amp;#34;../components/Layout/Year&amp;#34;; import New from &amp;#34;.</description></item><item><title>03. 使用 redux 管理数据</title><link>https://typonotes.com/books/react/demos/account-book/redux/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/demos/account-book/redux/</guid><description>1. 安装 redux 和 toolskit $ npm install @reduxjs/toolkit react-redux 2. 初始化 redux store 在 /src/demos/AccountBook/src/store/modules/billStore/index.js 中 使用 createSlice 创建 billStore 初始化 name, initialState, reducers 默认导出 billStore.reduer 创建同步 action setBillList 创建异步 action getBillList， 并从 json-server 中获取数据 导出 getBillList。 在 /src/demos/AccountBook/src/store/index.js 中 使用 configureStore 创建 store 导入 billStore.reduer。 再导入 store.reducer 中， 并指定为 bill。 默认导出 store 在 /src/demos/AccountBook/src/demos/AccountBook/src/App.</description></item><item><title>04. andD-mobile 主题</title><link>https://typonotes.com/books/react/demos/account-book/antd-mobile-theme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/demos/account-book/antd-mobile-theme/</guid><description>And Design Mobile 是一个 移动端 的样式库
1. 安装 $ npm install --save antd-mobile # or $ yarn add antd-mobile 2. 使用 import { Button } from &amp;#39;antd-mobile&amp;#39; // 组件按钮 &amp;lt;Button type=&amp;#34;primary&amp;#34;&amp;gt;点我+1&amp;lt;/Button&amp;gt; // 原生按钮 &amp;lt;button&amp;gt;点我+1&amp;lt;/button&amp;gt; 3. 主题定制 全局定制: 整个应用范围 内的所有组件都生效 /* 蓝色 */ :root:root { --adm-color-primary: #006DFD; } 局部定制: 只有在某些元素 内部生效。 /* 紫色 */ .purple-theme { --adm-color-primary: #9E53D4; }</description></item><item><title>05. TabBar</title><link>https://typonotes.com/books/react/demos/account-book/tabbar/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/demos/account-book/tabbar/</guid><description>官网文档 TabBar
1. 准备工作 从课件中复制 TabBar 的 index.jsx 和 index.scss 到 /src/demos/AccountBook/src/components/Layout 中
2. 切换路由 注意 看文档， 可能不同的样式库有不同的实现方式。
路由切换是在 TabBar 的 onChange 事件实现的。 而非在 TabBar.Item 中的 onClick 中实现。 import { useNavigate } from &amp;#39;react-router-dom&amp;#39; const Layout = () =&amp;gt; { const navigate = useNavigate() // 切换路由 const switchRouteActive = (path) =&amp;gt; { navigate(path) } // 返回 return ( &amp;lt;TabBar onChange={path =&amp;gt; switchRouteActive(path)}&amp;gt; {/* &amp;lt;TabBar onChange={path =&amp;gt; useNavigate(path)}&amp;gt; // 可行*/} {tabs.</description></item><item><title>06. 时间选择器 - 月度统计</title><link>https://typonotes.com/books/react/demos/account-book/date-picker-monthly/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/demos/account-book/date-picker-monthly/</guid><description>1. 管理时间选择器状态 1.1. 使用 useState 管理时间选择器状态 const [dateVisable, setDateVisable] = useState(false) 1.2. 点击箭头展开时选择器 使用onClick 事件 打开时间选择器控件 使用 classNames 控制箭头显示状态 &amp;lt;div className=&amp;#34;date&amp;#34; // 打开时间选择器 onClick={() =&amp;gt; setDateVisable(true)}&amp;gt; {/* &amp;lt;span className=&amp;#39;arrow expand&amp;#39;&amp;gt;&amp;lt;/span&amp;gt; */} {/* 错误示范 */} {/* &amp;lt;span className=classNames={&amp;#39;arrow&amp;#39;, &amp;#39;expand&amp;#39;}&amp;gt;&amp;lt;/span&amp;gt; */} {/* 正确示范: classNames 是一个函数， 需要在外层 {} 开启 jsx 语法 */} &amp;lt;span className={classNames( &amp;#39;arrow&amp;#39;, { &amp;#39;expand&amp;#39;: dateVisable })}&amp;gt; &amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; 1.</description></item><item><title>07. 时间选择器 - 按日统计</title><link>https://typonotes.com/books/react/demos/account-book/date-picker-daily/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/demos/account-book/date-picker-daily/</guid><description>本篇是 按日 统计消费数据， 其逻辑和上一篇 按月 是一样的。 根据 视频弹幕提示 ， 并没有完全按照视频的思路进行， 而是
使用了 自定义 Hook 使用 lodash 的 map, groupBy, orderBy 等方法整理数据。 1. 自定义组件逻辑 在视频中的组件是 Month 直接嵌套 DailyBill。 但是我觉得继续在 Month 中写代码造成文件臃肿且复杂。
因此额外抽了一层 DailyBillEntry， 现在就成了 Month -&amp;gt; DailyBillEntry -&amp;gt; DailyBill。 其中
DailyBillEntry 承上启下： 接受 Month 传下来的数据， 并调用 useDailyResults 计算出结果数据， 传递给 DailyBill DailyBill 依旧只负责展示结果。 2. 自定义 Hook: useDailyResults 在 /src/demos/AccountBook/src/components/Layout/Month/Daily/hooks.js 中</description></item><item><title>08. 新增账单</title><link>https://typonotes.com/books/react/demos/account-book/new-bill/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/demos/account-book/new-bill/</guid><description>1. 界面分析 在新增账单界面上， (1) 有两种类型： 支出(pay) 和 收入(income)。 根据对应的选择， 会将数据传递到 (3) 的进行渲染。 此处不需要额外的路由配置。 1.1. 复制课件资料 复制课件资料的时候， 注意代码中使用了 路径别名 @。 如果发现报错，注意进行本地化替换。
// import { billListData } from &amp;#39;@/contants&amp;#39; import { billListData } from &amp;#39;../../constants&amp;#39; 2. 收入支出状态切换 点击按钮切换装题啊 适配显示数据 2.1. 点击切换收入支出按钮 使用 useState 创建一个 selected 选中状态变量。 使用 classNames 在 收入/支出按钮 上绑定 selected 属性。 判断是否与 selected 值相同而启用 为 收入/支持按钮 增加 onClick 事件， 变更 selected 的值。 const New = () =&amp;gt; { // 1.</description></item><item><title>1. for</title><link>https://typonotes.com/books/react/javascript/loop/for/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/loop/for/</guid><description>for for&amp;hellip;in for&amp;hellip;of for await&amp;hellip;of 1. for for 循环与 Golang 的使用方式一致。
for (initialization; condition; afterthought) { statement } 注意:
在定义变量的时候， 只能使用 let。 因为 const 是常量，不能被重新赋值。 在 (let i=1; y; z) 条件语句中定义的变量， 只能在 for 的 scope 中使用。 for (let i = 1; i &amp;lt;= 9; i++) { console.log(`${i}`); } // console.log(i); // i is not defined 1.1. 省略 for 条件 (x; y; z) 中的 x,y,z 可以 省略任意一个或多个</description></item><item><title>1. if-else</title><link>https://typonotes.com/books/react/javascript/control-flow/if-else/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/control-flow/if-else/</guid><description>if&amp;hellip;else
if...else 条件分支。
const a = 1, b = 2 if (a &amp;gt; b) { console.log(&amp;#39;a is less than b&amp;#39;) } else { console.log(&amp;#39;a is not greater than b&amp;#39;) } 2. else 分支可以省略 if (a &amp;lt; b) { console.log(&amp;#39;a is greater than b&amp;#39;) } 3. 多个分支条件 类似 switch
const c = 3 if (a &amp;gt; b) { console.log(&amp;#39;a is greater than b&amp;#39;) } else if (a &amp;lt; c) { console.</description></item><item><title>1. jsx 的介绍</title><link>https://typonotes.com/books/react/react/jsx/introduce/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/jsx/introduce/</guid><description>之前在 /src/App.js 中说到了 className 是 react 语法。 更准确的说是 JSX 语法。
这是一个带有变量的例子
// 定义 变量 const message = &amp;#34;this is a message&amp;#34; function App() { // return 中的内容是 jsx 语法 return ( &amp;lt;div className=&amp;#34;App&amp;#34;&amp;gt; // className 不是 HTML 语法 {message} // 使用变量 &amp;lt;/div&amp;gt; ); } 1. 什么是 jsx jsx 是 js 的一种扩展语法， 继承了 js 和 xml 的优点。
可以使用 HTML 的声明式模版。 可以使用 js 的可编程能力。 由于 jsx 本身不是标准语法。 因此需要使用 Babel 进行编译后， 才能在 浏览器 上运行。 TypeScript同理， 也是需要编译成 js 后才能在浏览器上运行。</description></item><item><title>1. NaN</title><link>https://typonotes.com/books/react/javascript/data-types/number/number-nan/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/data-types/number/number-nan/</guid><description>2. 特殊数字 NaN 反正: 用之前， 最好先测试一下
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN
NaN 表示 Not a number。 NaN 是数字类型。 可以符合逻辑的想法:
任何 数字 相关的操作， 如果 执行错误，则返回 NaN 但是也有很多不符合逻辑的 例外:
字符串 -&amp;gt; 数字 有 隐式 转换。 // 数字函数处理 **数字行字符串** // parseInt: console.log(parseInt(10)); // 10 console.log(parseInt(&amp;#34;10.5&amp;#34;)); // 10 console.log(parseFloat(&amp;#34;10.5&amp;#34;)); // 10.5 console.log(parseInt(&amp;#34;10.5abc&amp;#34;)); // 10 console.log(parseInt(&amp;#34;abc10.5&amp;#34;)); // NaN // Number 类型转换字符串 console.log(Number(&amp;#34;10.5abc&amp;#34;)); // NaN console.</description></item><item><title>1. npx 初始化项目</title><link>https://typonotes.com/books/react/setup/initalize/npx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/setup/initalize/npx/</guid><description>2. 创建项目 npx create-react-app react-basic npx 是 node.js 的工具命令， 查找并执行后续包命令。 create-react-app 是 核心包（固定写法）， 用于创建 react 项目 react-basic 是 react 项目名称， 可以自定义。 3. 项目配置 ## 启动命令 npm start ## 编译命令 npm run build # 注意这个 run 用不用都可以 可以在 package.json 中看到核心组建与启动命令
// 依赖组建 &amp;quot;dependencies&amp;quot;: { &amp;quot;@testing-library/jest-dom&amp;quot;: &amp;quot;^5.17.0&amp;quot;, &amp;quot;@testing-library/react&amp;quot;: &amp;quot;^13.4.0&amp;quot;, &amp;quot;@testing-library/user-event&amp;quot;: &amp;quot;^13.5.0&amp;quot;, &amp;quot;react&amp;quot;: &amp;quot;^18.2.0&amp;quot;, &amp;quot;react-dom&amp;quot;: &amp;quot;^18.2.0&amp;quot;, &amp;quot;react-scripts&amp;quot;: &amp;quot;5.0.1&amp;quot;, &amp;quot;web-vitals&amp;quot;: &amp;quot;^2.1.4&amp;quot; }, // 启动命令 &amp;quot;scripts&amp;quot;: { &amp;quot;start&amp;quot;: &amp;quot;react-scripts start&amp;quot;, &amp;quot;build&amp;quot;: &amp;quot;react-scripts build&amp;quot;, &amp;quot;test&amp;quot;: &amp;quot;react-scripts test&amp;quot;, &amp;quot;eject&amp;quot;: &amp;quot;react-scripts eject&amp;quot; }, 4.</description></item><item><title>1. Number</title><link>https://typonotes.com/books/react/javascript/data-types/number/number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/data-types/number/number/</guid><description>1. 数字 JavaScript 只有 一种 数字类型： number。
不分 正数(int), 浮点数(float)
数字类型可以进行 四则运算。 优先级 左右相同， 上下递减
*, / 和 % 求模（余数） +, - Js 的 % 与其他语言不同， 不会舍弃 小数。
console.log(0.4 / 1); // 0.4 console.log(11.5 % 4); // 3.5 圆括号 具有最高优先级。 即可以改变优先级
console.log(5 / 2 + 3); // 5.5 console.log(5 / (2 + 3)); // 1 2. 特殊数字 NaN https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN</description></item><item><title>1. onClick 点击事件</title><link>https://typonotes.com/books/react/react/events/on-click/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/events/on-click/</guid><description>事件名称统一为 onXXXX Hanlder 函数支持多种方式定义， 变量形式 与 函数形式 // 不接受参数 // 变量形式 const handler1 = () =&amp;gt; { console.log(count); count = count + 1 } // 接收事件 // 函数形式 function handler2(event) { console.log(event) // count = count + 2 } 这里是是 onClick 点击事件。
1. 不接受参数 这种最简单， 只需要在 标签 中的 属性 中， 使用 onClick 事件时 指定 调用 handler 函数 即可。
&amp;lt;button onClick={handler1}&amp;gt;button +1&amp;lt;/button&amp;gt; 如上， 是在 button 中接收了的 onClick 事件。 注意</description></item><item><title>1. Redux计数器（纯网页版）</title><link>https://typonotes.com/books/react/react/communication/redux/counter-demo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/redux/counter-demo/</guid><description>在不使用 React 框架的情况下。 仅使用 Redux 实现一个计数器功能。
使用步骤 定义一个 reducer 函数。 （根据当前想要做的修改返回一个心的状态） 使用 createStore 方法传入 reducer， 生成一个 store 实例对象 使用 store 实例的 subscribe 方法 订阅数据变化。 （数据一旦变化， 可以得到通知） 使用 store 实例的 dispatch 方法提交 action 对象 触发数据变化。 （告诉 reducer 所需要执行的操作） 使用 store 实例 getState 方法 获取最新的状态数据， 并更新到试图中。 注意： Redux 不会主动更新视图， 需要主动调用 document DOM 绑定数据。
示例代码 本案例中使用 redux@4.2.1， 最新版本 5.0.x API 有新变化， 页面代码不兼容。 （2024-02-18）</description></item><item><title>1. use 替代 useEffect</title><link>https://typonotes.com/books/react/react/react19/use/use-instead-useEffect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/react19/use/use-instead-useEffect/</guid><description>替代 useEffect https://react.dev/reference/react/use#streaming-data-from-server-to-client
定义函数，从服务器获取资源
type MovieType = { title: string } // 获取资源，返回 Promise async function fetchMovie() { const resp = await axios.get&amp;lt;MovieType[]&amp;gt;(&amp;#34;http://localhost:8080/&amp;#34;) return resp.data[0] } useEffect 版本 export default function MovieUseEffectContainer() { // 使用 useState 管理数据状态 const [movie, setMovie] = useState&amp;lt;MovieType | undefined&amp;gt;(undefined) // 使用 useEffect 获取资源 useEffect(() =&amp;gt; { fetchMovie().then(setMovie) }, []) return ( &amp;lt;div&amp;gt; &amp;lt;Suspense fallback={&amp;lt;h2&amp;gt;MovieUseEffect, Loading .</description></item><item><title>1. Zustand 安装与使用</title><link>https://typonotes.com/books/react/react/communication/zustand/zustand/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/zustand/zustand/</guid><description>1. Zustand 安装 官网: https://zustand-demo.pmnd.rs/ Github: https://github.com/pmndrs/zustand $ npm install zustand 2. 同步方法 从 zustand 中导入函数 create。
使用 create 创建时接受 回调函数 set =&amp;gt; ({ ??? })
回调函数 必须 使用 set 作为形参， 用于更新状态数据。 回调函数返回一个 对象。 该对象包含 状态数据 与 修改方法 修改方法 使用 set 更新数据。 set 的参数可以是
一个状态对象。 一个返回状态对象的 回调函数。 如果 要使用状态值， 则通过 state 给 set 传递参数。 如果 不使用状态值， 则可以直接 替换/覆盖 import { create } from &amp;#39;zustand&amp;#39; // 使用 create 创建状态。 // create 接收一个函数， 函数接收一个 set 参数， set 是一个函数， 用于更新状态。 const useStore = create(set =&amp;gt; ( { count: 0, // 1.</description></item><item><title>1. 函数</title><link>https://typonotes.com/books/react/javascript/func-class/func/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/func-class/func/</guid><description>function default parameters rest parameters 函数的基本定义
关键字 function 函数名 func1 代码块 {} 另外, 函数也可以赋值给其他变量，并调用。
1. 具名函数定义 function func1() { console.log(&amp;#39;func1&amp;#39;); } // call func func1(); // func1 // 赋值给新变量 const newFunc1 = func1; newFunc1(); // func1 2. 匿名函数赋值变量 将 匿名函数 赋值给赋值给一个变量。
const varFunc = function () { console.log(&amp;#34;var function&amp;#34;); }; varFunc(); // var function 2. 接受参数 default parameters</description></item><item><title>1. 基础语法</title><link>https://typonotes.com/books/react/react/hooks/use-effect/basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/use-effect/basic/</guid><description>1. 语法规则 import { useEffect } from &amp;#39;react&amp;#39; useEffect(()=&amp;gt;{}, []) useEffect 支持两个参数
参数一是 函数 ()=&amp;gt;{}。 可以称其为 副作用函数， 在函数内部可以放置要执行的操作。 如果函数由返回值， 则表示在 组件卸载时执行， 这个后面讨论。 参数二是 数组 []（可选）， 在数组里放置 依赖项。 不同依赖项数据量导致渲染行为不一致， 这个后面讨论。 在 /src/components/hooks/UseEffectBasic.jsx 中。
import { useEffect, useState } from &amp;#34;react&amp;#34; const URL = &amp;#39;http://geek.itheima.net/v1_0/channels&amp;#39; export default function UseEffectBasic() { const [channels, setChannels] = useState([]) // 定义副作用函数， 只执行一次 useEffect(() =&amp;gt; { console.</description></item><item><title>1. 声明</title><link>https://typonotes.com/books/react/javascript/variables/variable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/variables/variable/</guid><description>变量特点
使用 let 定义。 但 同一个变量名 并不能被重复定义。 变量可以重新赋值 1. 变量定义 // 使用 let 定义 let a = 1 console.log(a); // 1 // 重新赋值 a = 2 console.log(a); // 2 // 重复定义 // let a = 3 // SyntaxError: Identifier &amp;#39;a&amp;#39; has already been declared 其他定义和使用方式
// 多个变量定义 let x = 1, y = 2 // 先定义后赋值 let z z = 1 2. 变量命名规则 变量名支持 大小写字母 [a-zA-Zs] 数字 `[0-9] 下划线 _ 美元符号 $ 不能以数字开头 // 建议用 let _abc = 123 let Abc = 123 let aBc = 123 // 语法错误 // let 1abc = 123 // SyntaxError: Invalid or unexpected token 虽然变量名中包含 $ 是合法的， 甚至是在变量名中间。 但是不建议用。 其他语言没有这种规则， 何必徒添烦恼。</description></item><item><title>1. 安装</title><link>https://typonotes.com/books/react/react/router/setup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/router/setup/</guid><description>ReactRouter 为 React 提供路由管理的组件。
安装 $ npm install react-router-dom 在 package.json 中， 可以看到版本为 6.22.1
&amp;#34;dependencies&amp;#34;: { &amp;#34;react-router-dom&amp;#34;: &amp;#34;^6.22.1&amp;#34;, }, 使用 在 /src/components/router/RootRouter.jsx 中
使用 createBrowserRouter 创建 路由列表 router。 在组件中， 使用 RouterProvider 使用路由页面。 注意： 当前路由中使用的是 element 字段， 而非 componenet。
之后就可以访问 http://localhost:3000/page1 或者 http://localhost:3000/page2 切换页面了。
import { createBrowserRouter, RouterProvider } from &amp;#34;react-router-dom&amp;#34;; // 创建路由 const router = createBrowserRouter([ { path: &amp;#34;/page1&amp;#34;, element: &amp;lt;div&amp;gt;Page1&amp;lt;/div&amp;gt;, }, { path: &amp;#34;/page2&amp;#34;, element: &amp;lt;div&amp;gt;Page2&amp;lt;/div&amp;gt; } ]) export default function RootRouter() { return ( &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;8.</description></item><item><title>1. 支持的数据类型</title><link>https://typonotes.com/books/react/react/communication/props/props/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/props/props/</guid><description>/src/components/communication/Parent2Children.jsx
props 可以传递任意数据 数字, 字符串, 布尔值 数组, 对象 函数, JSX function Parent() { return ( &amp;lt;div&amp;gt; &amp;lt;Child name={&amp;#34;Wangwu&amp;#34;} age={20} isTrue={true} list={[1, 2, 3]} obj={{ name: &amp;#34;Zhaoliu&amp;#34; }} func={() =&amp;gt; { console.log(&amp;#34;Hello&amp;#34;) }} child={&amp;lt;span&amp;gt;this is a span&amp;lt;/span&amp;gt;} /&amp;gt; &amp;lt;/div&amp;gt; ); } props 是 只读对象: 子组件 只能读取 props 中的数据， 不能直接修改。 如果要修改， 只能在父组件中 由父组件修改。 参考 子传父通信 3. 兄弟通信 状态提升</description></item><item><title>1. 数组</title><link>https://typonotes.com/books/react/javascript/data-types/array/array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/data-types/array/array/</guid><description/></item><item><title>1. 环境准备</title><link>https://typonotes.com/books/react/demos/redux-meituan/setup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/demos/redux-meituan/setup/</guid><description>1. 解压项目 解压 /src/demos/redux-meituan.tgz
2. mock 数据 创建 /src/demos/redux-meituan/mock 目录， 创建mock 数据。
$ npm install json-server 启动服务
$ json-server --watch data.json --port 3101 3. 对外提供数据 对外提供数据
const takeawayURL = &amp;#39;http://localhost:3101/takeaway&amp;#39; export { takeawayURL }</description></item><item><title>1. 组件式开发</title><link>https://typonotes.com/books/react/react/components/what-is-component/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/components/what-is-component/</guid><description>1. 组件是什么 组件是用户界面的一部分， 他可以有自己的的逻辑和外观。
组件之间 可以互相嵌套 组件 可以多次重复使用 组件化开发， 可以让开发者像搭积木一样构建一个庞大而完整的新系统。
2. 如何定义组件</description></item><item><title>1. 选择器</title><link>https://typonotes.com/books/react/css/class-selector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/css/class-selector/</guid><description>选择器 通用选择选择器 *
元素选择器 h1, div ...
类选择器 .name
ID选择器 #name
元素选择器 [name]
* {} h1 {} .left {} #app {} [title] {} 1. 选择器关系 （组合使用） 这里的所有代词都可以替换为上述选择器。
1. 后代关系 包含 亲子关系 及以后的所有后代。 选择器之间使用 空格 连接。
father .son, father grandson ...。
father son {} div grandson {} 1.</description></item><item><title>1. 配置开发环境</title><link>https://typonotes.com/books/react/setup/install/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/setup/install/</guid><description>安装 NodeJS 安装 NodeJS wget -c https://nodejs.org/dist/v20.11.0/node-v20.11.0-darwin-arm64.tar.gz tar xf node-v20.11.0-darwin-arm64.tar.gz mv node-v20.11.0-darwin-arm64 /usr/local/nodejs 配置环境变量 export NODE_ROOT=/usr/local/nodejs export PATH=$NODE_ROOT/bin:$PATH alias cnpm=&amp;#39;npm --registry=https://registry.npmmirror.com &amp;#39; 配置国内源 yarn config set registry https://registry.npmmirror.com npm config set registry https://registry.npmmirror.com Chrome 插件 React Developer Tools</description></item><item><title>2. context 跨层级通信</title><link>https://typonotes.com/books/react/react/communication/context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/context/</guid><description>和 Golang 的 context 差不多。 在 context.Provider 下的所有节点都可以通过关键字 useContext 获取数据。
解决了 props 中不相关的组件之间需要传递数据时 状态提升 的复杂操作。
使用 createContext 方法创建一个 上下文对象 Ctx 在顶层组件 (如图, App) 中使用 Ctx.Provider 组件提供数据。 在下层组件 (如图, B) 中使用 useContext 钩子获取消费数据。 在 /src/components/communication/UseContext.jsx 中， 定义三个组件形成嵌套关系
UseContext, 对应上图中的 App A 对应 A B 对应 B 1. 定义 MsgContext 在文件级别， 使用 createContext 创建 Context 对象
注意: 经测试， 创建时提供的 default value 并不起作用。 实际 可用数据 还是需要在 &amp;lt;MsgContext.</description></item><item><title>2. jsx 的常用用法</title><link>https://typonotes.com/books/react/react/jsx/basic-syntax/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/jsx/basic-syntax/</guid><description>在 jsx 中， 可以通过 大括号语法{} 识别 JavaScript 中的表达式。
常见的包括
常量调用 变量调用 函数调用 方法调用 使用 js 对象 等等 1. 常量调用 在 BasicSyntax 内部使用 {'this is const string'}
// BasicSyntax 基础语法组建 function BasicSyntax() { return ( &amp;lt;div className=&amp;#34;BasicSyntax&amp;#34;&amp;gt; &amp;lt;h3&amp;gt;1. 常量调用&amp;lt;/h3&amp;gt; &amp;lt;p&amp;gt;{&amp;#39;this is const string&amp;#39;}&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; ); } 2. 变量调用 在 BasicSyntax 组建外部定义 变量 val。 在内部使用 {val} 调用 // BasicSyntax 基础语法组建 function BasicSyntax() { return ( &amp;lt;div className=&amp;#34;BasicSyntax&amp;#34;&amp;gt; &amp;lt;h3&amp;gt;2.</description></item><item><title>2. onChange 数据双向绑定</title><link>https://typonotes.com/books/react/react/events/on-change/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/events/on-change/</guid><description>在 /src/components/event/EventOnChange.js 中实现了 数据的双向绑定。 即
使用 useState 管理变量 username 的状态 使用 {username} 实现数据 从 state 到 UI 的单向绑定。 使用 onChange 捕捉控件的变化事件。 随后通过 箭头函数 获取 当前事件目标的值(e.target.value) 并通过 setUsername 保存数据， 从而数据 从 UI 到 state 的单向绑定。 当数据更新到 state 后， React 又刷新了页面。 // Path: src/components/event/EventOnClick.js import { useState } from &amp;#34;react&amp;#34; export default function EventOnChange() { const [username, setUsername] = useState(&amp;#34;zhangsan&amp;#34;) return ( &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;OnChange 事件实现数据双向绑定&amp;lt;/h2&amp;gt; {/* 1. {username} 实现数据从 state 到 UI 的单向绑定 2.</description></item><item><title>2. Redux 与 React - 环境准备</title><link>https://typonotes.com/books/react/react/communication/redux/redux-react-setup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/redux/redux-react-setup/</guid><description>官方要求安装两个其他插件
Redux Toolkit (RTK): 官方推荐编写 Redux 逻辑的方式， 是一套工具的集合， 可以 简化书写方式
简化 store 的配置 内置 immer 支持可变状态的修改 内置 thunk 更好的支持 异步创建 react-redux: 用于 链接 Redux 和 React 的中间件
1. 插件安装 $ npm install @reduxjs/toolkit react-redux 安装后可以在 package.json 中查看版本。
&amp;#34;dependencies&amp;#34;: { &amp;#34;@reduxjs/toolkit&amp;#34;: &amp;#34;^2.2.1&amp;#34;, &amp;#34;react-redux&amp;#34;: &amp;#34;^9.1.0&amp;#34;, }, 比 教学视频 的版本高。 (2024-02-20)
&amp;#34;dependencies&amp;#34;: { &amp;#34;@reduxjs/toolkit&amp;#34;: &amp;#34;^1.9.3&amp;#34;, &amp;#34;react-redux&amp;#34;: &amp;#34;^8.0.5&amp;#34;, }, 2. store 目录结构设计 创建 /src/store 根目录，</description></item><item><title>2. switch</title><link>https://typonotes.com/books/react/javascript/control-flow/switch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/control-flow/switch/</guid><description>switch
switch (expression) { case caseExpression1: statements case caseExpression2: statements // … case caseExpressionN: statements default: statements } 如果所有分支都匹配不成功， 则进入 default 分支。 注意 default 分支是可选的。 switch (a) { case 1: console.log(&amp;#39;a is 1&amp;#39;) break default: console.log(&amp;#39;a is not 1&amp;#39;) // a is not 1 } switch (a) { case 1: console.log(&amp;#39;a is 1&amp;#39;) break } switch 的分支逻辑是 默认下沉 的。 即 一旦某一个分支匹配成功， 则以下所有分支都会被执行, 这一点和 Golang 逻辑正好相反。 Go 默认不下沉 而是使用 fallthrough 关键字主动控制。</description></item><item><title>2. vite 初始化项目</title><link>https://typonotes.com/books/react/setup/initalize/vite/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/setup/initalize/vite/</guid><description>1. 使用 vite 初始化项目 使用 vite guide 创建第一个项目
$ npm create vite@latest # ✔ Project name: … my-vite-react # ✔ Select a framework: › React # ✔ Select a variant: › JavaScript # Scaffolding project in /private/tmp/vite-demo/my-vite-react... # Done. Now run: # cd my-vite-react # npm install # npm run dev 这里创建的是 React + JSX,
入口文件: index.html, 可以在代码中看到，引用了 main.jsx 项目文件: main.jsx, App.jsx 2. npx 迁移到 vite 2.</description></item><item><title>2. VSCode</title><link>https://typonotes.com/books/react/setup/vscode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/setup/vscode/</guid><description>1. 插件 Quokka.js, Video Demo Path Intellisense JavaScript and TypeScript Nightly ES7+ React/Redux/React-Native snippets Auto Rename Tag 2. 工具 Code Inspector - Video Demo</description></item><item><title>2. while</title><link>https://typonotes.com/books/react/javascript/loop/while/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/loop/while/</guid><description>while do&amp;hellip;while 1. while 语法结构
while (condition) { // code block to be executed } Demo
let i = 0; while (i &amp;lt; 3) { console.log(i); // 0, 1, 2 i++; } 可以使用 for 循环 代替 while 循环
let j = 0 for (; j &amp;lt; 3; j++) { console.log(j); } 2. do&amp;hellip;while 基本不用</description></item><item><title>2. 不同依赖项行为</title><link>https://typonotes.com/books/react/react/hooks/use-effect/dependencies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/use-effect/dependencies/</guid><description>2. 不同依赖项的不同渲染行为 不同状态 的数组影响第一参数函数的执行。 1. 数据被省略时： 在组件加载时执行， 且在任意渲染时执行。 2. 数组为空时： 仅在组件加载时执行 （仅执行一次）。 3. 数组中有依赖项时： 在组件加载时执行， 且在 仅在依赖项变化时触发的渲染时执行
在 /src/components/hooks/UseEffectDependencies.jsx 中
import { useState, useEffect } from &amp;#34;react&amp;#34;; export default function UseEffectDependencies() { const [count, setCount] = useState(0) const [trigger, setTrigger] = useState(0) // (1) none dependency // 组件加载时，执行一次 // 无依赖项，每次组件更新时，都会执行 useEffect(() =&amp;gt; { console.log(&amp;#39;NONE: useEffect called&amp;#39;); }); // (2) empty dependency // 仅在组件加载时执行一次 useEffect(() =&amp;gt; { console.</description></item><item><title>2. 书写位置</title><link>https://typonotes.com/books/react/javascript/introduce/position/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/introduce/position/</guid><description>书写位置包括以下三部分
1. 内部 在 html body 内部书写， 使用 script 标签包裹。 通常写在最后， 即 &amp;lt;/body&amp;gt; 的前方，以便在 script 中获取 html 中的元素信息。
注意: 将 &amp;lt;script&amp;gt; 放到 HTML文件底部 附近时因为浏览器会按照代码在文件中的位置 顺序加载。 如果加载的 script 期望修改器下方的 HTML 元素，那么就因为因为元素为被加载而失败。 因此 将 js 代码放在 HTML 页面底附近通常是最好的策略。
2. 外部 即 引用js文件。
head 中引用： 公共库一般放在这里。 body 中引用： 自己写的一般放在这里， 位置参考 内部script 注意: 闭合标签中不在写其他内容。
&amp;lt;head&amp;gt; &amp;lt;script src=&amp;#34;http://cdn.example.com/jquery.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;button id=&amp;#34;name&amp;#34;&amp;gt;点我&amp;lt;/button&amp;gt; &amp;lt;script src=&amp;#34;.</description></item><item><title>2. 伪类选择器</title><link>https://typonotes.com/books/react/css/pseudo-class-selector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/css/pseudo-class-selector/</guid><description>伪类(pseudo class) 即 类所处的一种状体。 使用 冒号 : 连接 类 与 状态
a:link { color: green; } div:hover{ font-size: 30px; } 常见的状态有 (lvha), 效果与定义顺序有关系。
link : (&amp;lt;a&amp;gt; 特有属性) 表示 未访问过的 链接状态。 visited: (&amp;lt;a&amp;gt; 特有属性) 表示 访问过的 链接状态。 hover: 通用属性， 表示 鼠标悬浮 时的状态。 active: 通用属性， 表示 鼠标点击但未抬起 时的状体。</description></item><item><title>2. 使用 redux 管理数据</title><link>https://typonotes.com/books/react/demos/redux-meituan/initial-store/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/demos/redux-meituan/initial-store/</guid><description>1. 创建 takeaway slice 在 /src/demos/redux-meituan/store/modules/takeaway.js
使用 @reduxjs/toolkit 提供的 createSlice 创建 state 对象 并导出 reducer import { createSlice } from &amp;#39;@reduxjs/toolkit&amp;#39; import { defaultFoodsList } from &amp;#39;./default&amp;#39; const takeaway = createSlice({ // 名称 name: &amp;#39;takeaway&amp;#39;, // 初始数据 initialState: { foodsList: defaultFoodsList, }, // actions reducers: { } }) // 导出 reducer 在 store/index.js 中合并 const takeawayReducer = takeaway.reducer export default takeawayReducer 初始化 foodsList 的时候使用了 精简版 的默认值， 保证数据解构完整性。 以避免从服务器获取数据失败时的渲染报错。</description></item><item><title>2. 多状态管理</title><link>https://typonotes.com/books/react/react/communication/zustand/multiple/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/zustand/multiple/</guid><description>1. 切片模式 https://www.bilibili.com/video/BV1ZB4y1Z7o8?p=145
import { create } from &amp;#39;zustand&amp;#39; // 创建counter相关切片 const createCounterStore = (set) =&amp;gt; { return { count: 0, setCount: () =&amp;gt; { set(state =&amp;gt; ({ count: state.count + 1 })) } } } // 创建channel相关切片 const createChannelStore = (set) =&amp;gt; { return { channelList: [], fetchGetList: async () =&amp;gt; { const res = await fetch(URL) const jsonData = await res.json() set({ channelList: jsonData.</description></item><item><title>2. 如何定义组件</title><link>https://typonotes.com/books/react/react/components/define-component/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/components/define-component/</guid><description>组件的定义方式有两种。
函数式组件： 最常用 类式组件 组件名通常使用 大驼峰 命名方式， 即 首字母大写的驼峰
例如， MyButton, UserInfoDisplay
1. 组件的定义 1.1. 函数式组件 在 /src/components/component/FuncComponent.js 中
function FunctionButtion() { return ( &amp;lt;button&amp;gt;function buttion&amp;lt;/button&amp;gt; ) } export default FunctionButtion; 1.2. 箭头函数式组件 箭头函数也是函数， 所以和上面 function 定义没什么区别。 也在 /src/components/component/FuncComponent.js 中
export const ArrowFuncButtion = () =&amp;gt; { return ( &amp;lt;button&amp;gt;arrow func button&amp;lt;/button&amp;gt; ) } 1.3. 类式组件 这个有有点特别了， 在 React 18 中， 已经不怎么用了。</description></item><item><title>2. 字符串</title><link>https://typonotes.com/books/react/javascript/data-types/string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/data-types/string/</guid><description>string - MDN
1. 字符串 字符串 所有使用以下引号包括的内容就是
单引号: ' 双引号: &amp;quot; 反引号: ` 例如
const a = `abc` const b = &amp;#34;abc123&amp;#34; const c = &amp;#39;123&amp;#39; 2. 模版字符串 只有在 反引号 中要在字符串才是 模版字符串说， 因此其中 变量 或 表达式 才会生效
// 只有反引号(`)才能使用模板字符串 console.log(`a=${a}`); // a=abc console.log(&amp;#39;b=${b}&amp;#39;); // b=${b} console.log(&amp;#34;c=${c}&amp;#34;); // c=${c} 3. 字符串的拼接 字符串的拼接出了用 模版字符串 之外，
还可以使用 连接符 +, 直接使用 变量名 即可。</description></item><item><title>2. 常量</title><link>https://typonotes.com/books/react/javascript/variables/constant/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/variables/constant/</guid><description>常量特点： 常量是不可改变的 变量
常量使用 const 关键字定义 常量不可被重复赋值。 但如果常量是引用类型(数组/对象), 则其字段可以被修改。 其他方便 与变量一致 1. 常量的定义 // 定义常量， 简单类型 const a = 100 console.log(a) // 100 // 重新复制 // a = 200 // Error: Assignment to constant variable. // 定义常量， 引用类型（对象） const b = { name: &amp;#34;zhangsan&amp;#34; } // 可以 修改对象值 b.name = &amp;#34;lisi&amp;#34; console.log(b.name) // lisi // 不可以 重新赋值一个新对象 // b = { name: &amp;#34;wangwu&amp;#34; } // Error: Assignment to constant variable.</description></item><item><title>2. 父传子通信</title><link>https://typonotes.com/books/react/react/communication/props/parent-to-children/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/props/parent-to-children/</guid><description>/src/components/communication/Parent2Children.jsx
实现步骤
传递数据: 父组件 在 子组件 上 绑定属性 接收数据: 子组件 使用 props 参数接收数据。 function Parent() { const name = &amp;#34;Zhangsan&amp;#34;; const age = 18; return ( &amp;lt;div&amp;gt; &amp;lt;span&amp;gt;Parent Area: &amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;name=Zhangsan, age=18&amp;lt;/span&amp;gt; {/* 1. 通过属性给 Child 传递数据 */} &amp;lt;Child name={name} age={age} /&amp;gt; &amp;lt;/div&amp;gt; ); } // 2. 定义的时候， 使用 props 接收参数 function Child(props) { // 打印所有 props console.log(props); return ( &amp;lt;div&amp;gt; &amp;lt;span&amp;gt;Child Area: &amp;lt;/span&amp;gt; {/* 3. 使用的时候， 使用 props.</description></item><item><title>2. 箭头函数</title><link>https://typonotes.com/books/react/javascript/func-class/arrow-func/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/func-class/arrow-func/</guid><description>Arrow functions
箭头函数用法和 function 函数一样。
就是定义方式多了那么一点点。 主要集中在 (), {} 是否省略的问题上
() =&amp;gt; expression param =&amp;gt; expression (param) =&amp;gt; expression (param1, paramN) =&amp;gt; expression () =&amp;gt; { statements } param =&amp;gt; { statements } (param1, paramN) =&amp;gt; { statements } 箭头函数的 this 箭头函数的 this 是一个难点。 需要继续研读文档。</description></item><item><title>2. 路由导航</title><link>https://typonotes.com/books/react/react/router/navigate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/router/navigate/</guid><description>使用 路由导航 可以在不同组件之间切换。
创建两个组件 Login 和 Article。 目录结构如下。
统一 import 到 RootRouter 下管理， 对应的 router 也需要做调整。
import { createBrowserRouter, RouterProvider } from &amp;#34;react-router-dom&amp;#34;; import Login from &amp;#34;./Login&amp;#34;; import Article from &amp;#34;./Article&amp;#34;; const router = createBrowserRouter([ { path: &amp;#34;/login&amp;#34;, element: &amp;lt;Login /&amp;gt; // 登录 Login }, { path: &amp;#34;/article&amp;#34;, element: &amp;lt;Article /&amp;gt; // 文章 Article } ]) export default function RootRouter() { return ( &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;8. 路由页面 Root Page&amp;lt;/h2&amp;gt; &amp;lt;RouterProvider router={router} /&amp;gt; &amp;lt;/div&amp;gt; ); } 声明式导航 声明式导航: 是指通过在模版中使用 &amp;lt;Link /&amp;gt; 组件描述出要跳转到哪里去。 比如后台管理系统的左侧菜单通常使用这种方式进行。</description></item><item><title>3. BigInt</title><link>https://typonotes.com/books/react/javascript/data-types/number/bigint/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/data-types/number/bigint/</guid><description/></item><item><title>3. Chrome</title><link>https://typonotes.com/books/react/setup/chrome/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/setup/chrome/</guid><description>Chrome 插件 React Developer Tools Redux DevTools</description></item><item><title>3. Redux 与 React - 实现 Counter(同步)</title><link>https://typonotes.com/books/react/react/communication/redux/redux-react-counter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/redux/redux-react-counter/</guid><description>先来看一张 Redux 与 React 调用全图。
全图左右两个部分， 中间使用 store 关联起来。 左边使用 @reduxjs@toolkit 创建 reducer 管理 store. 右边使用 react-redux 获取数据并修改。 1. 创建 Slice 并初始化 counterReducer 在 /src/store/modules/counterStore.js 创建 reducer 和 actions
从 @reduxjs/toolkit 中导入并使用 createSlice 创建 通过 counterSlice.reducer 获取 reducer 并导出。 在 index.js 中引用， 创建 合并reducer 通过 counterSlice.actions 获取 actions 并导出。 在外部代码引用， 使用 useDispatch 调用修改 state 的值。 import { createSlice } from &amp;#39;@reduxjs/toolkit&amp;#39;; const counterSlice = createSlice({ // 设置名称 name: &amp;#39;counter&amp;#39;, // 设置初始状态 state initialState: { value: 0, }, // 设置修改方法 actions reducers: { increment: (state) =&amp;gt; { state.</description></item><item><title>3. TypeScript 类型支持</title><link>https://typonotes.com/books/react/react/communication/zustand/zustand-ts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/zustand/zustand-ts/</guid><description>1. 定义 需要使用 interface 指定 state 需要实现的接口 在创建的时候使用 泛型 指定 `create((set)=&amp;gt;{}) import { create } from &amp;#39;zustand&amp;#39;; // 定义参数类型 interface CounterStore { count: number; increment: (payload: number) =&amp;gt; void; set: (payload: number) =&amp;gt; void; } // create&amp;lt;CounterStore&amp;gt; 使用泛型指定 store 的类型 const useCounterStore = create&amp;lt;CounterStore&amp;gt;((set) =&amp;gt; ({ count: 0, // 修改对象，+1 increment: (payload: number) =&amp;gt; set( (state) =&amp;gt; ({ count: state.count + payload }) ), // 直接替换对象 set(payload) { set(() =&amp;gt; ({ count: payload })); } })); export default useCounterStore; 2.</description></item><item><title>3. vite 配置别名</title><link>https://typonotes.com/books/react/setup/initalize/vite-src-alias/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/setup/initalize/vite-src-alias/</guid><description>1. 安装 types/node 支持 $ npm i @types/node 2. 配置 vite 支持别名 这一步是为了 vite 在编译的时候可以使用 @ 别名符号。
所有 非注释 的内容都是 新增配置
// vite.config.ts // import { defineConfig } from &amp;#39;vite&amp;#39; // import react from &amp;#39;@vitejs/plugin-react&amp;#39; import path from &amp;#39;path&amp;#39; // https://vitejs.dev/config/ export default defineConfig({ // plugins: [react()], resolve: { alias: { &amp;#39;@&amp;#39;: path.resolve(__dirname, &amp;#39;./src&amp;#39;), }, }, }) 3. 配置 VSCode 支持别名 这一步配置是在使用 路径别名 的时候， 为了让 VSCode 支持别名路径， 且显示不报错。</description></item><item><title>3. 三元表达式</title><link>https://typonotes.com/books/react/javascript/control-flow/ternary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/control-flow/ternary/</guid><description>三元表达式(ternary)
但是 并不推荐使用 三元表达式。 推荐使用 if-else 代替。
可读性不高， 尤其是嵌套的情况下。 不支持 代码块。 condition ? exprIfTrue : exprIfFalse const expr = true expr ? console.log(&amp;#39;expr is true&amp;#39;) : console.log(&amp;#39;expr is false&amp;#39;) // expr is true; 当使用 代码块 的时候， 就出问题了。</description></item><item><title>3. 函数闭包</title><link>https://typonotes.com/books/react/javascript/func-class/closure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/func-class/closure/</guid><description>Closures
定义:
函数嵌套 内部函数 直接 使用外部函数的变量。 而非传参数使用。 Demo 代码,
function makeFunc() { const name = &amp;#34;Mozilla&amp;#34;; function displayName() { console.log(name); } return displayName; } const myFunc = makeFunc(); myFunc(); 闭包在 Go 中的应用， 辅助理解 换个 Golang 的闭包的使用案例: 配置参数
type Person struct { name string age int } type Option = func(*Person) func (p *Person) WithOptios(opts ...Option) { for _, opt := range opts { opt(p) } }</description></item><item><title>3. 列表与字典渲染</title><link>https://typonotes.com/books/react/react/jsx/list-render/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/jsx/list-render/</guid><description>代码在 /src/components/jsx/ListRender.js 中
列表默认情况是这样的
&amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;liubei&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;guanyu&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;zhangfei&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; 1. 标准版的渲染 const list = [&amp;#39;liubei&amp;#39;, &amp;#39;guanyu&amp;#39;, &amp;#39;zhangfei&amp;#39;] function ListRender() { return ( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;2.3. 循环渲染&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt; list = [&amp;#39;liubei&amp;#39;, &amp;#39;guanyu&amp;#39;, &amp;#39;zhangfei&amp;#39;]&amp;lt;/p&amp;gt; &amp;lt;h3&amp;gt;箭头函数， 完整版。 带 key &amp;lt;/h3&amp;gt; &amp;lt;ul&amp;gt; // (1) 保留外城的 ul { list.map((item, index) =&amp;gt; { // (2) 循环什么就返回什么。 // (3) key 是 React 渲染的唯一表示 return &amp;lt;li key={index}&amp;gt;{item}&amp;lt;/li&amp;gt; }) } &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; ) } 当我们要进行 列表渲染 的时候，</description></item><item><title>3. 布尔值</title><link>https://typonotes.com/books/react/javascript/data-types/boolean/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/data-types/boolean/</guid><description>1. 布尔值 布尔值 只有两个: true 和 false
2. 其他类型的布尔值 内建类型强制布尔值
许多内建类型， 在被作为 布尔值 对待时， 具有一个 强制性 的值。
Booleans are returned as-is.
undefined 返回 false. null 返回 false. 0, -0, and NaN 返回 false; 其他非零数字 返回 true. 0n 返回 false; 其他非零大数字 返回 true. 空字符串 返回 false; 非空字符串 返回 true. Symbol 返回 true. 所有对象 和 数组 返回 true. // built-in types boolean coercion console.</description></item><item><title>3. 模版字符串</title><link>https://typonotes.com/books/react/javascript/variables/format/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/variables/format/</guid><description>模版字符串可以很方便的 在字符串中插入 变量或常量
使用模版字符串
必须使用 反引号 ` 包裹字符串 需要使用 ${ expression } 格式。 其中 expression 是 表达式 或 变量 const name = &amp;#34;zhangsan&amp;#34; let age = 20 // 使用变量 console.log(`name: ${name}, age: ${age}`); // name: zhangsan, age: 2 // 模版字符串中还可以使用表达式 console.log(`1 + 2 = ${1 + 2}`); // 1 + 2 = 3 console.log(`&amp;#39;a&amp;#39;+&amp;#39;b&amp;#39;= ${&amp;#39;a&amp;#39; + &amp;#39;b&amp;#39;}`); // &amp;#39;a&amp;#39;+&amp;#39;b&amp;#39;= ab</description></item><item><title>3. 注释与结束符</title><link>https://typonotes.com/books/react/javascript/introduce/comment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/introduce/comment/</guid><description>1. 注释 单行注释 : // statment 多行注释 : /* statment */ // comment /* line 1 line 2 */ 2. 结束符 结束符为 分号 ;， 但是大部分时候 不写</description></item><item><title>3. 清理副作用</title><link>https://typonotes.com/books/react/react/hooks/use-effect/clear-side-effect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/use-effect/clear-side-effect/</guid><description>3. 清除函数副作用 useEffect 的第一个参数时一个函数。 当该函数有 return 返回值 statement 的时候， 会在 组件被卸载/取消挂载 的时候执行。
如下代码， return 返回的 箭头函数 会在其所在的组件的组件被卸载的时候 停止计时器 。
useEffect( () =&amp;gt; { const id = setInterval(() =&amp;gt; { console.log(&amp;#39;Child: setInterval called&amp;#39;); }, 1000); // 当省略清理函数时， // 组件卸载时，定时器不会被清除 // 当重新加载组件时，会创建新的定时器， 多个定时器会同时运行 return () =&amp;gt; { clearInterval(id); } }, [] // 依赖项为空数组，只有在加载时执行一次， 只有在组件卸载时才会执行清理函数 ) 如果没有这段 return 清空计时器的代码， 那么当所在组件 反复 被挂载时， 每次加载都会启动一个新的定时器， 结果就是 启动无数个 计时器。</description></item><item><title>3. 特殊的 children 插槽</title><link>https://typonotes.com/books/react/react/communication/props/slot-children/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/props/slot-children/</guid><description>/src/components/communication/RootCommunication.jsx
export default function RootCommunication() { return ( &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt; 7. 组件通信&amp;lt;/h2&amp;gt; {/* 1. 自闭和标签 */} &amp;lt;Parent2Children /&amp;gt; {/* 2. 成对标签， 默认插槽 */} &amp;lt;PropChild&amp;gt; &amp;lt;span&amp;gt;span1&amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;span2&amp;lt;/span&amp;gt; &amp;lt;/PropChild&amp;gt; &amp;lt;/div&amp;gt; ); } 可以看到在使用 PropChild
使用的是 成对标签。 标签中放入了两个 span 标签。 function PropChild(props) { return ( &amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;7.1. 特殊的 props.children&amp;lt;/h3&amp;gt; {/* 拿到默认的 children 属性 */} &amp;lt;span&amp;gt;prop child: {props.children}&amp;lt;/span&amp;gt; &amp;lt;hr /&amp;gt; &amp;lt;/div&amp;gt; ) } 在 PropChild 内部， 使用 props.children 拿到了传过来的标签值
使用 React Developer Tool 可以更清晰的看到其属性</description></item><item><title>3. 类</title><link>https://typonotes.com/books/react/javascript/func-class/class/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/func-class/class/</guid><description/></item><item><title>3. 菜单交互</title><link>https://typonotes.com/books/react/demos/redux-meituan/menu/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/demos/redux-meituan/menu/</guid><description>1. 菜单选中 在 /src/demos/redux-meituan/store/modules/takeaway.js 中
增加新的 state 字段 activeIndex 表示选中的菜单。 其值为对应的 foodsList 数组的 index 位置。 增加新的 reducer action setActiveIndex , 这是一个 同步 方法。 导出 setActiveIndex 以供外部使用 部分代码
const takeaway = createSlice({ // 名称 name: &amp;#39;takeaway&amp;#39;, // 初始数据 initialState: { // 当前选中的菜单分类 activeIndex: 0, }, // actions reducers: { setActiveIndex: (state, action) =&amp;gt; { state.activeIndex = action.payload } } }) // 省略 .</description></item><item><title>3. 路由传参</title><link>https://typonotes.com/books/react/react/router/navigate-params/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/router/navigate-params/</guid><description>有 两种 方式可以通过 路由地址 进行参数传递。
路径传参: /path/1234/zhangsan query请求传参: /article?id=1101&amp;amp;name=wangwu 1. 路径传参 顾名思义， 就是 将参数放在 path 中。
在使用之前需要 定义参数名称和位置。 使用 useParams 接受参数 在 /src/components/router/RootRouter.jsx 中
const router = createBrowserRouter([ { // 定义参数位置和名称 path: &amp;#34;/article/:id/:name&amp;#34;, element: &amp;lt;Article /&amp;gt; } ]) 在 /src/components/router/Article/index.jsx 中使用 useParams 使用 解构赋值 接受参数
import { Link } from &amp;#34;react-router-dom&amp;#34;; import { useParams } from &amp;#34;react-router-dom&amp;#34;; export default function Article() { // 使用 解构赋值 获取路由参数 const { id, name } = useParams(); return ( &amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;8.</description></item><item><title>4. Redux 与 React - 实现 Channel (异步)</title><link>https://typonotes.com/books/react/react/communication/redux/redux-react-channel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/redux/redux-react-channel/</guid><description>异步 的实现方法和同步差不多。
1. 使用 createSlice 创建 在 /src/store/modules/channelStore.js 中创建 Channel Store。 这一步同步是一样的。
const channelSlice = createSlice({ // 名称 name: &amp;#39;channel&amp;#39;, // 初始化数据 initialState: { channels: [ { id: 1, name: &amp;#39;网络不通， 检查网络&amp;#39; }, ], }, // actions 方法 reducers: { setChannels(state, action) { state.channels = action.payload; } }, }) 2. 导出 reducer 到 store/index.js 这一部分也一样
在 /src/store/modules/channelStore.js 中导出 reduder，</description></item><item><title>4. undefined and null</title><link>https://typonotes.com/books/react/javascript/data-types/undefined-null/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/data-types/undefined-null/</guid><description>undefined - mdn
1. undefined undefined 类型的的值就是 undefined。 undefined 具有一下特征
不可写 不可枚举 不可配置 以下代码 合法但有病
Note: While you can use undefined as an identifier (variable name) in any scope other than the global scope (because undefined is not a reserved wor 保留字符), doing so is a very bad idea that will make your code difficult to maintain and debug.
// DON&amp;#39;T DO THIS (() =&amp;gt; { const undefined = &amp;#34;foo&amp;#34;; console.</description></item><item><title>4. 作用域</title><link>https://typonotes.com/books/react/javascript/variables/scope/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/variables/scope/</guid><description>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#variables
作用域是指 变量和常量 的生效范围。 即 在哪里定义， 就在哪里生效
全局范围: 所有代码的默认作用域 模块范围: 模块代码 函数范围: 函数内 let x = 100 if (true) { let x = 5; // block-scoped to the containing if statement console.log(x); // 5 } console.log(x); // 100 let z = 100 if (true) { z = 5; // modify, not re-declare } console.log(z); // z is 5 2. 函数作用域 // 函数作用域 function bigger(a, b) { if (a &amp;gt; b) { let res = &amp;#34;a &amp;gt; b&amp;#34;; } else { let res = &amp;#34;a &amp;lt; b&amp;#34; } } console.</description></item><item><title>4. 函数柯里化</title><link>https://typonotes.com/books/react/javascript/func-class/currying/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/func-class/currying/</guid><description/></item><item><title>4. 子传父通信</title><link>https://typonotes.com/books/react/react/communication/props/children-to-parent/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/props/children-to-parent/</guid><description>/src/components/communication/Children2Parent.jsx
核心思路: 父组件可以给子组件传递一个函数， 子组件通过调用函数向父组件传递数据
父组件通过 props 向子组件传递数据， 但 在子组件中 props 是只读的。 因此 数据只能在父组件中被修改 function Parent() { const original = &amp;#34;Father.React&amp;#34; // 在父组件定义一个状态数据 const [name, setName] = useState(original) // 重置名字 function resetName() { setName(original) } // 1. 通过函数修改父组件的状态数据 function changeName(name) { setName(name) } return ( &amp;lt;div&amp;gt; &amp;lt;p&amp;gt;父组件名字: {name}&amp;lt;/p&amp;gt; &amp;lt;b&amp;gt;父组件区域: &amp;lt;/b&amp;gt; &amp;lt;button onClick={resetName}&amp;gt;重置名称&amp;lt;/button&amp;gt; &amp;lt;span&amp;gt;重置父组件名字&amp;lt;/span&amp;gt; {/* 1. 通过 props 将函数传递给子组件 2. props 属性名字加上 on 表示调用执行 */} &amp;lt;hr&amp;gt;&amp;lt;/hr&amp;gt; &amp;lt;Child onChangeName={changeName} /&amp;gt; &amp;lt;/div&amp;gt; ) } 在 父组件中</description></item><item><title>4. 嵌套路由</title><link>https://typonotes.com/books/react/react/router/nested-routers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/router/nested-routers/</guid><description>嵌套路由: 在一级路由中 内嵌 了其他路由， 这种路由关系就叫做 嵌套路由。
嵌套到一级路由内的路由又被称为 二级路由。 以此类推， 三级、四级路由。
最常见应用场景， 就是 系统管理界面， 如图。
1. 使用 children 属性配置路由嵌套关系 在 /src/components/router/RootRouter.jsx 中， 添加路由表。
const router = createBrowserRouter([ { path: &amp;#34;/&amp;#34;, element: &amp;lt;Layout /&amp;gt;, // 指定子路由 children: [ // 子路由与父路由定义方式一样 { path: &amp;#34;/board&amp;#34;, element: &amp;lt;Board /&amp;gt; }, { path: &amp;#34;/about&amp;#34;, element: &amp;lt;About /&amp;gt; } ], } ]) 2. 使用 &amp;lt;Outlet /&amp;gt; 指定二级路由渲染位置 在 /src/components/router/Layout/index.</description></item><item><title>4. 条件渲染</title><link>https://typonotes.com/books/react/react/jsx/conditional-render/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/jsx/conditional-render/</guid><description>React 根据条件运算返回的不同结果进行结果渲染， 主要分为以下几种
逻辑判断： &amp;amp;&amp;amp;, ||, ! 三目运算符: condition? yes : no 分支语句： if-else, switch 1. 逻辑运算符 逻辑运算符：
&amp;amp;&amp;amp; 且 || 或 ! 非 function ConditionalRender() { return ( &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;04. 条件渲染: isLogin={String(isLogin)}&amp;lt;/h2&amp;gt; &amp;lt;h3&amp;gt;1. 逻辑语句&amp;lt;/h3&amp;gt; &amp;lt;p&amp;gt;isLogin &amp;amp;&amp;amp; Login &amp;lt;/p&amp;gt; {isLogin &amp;amp;&amp;amp; &amp;lt;Login /&amp;gt;} &amp;lt;p&amp;gt;isLogin || Logout&amp;lt;/p&amp;gt; {isLogin || &amp;lt;Logout /&amp;gt;} &amp;lt;p&amp;gt;isLogin &amp;amp;&amp;amp; Login || Logout&amp;lt;/p&amp;gt; {isLogin &amp;amp;&amp;amp; &amp;lt;Login /&amp;gt; || &amp;lt;Logout /&amp;gt;} {(isLogin &amp;amp;&amp;amp; &amp;lt;Login /&amp;gt;) || &amp;lt;Logout /&amp;gt;} &amp;lt;/div &amp;gt; ) } const isLogin = false; 条件语句 必须要在最前面。 &amp;amp;&amp;amp; 和 || 可以单独使用； 也可以一起使用， 一起使用时效果类似 三目运算符。 但是 React 并不推荐这么做， 如果这样做了会给予提示： 混合使用 &amp;amp;&amp;amp; 和 ||。 请用 圆括号 指定执行顺序</description></item><item><title>4. 购物车管理</title><link>https://typonotes.com/books/react/demos/redux-meituan/cart-list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/demos/redux-meituan/cart-list/</guid><description>1. 添加购物车 在 /src/demos/redux-meituan/components/Cart/index.js 中可以看到 购物车 的相关配置。
可以看到 购物车 的数据定义是 cart=[] 空数组。
const Cart = () =&amp;gt; { const cart = [] // 省略 ... } 在 /src/demos/redux-meituan/components/FoodsCategory/FoodItem/index.js 中
可以看到 具体商品 配置。 从传入的 props 中解构出来了所有商品字段。
const Foods = ({ id, picture, name, unit, description, food_tag_list, month_saled, like_ratio_desc, price, tag, count }) =&amp;gt; { // 省略 ... } 1.1. 优化 store 因此在 /src/demos/redux-meituan/store/modules/takeaway.js 中</description></item><item><title>4. 输入输出</title><link>https://typonotes.com/books/react/javascript/introduce/input-output/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/introduce/input-output/</guid><description>1. 输入 prompt // 输入 const name = prompt(&amp;#39;请输入你的名字&amp;#39;); 2. 输出 document.write console.log alert // 输出 console.log(&amp;#39;可以输出信息到控制台: &amp;#39; + name); document.write(&amp;#39;可以输出信息到页面: &amp;#39; + name); alert(&amp;#39;可以弹出一个警告框: &amp;#39; + name); demo input-output.html
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt; &amp;lt;title&amp;gt;1.5 输入输出&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;script&amp;gt; // 输入 const name = prompt(&amp;#39;请输入你的名字&amp;#39;); // 输出 console.</description></item><item><title>5. 兄弟通信</title><link>https://typonotes.com/books/react/react/communication/props/brothers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/props/brothers/</guid><description>/src/components/communication/Brothers.jsx
兄弟组件没有关联关系， 因此需要 通过共同的父组件 进行数据的传递。 这并不是一个新东西， 而是将 父传子、子传父 组合案例。
function Parent() { // 1. 在父节点定义状态数据 const [name, setName] = useState(&amp;#34;&amp;#34;) // 2. 在父节点定义修改状态数据的方法 function changeName(name) { setName(name) } return ( &amp;lt;div&amp;gt; {/* 3. 给 Child A 传递修改数据方法 */} &amp;lt;ChildA onChangeName={changeName} /&amp;gt; {/* 3. 给 Child B 传递数据 */} &amp;lt;ChildB name={name} /&amp;gt; &amp;lt;/div&amp;gt; ); } 在 父节点
使用 useState 定义状态数据 name 定义 修改函数 changeName 将修改传输传递给 ChildA, 将状态数据传递给 ChildB function ChildA({ onChangeName }) { return ( &amp;lt;div&amp;gt; &amp;lt;b&amp;gt;Child A: &amp;lt;/b&amp;gt; {/* 4.</description></item><item><title>5. 字面量</title><link>https://typonotes.com/books/react/javascript/introduce/literal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/introduce/literal/</guid><description>一个概念， 不用深究。
在计算机科学中， 字面量(literal) 就是 在计算机中描述的事或物
工资是 1000 中 1000 就是 数字字面量 名字是 zhangsan 中的 zhangsan 就是 字符串字面量 [] 表示 数组字面量 {} 表示 对象字面量 以及其他</description></item><item><title>5. 样式的使用</title><link>https://typonotes.com/books/react/react/jsx/style/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/jsx/style/</guid><description>源代码在 /src/components/styles/RootStyle.jsx
1. 行内样式 在标签内使用使用 style={{key:v1, k2:v2}} 实现样式管理。
&amp;lt;p style={{ color: &amp;#34;red&amp;#34;, fontSize: &amp;#34;18px&amp;#34; }}&amp;gt;1.1. 行内样式&amp;lt;/p&amp;gt; 外层 {}: 开始 React 语法。 {k1:v1, k2:v2}: 是一个 Object 对象。 key 使用 驼峰 规则: font-size =&amp;gt; fontSize 向上面直接写在行内的方式， 管理起来并不清晰。 因此可以将 样式 赋值给一个 变量 保存。
export default function RootStyle() { return ( &amp;lt;div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;p style={style}&amp;gt;1.2. 行内样式2&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; ) } const style = { color: &amp;#34;blue&amp;#34;, fontSize: &amp;#34;18px&amp;#34; } 2.</description></item><item><title>5. 默认路由</title><link>https://typonotes.com/books/react/react/router/default-router/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/router/default-router/</guid><description>在 router 配置的时候， path 的值使用 * 即可配置默认路径。 当用户访问路径无法匹配时返回。
通常， 默认路径可以用于 优化 404 页面， 提高用户体验。
在 /src/components/router/RootRouter.jsx 中,
const router = createBrowserRouter([ { // 使用 * 匹配所有路由 path: &amp;#34;*&amp;#34;, element: &amp;lt;NotFound /&amp;gt; } ])</description></item><item><title>6. 对象</title><link>https://typonotes.com/books/react/javascript/data-types/object/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/data-types/object/</guid><description/></item><item><title>6. 路由模式</title><link>https://typonotes.com/books/react/react/router/router-modes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/router/router-modes/</guid><description>路由模式 URL表现 底层原理 是否需要后端支持 history url/login history对象+pushState事件 需要 hash url/#/login 监听 hashChange 事件 不需要 memory url ?? ?? 1. Hash 模式 使用 createHashRouter 创建 Hash 模式。 path 上有 # 。 单页面模式
import { createHashRouter } from &amp;#34;react-router-dom&amp;#34;; const router = createHashRouter([ { path: &amp;#34;/login&amp;#34;, element: &amp;lt;Login /&amp;gt; } ]) 2. Memory 模式 使用 createMemoryRouter 模式。 path 路径 不会 在 URL 上体现出来。 单页面模式</description></item><item><title>6. 迭代器</title><link>https://typonotes.com/books/react/javascript/data-types/array/iter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/data-types/array/iter/</guid><description>前端面试：解构的原理是什么？如何修改这段代码使其正确执行？
let [x, y] = {x: 1, y:2} console.log(x,y)</description></item><item><title>7. 类型转换</title><link>https://typonotes.com/books/react/javascript/data-types/convert/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/javascript/data-types/convert/</guid><description/></item><item><title>classnames</title><link>https://typonotes.com/books/react/library/chassnames/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/library/chassnames/</guid><description> 项目地址: https://github.com/JedWatson/classnames
安装方式 npm install classnames Demo import classNames from &amp;#39;classnames&amp;#39;; classNames(&amp;#39;foo&amp;#39;, &amp;#39;bar&amp;#39;); // =&amp;gt; &amp;#39;foo bar&amp;#39; classNames(&amp;#39;foo&amp;#39;, { bar: true }); // =&amp;gt; &amp;#39;foo bar&amp;#39; classNames({ &amp;#39;foo-bar&amp;#39;: true }); // =&amp;gt; &amp;#39;foo-bar&amp;#39; classNames({ &amp;#39;foo-bar&amp;#39;: false }); // =&amp;gt; &amp;#39;&amp;#39; classNames({ foo: true }, { bar: true }); // =&amp;gt; &amp;#39;foo bar&amp;#39; classNames({ foo: true, bar: true }); // =&amp;gt; &amp;#39;foo bar&amp;#39; // lots of arguments of various types classNames(&amp;#39;foo&amp;#39;, { bar: true, duck: false }, &amp;#39;baz&amp;#39;, { quux: true }); // =&amp;gt; &amp;#39;foo bar baz quux&amp;#39; // other falsy values are just ignored classNames(null, false, &amp;#39;bar&amp;#39;, undefined, 0, { baz: null }, &amp;#39;&amp;#39;); // =&amp;gt; &amp;#39;bar&amp;#39;</description></item><item><title>dayjs 时间处理</title><link>https://typonotes.com/books/react/library/dayjs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/library/dayjs/</guid><description>dayjs 是一款 nodejs 的 时间 处理库。 与 js 原生时间库 Date 相比， 更好用。
官网: https://day.js.org/docs/en/installation/typescript 中文网: https://dayjs.fenxianglu.cn/category/#node-js 1. install
npm install dayjs 2. Usage
import dayjs from &amp;#39;dayjs&amp;#39; // https://day.js.org/docs/en/parse/string-format dayjs().format(&amp;#39;YYYY-MM-DD HH:mm:ss&amp;#39;) // 2023-03-18 19:33:24 更多直接查看官网。</description></item><item><title>lodash 工具库</title><link>https://typonotes.com/books/react/library/lodash/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/library/lodash/</guid><description/></item><item><title>props - ts</title><link>https://typonotes.com/books/react/react/react-ts/props-ts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/react-ts/props-ts/</guid><description>1. 使用 type 或者 interface 注解 props 注解的本质， 就是 限定函数参数类型。
可是使用 type 或者 interface 进行注解 在使用 props 的时候 传递整个对象: const TypeProps = (props: Props) =&amp;gt; {} 解耦部分字段，注意不能省略注解类型: const IterfaceProps = ({ name }: IProps) =&amp;gt; {} type Props = { name: string age: number } // 使用 Type 注解 // 获取整个 props const TypeProps = (props: Props) =&amp;gt; { return ( &amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;Props Basic&amp;lt;/h3&amp;gt; &amp;lt;p&amp;gt;{props.</description></item><item><title>redux - ts</title><link>https://typonotes.com/books/react/react/communication/redux/redux-ts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/redux/redux-ts/</guid><description>3. redux 3.1. 导出 store 的 IRootState 参考: https://stackoverflow.com/a/60223837
// 在 store/index.ts 中 // https://stackoverflow.com/a/60223837 export type IRootState = ReturnType&amp;lt;typeof store.getState&amp;gt; 3.2. 使用 useSelector 指定 state 类型 在使用 useSelector 指定 state 类型
// 导入 import { IRootState } from &amp;#34;../../../store&amp;#34; // 使用 let { todos } = useSelector((state: IRootState) =&amp;gt; state.todolist)</description></item><item><title>useContext 数据传递</title><link>https://typonotes.com/books/react/react/hooks/use-context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/use-context/</guid><description/></item><item><title>useImmer 状态数据</title><link>https://typonotes.com/books/react/react/hooks/use-immer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/use-immer/</guid><description>useImmer 是 useState 的 加强版。
https://github.com/immerjs/use-immer npm install immer use-immer</description></item><item><title>useRef - ts</title><link>https://typonotes.com/books/react/react/react-ts/use-ref-ts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/react-ts/use-ref-ts/</guid><description>https://github.com/panda-frontend/react-ts-todolist
/src/componenets/TodoList/Input/index.tsx
1. 指定 HTML Element 使用 useRef 的时候， 要指定 HTML Element。 全部元素在 https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement
// https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement const inputRef = useRef&amp;lt;HTMLInputElement&amp;gt;(null); 1.1. 判断 xxxRef.current 是否存在 由于 xxxRef.current 可能不存在， 因此使用的时候需要判断存在才能取值 xxxRef.current.value
方式一, 使用 问号
xxxRef.current?value 方式二， 使用 逻辑语句
const addItem = () =&amp;gt; { // 如果值为空，不添加 if (!inputRef.current?.value) { return } const item: ToDo = { id: Date.now(), title: inputRef.current?.value, completed: false } // dispath 调用 action 添加新条目 dispatch(addTodo(item)) // 添加完成后清空 input 框 inputRef.</description></item><item><title>useRef 获取 DOM</title><link>https://typonotes.com/books/react/react/hooks/use-ref/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/use-ref/</guid><description>在 React 中 获取/操作 DOM， 需要使用 useRef 钩子函数
import { useRef } from &amp;#39;react&amp;#39;; export default function UseRef() { // 1. 使用 useRef 生成 ref 对象 const inputRef = useRef(null); function showDOM() { // 使用 console.log 查看 ref 对象 console.log(inputRef.current); // 使用 console.dir 展开 ref 对象 console.dir(inputRef.current); // 焦点锁定 inputRef.current.focus() } return ( &amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;3. useRef 获取 DOM&amp;lt;/h3&amp;gt; &amp;lt;p&amp;gt;点击 Button 在控制台查看输出&amp;lt;/p&amp;gt; {/* 将 ref 绑定到标签属性上 */} &amp;lt;input type=&amp;#34;text&amp;#34; ref={inputRef} /&amp;gt; {/* 3.</description></item><item><title>useState - ts</title><link>https://typonotes.com/books/react/react/react-ts/use-state-ts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/react-ts/use-state-ts/</guid><description>1. 类型推导 类型推导的根本
不在于 是否简单类型还是复杂类型。 而是 在于初始化的时候，是否传入了明确的值。 如果有明确的值， 就可以推导。 // 简单类型推导 const [count, setCount] = useState(0); // const count: number // 复杂类型推导 const [names, setNames] = useState([&amp;#39;zhangsan&amp;#39;, &amp;#39;lisi&amp;#39;]); // const names: string[] // 自定义类型的类型推导 const p: Person = { name: &amp;#39;zhangsan&amp;#39;, age: 18 } const [person, setPerson] = useState(p); // const person: Person 2. 泛型参数 没有明确初始化值的时候， 可以指定 泛型参数 明确类型约束 当指定了泛型参数后， 如果没有指定参数， 则变量为联合类型（ 指定类型 + undefined ） 如果指定了明确参数， 则为指定的类型 // 简单类型 // 只指定 泛型类型， 不指定默认参数。 变量类型为联合类型， 多一个 undefined const [name, setName] = useState&amp;lt;string&amp;gt;() // const name: string | undefined // 复杂类型 const [ages, setAges] = useState&amp;lt;Array&amp;lt;number&amp;gt;&amp;gt;() // const arr: number[] | undefined const [numbers, setNumbers] = useState&amp;lt;number[]&amp;gt;() // const arr: number[] | undefined // 自定类型 const [person, setPerson] = useState&amp;lt;IPerson&amp;gt;() // const person: IPerson | undefined // 同时指定 泛型类型 和 指定参数。 变量类型固定。 const zhangsan: IPerson = { name: &amp;#39;zhangsan&amp;#39;, age: 18 } const [user, setUser] = useState&amp;lt;IPerson&amp;gt;(zhangsan) // const user: IPerson 3.</description></item><item><title>useState 状态数据</title><link>https://typonotes.com/books/react/react/hooks/use-state/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/use-state/</guid><description>React 讲究的是 数据驱动页面。 意思是 当状态数据被修改了，页面内容也会被重新渲染更新。
如果要上述这个效果， 就需要用到 useState 这个 钩子(Hook)
使用 useState 时， 需要先导入。 import { useState } from &amp;#34;react&amp;#34; 使用 const/let 进行结构赋值。 count 和 setCount 是一对 3. useState 创建 状态， 并定义变量的默认值。 count 被称为状态变量，不应该被直接修改， 推荐使用 const 初始化 setCount 是一个函数, 修改 count 的函数。 通过 setCount 修改 count 的值，会触发相关组件的重新渲染。 // const: count 不能被修改 const [count, setCount] = useState(0) // let: count 可以被修改 let [count, setCount] = useState(0) 注意: 使用 let 定义时， count 非只读， 可以直接修改。 但不会触发组件的重新渲染。</description></item><item><title>uuid</title><link>https://typonotes.com/books/react/library/uuid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/library/uuid/</guid><description>uuid 生成 UUID 随机数。
https://github.com/uuidjs/uuid https://www.npmjs.com/package/uuid 1. Install npm install uuid 2. Create a UUID (ES6 module syntax)
import { v4 as uuidv4 } from &amp;#39;uuid&amp;#39;; uuidv4(); // ⇨ &amp;#39;9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d&amp;#39; &amp;hellip; or using CommonJS syntax:
const { v4: uuidv4 } = require(&amp;#39;uuid&amp;#39;); uuidv4(); // ⇨ &amp;#39;1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed&amp;#39; const { v4: uuidv4 } = require(&amp;#39;uuid&amp;#39;); uuidv4(); // ⇨ &amp;#39;1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed&amp;#39;</description></item><item><title>自定义 Hook</title><link>https://typonotes.com/books/react/react/hooks/customize-hook/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/customize-hook/</guid><description>简单的说 自定义 Hook 就是创建一个以 use开头的函数。 往复杂了说还需要考虑各种数据状态、冲突。
自定义 Hook 通用思路 以 use 开头的函数 函数内部可以调用其他 Hook 通常返回一个数组或对象（包含状态数据和控制方法）， 以便在组件中使用 其他组件则可以直接调用该函数，而不需要关心内部实现 代码在 /src/components/hooks/CustomizeHook.jsx
1. 原始对象， 直接管理 export default function CustomizeHook() { // 使用 useState 直接管理 const [isShow, setIsShow] = useState(true) const toggle = () =&amp;gt; { setIsShow(!isShow) } return ( &amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;5. CustomizeHook&amp;lt;/h3&amp;gt; &amp;lt;button onClick={toggle}&amp;gt;Toggle: 隐藏或显示&amp;lt;/button&amp;gt; {isShow &amp;amp;&amp;amp; &amp;lt;p&amp;gt;this is a span&amp;lt;/p&amp;gt;} &amp;lt;/div&amp;gt; ) } 2.</description></item></channel></rss>